/* Copyright 2013 Chris Wilson

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

/*! jQuery v2.1.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */

/* jQuery Tiny Pub/Sub - v0.7 - 10/27/2011
 * http://benalman.com/
 * Copyright (c) 2011 "Cowboy" Ben Alman; Licensed MIT, GPL */

/*!
 * VERSION: 1.12.1
 * DATE: 2014-06-26
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.2
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

function FastClick(e, t) {
	function r(e, t) {
		return function() {
			return e.apply(t, arguments)
		}
	}
	var n;
	t = t || {}, this.trackingClick = !1, this.trackingClickStart = 0, this.targetElement = null, this.touchStartX = 0, this.touchStartY = 0, this.lastTouchIdentifier = 0, this.touchBoundary = t.touchBoundary || 10, this.layer = e, this.tapDelay = t.tapDelay || 200;
	if (FastClick.notNeeded(e)) return;
	var i = ["onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel"],
		s = this;
	for (var o = 0, u = i.length; o < u; o++) s[i[o]] = r(s[i[o]], s);
	deviceIsAndroid && (e.addEventListener("mouseover", this.onMouse, !0), e.addEventListener("mousedown", this.onMouse, !0), e.addEventListener("mouseup", this.onMouse, !0)), e.addEventListener("click", this.onClick, !0), e.addEventListener("touchstart", this.onTouchStart, !1), e.addEventListener("touchmove", this.onTouchMove, !1), e.addEventListener("touchend", this.onTouchEnd, !1), e.addEventListener("touchcancel", this.onTouchCancel, !1), Event.prototype.stopImmediatePropagation || (e.removeEventListener = function(t, n, r) {
		var i = Node.prototype.removeEventListener;
		t === "click" ? i.call(e, t, n.hijacked || n, r) : i.call(e, t, n, r)
	}, e.addEventListener = function(t, n, r) {
		var i = Node.prototype.addEventListener;
		t === "click" ? i.call(e, t, n.hijacked || (n.hijacked = function(e) {
			e.propagationStopped || n(e)
		}), r) : i.call(e, t, n, r)
	}), typeof e.onclick == "function" && (n = e.onclick, e.addEventListener("click", function(e) {
		n(e)
	}, !1), e.onclick = null)
}
define("AudioContextMonkeyPatch", [], function() {
	(function(e, t, n) {
		function r(e) {
			if (!e) return;
			e.setTargetAtTime || (e.setTargetAtTime = e.setTargetValueAtTime)
		}
		window.hasOwnProperty("webkitAudioContext") && !window.hasOwnProperty("AudioContext") && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty("createGain") || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty("createDelay") || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty("createScriptProcessor") || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function() {
			var e = this.internal_createGain();
			return r(e.gain), e
		}, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function(e) {
			var t = e ? this.internal_createDelay(e) : this.internal_createDelay();
			return r(t.delayTime), t
		}, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function() {
			var e = this.internal_createBufferSource();
			return e.start || (e.start = function(e, t, n) {
				t || n ? this.noteGrainOn(e, t, n) : this.noteOn(e)
			}), e.stop || (e.stop = e.noteOff), r(e.playbackRate), e
		}, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function() {
			var e = this.internal_createDynamicsCompressor();
			return r(e.threshold), r(e.knee), r(e.ratio), r(e.reduction), r(e.attack), r(e.release), e
		}, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function() {
			var e = this.internal_createBiquadFilter();
			return r(e.frequency), r(e.detune), r(e.Q), r(e.gain), e
		}, AudioContext.prototype.hasOwnProperty("createOscillator") && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function() {
			var e = this.internal_createOscillator();
			return e.start || (e.start = e.noteOn), e.stop || (e.stop = e.noteOff), r(e.frequency), r(e.detune), e
		}))
	})(window)
}), ! function(e, t) {
	"object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
		if (!e.document) throw new Error("jQuery requires a window with a document");
		return t(e)
	} : t(e)
}("undefined" != typeof window ? window : this, function(a, b) {
	function s(e) {
		var t = e.length,
			n = o.type(e);
		return "function" === n || o.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
	}

	function x(e, t, n) {
		if (o.isFunction(t)) return o.grep(e, function(e, r) {
			return !!t.call(e, r, e) !== n
		});
		if (t.nodeType) return o.grep(e, function(e) {
			return e === t !== n
		});
		if ("string" == typeof t) {
			if (w.test(t)) return o.filter(t, e, n);
			t = o.filter(t, e)
		}
		return o.grep(e, function(e) {
			return g.call(t, e) >= 0 !== n
		})
	}

	function D(e, t) {
		while ((e = e[t]) && 1 !== e.nodeType);
		return e
	}

	function G(e) {
		var t = F[e] = {};
		return o.each(e.match(E) || [], function(e, n) {
			t[n] = !0
		}), t
	}

	function I() {
		m.removeEventListener("DOMContentLoaded", I, !1), a.removeEventListener("load", I, !1), o.ready()
	}

	function K() {
		Object.defineProperty(this.cache = {}, 0, {
			get: function() {
				return {}
			}
		}), this.expando = o.expando + Math.random()
	}

	function P(e, t, n) {
		var r;
		if (void 0 === n && 1 === e.nodeType)
			if (r = "data-" + t.replace(O, "-$1").toLowerCase(), n = e.getAttribute(r), "string" == typeof n) {
				try {
					n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : +n + "" === n ? +n : N.test(n) ? o.parseJSON(n) : n
				} catch (i) {}
				M.set(e, t, n)
			} else n = void 0;
		return n
	}

	function Z() {
		return !0
	}

	function $() {
		return !1
	}

	function _() {
		try {
			return m.activeElement
		} catch (e) {}
	}

	function jb(e, t) {
		return o.nodeName(e, "table") && o.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
	}

	function kb(e) {
		return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
	}

	function lb(e) {
		var t = gb.exec(e.type);
		return t ? e.type = t[1] : e.removeAttribute("type"), e
	}

	function mb(e, t) {
		for (var n = 0, r = e.length; r > n; n++) L.set(e[n], "globalEval", !t || L.get(t[n], "globalEval"))
	}

	function nb(e, t) {
		var n, r, i, s, u, a, f, l;
		if (1 === t.nodeType) {
			if (L.hasData(e) && (s = L.access(e), u = L.set(t, s), l = s.events)) {
				delete u.handle, u.events = {};
				for (i in l)
					for (n = 0, r = l[i].length; r > n; n++) o.event.add(t, i, l[i][n])
			}
			M.hasData(e) && (a = M.access(e), f = o.extend({}, a), M.set(t, f))
		}
	}

	function ob(e, t) {
		var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
		return void 0 === t || t && o.nodeName(e, t) ? o.merge([e], n) : n
	}

	function pb(e, t) {
		var n = t.nodeName.toLowerCase();
		"input" === n && T.test(e.type) ? t.checked = e.checked : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
	}

	function sb(e, t) {
		var n = o(t.createElement(e)).appendTo(t.body),
			r = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(n[0]).display : o.css(n[0], "display");
		return n.detach(), r
	}

	function tb(e) {
		var t = m,
			n = rb[e];
		return n || (n = sb(e, t), "none" !== n && n || (qb = (qb || o("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = qb[0].contentDocument, t.write(), t.close(), n = sb(e, t), qb.detach()), rb[e] = n), n
	}

	function xb(e, t, n) {
		var r, i, s, u, a = e.style;
		return n = n || wb(e), n && (u = n.getPropertyValue(t) || n[t]), n && ("" !== u || o.contains(e.ownerDocument, e) || (u = o.style(e, t)), vb.test(u) && ub.test(t) && (r = a.width, i = a.minWidth, s = a.maxWidth, a.minWidth = a.maxWidth = a.width = u, u = n.width, a.width = r, a.minWidth = i, a.maxWidth = s)), void 0 !== u ? u + "" : u
	}

	function yb(e, t) {
		return {
			get: function() {
				return e() ? void delete this.get : (this.get = t).apply(this, arguments)
			}
		}
	}

	function Fb(e, t) {
		if (t in e) return t;
		var n = t[0].toUpperCase() + t.slice(1),
			r = t,
			i = Eb.length;
		while (i--)
			if (t = Eb[i] + n, t in e) return t;
		return r
	}

	function Gb(e, t, n) {
		var r = Ab.exec(t);
		return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
	}

	function Hb(e, t, n, r, i) {
		for (var s = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, u = 0; 4 > s; s += 2) "margin" === n && (u += o.css(e, n + R[s], !0, i)), r ? ("content" === n && (u -= o.css(e, "padding" + R[s], !0, i)), "margin" !== n && (u -= o.css(e, "border" + R[s] + "Width", !0, i))) : (u += o.css(e, "padding" + R[s], !0, i), "padding" !== n && (u += o.css(e, "border" + R[s] + "Width", !0, i)));
		return u
	}

	function Ib(e, t, n) {
		var r = !0,
			i = "width" === t ? e.offsetWidth : e.offsetHeight,
			s = wb(e),
			u = "border-box" === o.css(e, "boxSizing", !1, s);
		if (0 >= i || null == i) {
			if (i = xb(e, t, s), (0 > i || null == i) && (i = e.style[t]), vb.test(i)) return i;
			r = u && (l.boxSizingReliable() || i === e.style[t]), i = parseFloat(i) || 0
		}
		return i + Hb(e, t, n || (u ? "border" : "content"), r, s) + "px"
	}

	function Jb(e, t) {
		for (var n, r, i, s = [], u = 0, a = e.length; a > u; u++) r = e[u], r.style && (s[u] = L.get(r, "olddisplay"), n = r.style.display, t ? (s[u] || "none" !== n || (r.style.display = ""), "" === r.style.display && S(r) && (s[u] = L.access(r, "olddisplay", tb(r.nodeName)))) : s[u] || (i = S(r), (n && "none" !== n || !i) && L.set(r, "olddisplay", i ? n : o.css(r, "display"))));
		for (u = 0; a > u; u++) r = e[u], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? s[u] || "" : "none"));
		return e
	}

	function Kb(e, t, n, r, i) {
		return new Kb.prototype.init(e, t, n, r, i)
	}

	function Sb() {
		return setTimeout(function() {
			Lb = void 0
		}), Lb = o.now()
	}

	function Tb(e, t) {
		var n, r = 0,
			i = {
				height: e
			};
		for (t = t ? 1 : 0; 4 > r; r += 2 - t) n = R[r], i["margin" + n] = i["padding" + n] = e;
		return t && (i.opacity = i.width = e), i
	}

	function Ub(e, t, n) {
		for (var r, i = (Rb[t] || []).concat(Rb["*"]), s = 0, o = i.length; o > s; s++)
			if (r = i[s].call(n, t, e)) return r
	}

	function Vb(e, t, n) {
		var r, i, s, u, a, f, l, c = this,
			h = {},
			p = e.style,
			d = e.nodeType && S(e),
			v = L.get(e, "fxshow");
		n.queue || (a = o._queueHooks(e, "fx"), null == a.unqueued && (a.unqueued = 0, f = a.empty.fire, a.empty.fire = function() {
			a.unqueued || f()
		}), a.unqueued++, c.always(function() {
			c.always(function() {
				a.unqueued--, o.queue(e, "fx").length || a.empty.fire()
			})
		})), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], l = o.css(e, "display"), "none" === l && (l = tb(e.nodeName)), "inline" === l && "none" === o.css(e, "float") && (p.display = "inline-block")), n.overflow && (p.overflow = "hidden", c.always(function() {
			p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]
		}));
		for (r in t)
			if (i = t[r], Nb.exec(i)) {
				if (delete t[r], s = s || "toggle" === i, i === (d ? "hide" : "show")) {
					if ("show" !== i || !v || void 0 === v[r]) continue;
					d = !0
				}
				h[r] = v && v[r] || o.style(e, r)
			} if (!o.isEmptyObject(h)) {
			v ? "hidden" in v && (d = v.hidden) : v = L.access(e, "fxshow", {}), s && (v.hidden = !d), d ? o(e).show() : c.done(function() {
				o(e).hide()
			}), c.done(function() {
				var t;
				L.remove(e, "fxshow");
				for (t in h) o.style(e, t, h[t])
			});
			for (r in h) u = Ub(d ? v[r] : 0, r, c), r in v || (v[r] = u.start, d && (u.end = u.start, u.start = "width" === r || "height" === r ? 1 : 0))
		}
	}

	function Wb(e, t) {
		var n, r, i, s, u;
		for (n in e)
			if (r = o.camelCase(n), i = t[r], s = e[n], o.isArray(s) && (i = s[1], s = e[n] = s[0]), n !== r && (e[r] = s, delete e[n]), u = o.cssHooks[r], u && "expand" in u) {
				s = u.expand(s), delete e[r];
				for (n in s) n in e || (e[n] = s[n], t[n] = i)
			} else t[r] = i
	}

	function Xb(e, t, n) {
		var r, i, s = 0,
			u = Qb.length,
			a = o.Deferred().always(function() {
				delete f.elem
			}),
			f = function() {
				if (i) return !1;
				for (var t = Lb || Sb(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, s = 1 - r, o = 0, u = l.tweens.length; u > o; o++) l.tweens[o].run(s);
				return a.notifyWith(e, [l, s, n]), 1 > s && u ? n : (a.resolveWith(e, [l]), !1)
			},
			l = a.promise({
				elem: e,
				props: o.extend({}, t),
				opts: o.extend(!0, {
					specialEasing: {}
				}, n),
				originalProperties: t,
				originalOptions: n,
				startTime: Lb || Sb(),
				duration: n.duration,
				tweens: [],
				createTween: function(t, n) {
					var r = o.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
					return l.tweens.push(r), r
				},
				stop: function(t) {
					var n = 0,
						r = t ? l.tweens.length : 0;
					if (i) return this;
					for (i = !0; r > n; n++) l.tweens[n].run(1);
					return t ? a.resolveWith(e, [l, t]) : a.rejectWith(e, [l, t]), this
				}
			}),
			c = l.props;
		for (Wb(c, l.opts.specialEasing); u > s; s++)
			if (r = Qb[s].call(l, e, c, l.opts)) return r;
		return o.map(c, Ub, l), o.isFunction(l.opts.start) && l.opts.start.call(e, l), o.fx.timer(o.extend(f, {
			elem: e,
			anim: l,
			queue: l.opts.queue
		})), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always)
	}

	function rc(e) {
		return function(t, n) {
			"string" != typeof t && (n = t, t = "*");
			var r, i = 0,
				s = t.toLowerCase().match(E) || [];
			if (o.isFunction(n))
				while (r = s[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
		}
	}

	function sc(e, t, n, r) {
		function u(l) {
			var h;
			return i[l] = !0, o.each(e[l] || [], function(e, o) {
				var a = o(t, n, r);
				return "string" != typeof a || s || i[a] ? s ? !(h = a) : void 0 : (t.dataTypes.unshift(a), u(a), !1)
			}), h
		}
		var i = {},
			s = e === oc;
		return u(t.dataTypes[0]) || !i["*"] && u("*")
	}

	function tc(e, t) {
		var n, r, i = o.ajaxSettings.flatOptions || {};
		for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
		return r && o.extend(!0, e, r), e
	}

	function uc(e, t, n) {
		var r, i, s, o, u = e.contents,
			a = e.dataTypes;
		while ("*" === a[0]) a.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
		if (r)
			for (i in u)
				if (u[i] && u[i].test(r)) {
					a.unshift(i);
					break
				} if (a[0] in n) s = a[0];
		else {
			for (i in n) {
				if (!a[0] || e.converters[i + " " + a[0]]) {
					s = i;
					break
				}
				o || (o = i)
			}
			s = s || o
		}
		return s ? (s !== a[0] && a.unshift(s), n[s]) : void 0
	}

	function vc(e, t, n, r) {
		var i, s, o, u, a, f = {},
			l = e.dataTypes.slice();
		if (l[1])
			for (o in e.converters) f[o.toLowerCase()] = e.converters[o];
		s = l.shift();
		while (s)
			if (e.responseFields[s] && (n[e.responseFields[s]] = t), !a && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), a = s, s = l.shift())
				if ("*" === s) s = a;
				else if ("*" !== a && a !== s) {
			if (o = f[a + " " + s] || f["* " + s], !o)
				for (i in f)
					if (u = i.split(" "), u[1] === s && (o = f[a + " " + u[0]] || f["* " + u[0]])) {
						o === !0 ? o = f[i] : f[i] !== !0 && (s = u[0], l.unshift(u[1]));
						break
					} if (o !== !0)
				if (o && e["throws"]) t = o(t);
				else try {
					t = o(t)
				} catch (c) {
					return {
						state: "parsererror",
						error: o ? c : "No conversion from " + a + " to " + s
					}
				}
		}
		return {
			state: "success",
			data: t
		}
	}

	function Bc(e, t, n, r) {
		var i;
		if (o.isArray(t)) o.each(t, function(t, i) {
			n || xc.test(e) ? r(e, i) : Bc(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
		});
		else if (n || "object" !== o.type(t)) r(e, t);
		else
			for (i in t) Bc(e + "[" + i + "]", t[i], n, r)
	}

	function Kc(e) {
		return o.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
	}
	var c = [],
		d = c.slice,
		e = c.concat,
		f = c.push,
		g = c.indexOf,
		h = {},
		i = h.toString,
		j = h.hasOwnProperty,
		k = "".trim,
		l = {},
		m = a.document,
		n = "2.1.0",
		o = function(e, t) {
			return new o.fn.init(e, t)
		},
		p = /^-ms-/,
		q = /-([\da-z])/gi,
		r = function(e, t) {
			return t.toUpperCase()
		};
	o.fn = o.prototype = {
		jquery: n,
		constructor: o,
		selector: "",
		length: 0,
		toArray: function() {
			return d.call(this)
		},
		get: function(e) {
			return null != e ? 0 > e ? this[e + this.length] : this[e] : d.call(this)
		},
		pushStack: function(e) {
			var t = o.merge(this.constructor(), e);
			return t.prevObject = this, t.context = this.context, t
		},
		each: function(e, t) {
			return o.each(this, e, t)
		},
		map: function(e) {
			return this.pushStack(o.map(this, function(t, n) {
				return e.call(t, n, t)
			}))
		},
		slice: function() {
			return this.pushStack(d.apply(this, arguments))
		},
		first: function() {
			return this.eq(0)
		},
		last: function() {
			return this.eq(-1)
		},
		eq: function(e) {
			var t = this.length,
				n = +e + (0 > e ? t : 0);
			return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
		},
		end: function() {
			return this.prevObject || this.constructor(null)
		},
		push: f,
		sort: c.sort,
		splice: c.splice
	}, o.extend = o.fn.extend = function() {
		var e, t, n, r, i, s, u = arguments[0] || {},
			a = 1,
			f = arguments.length,
			l = !1;
		for ("boolean" == typeof u && (l = u, u = arguments[a] || {}, a++), "object" == typeof u || o.isFunction(u) || (u = {}), a === f && (u = this, a--); f > a; a++)
			if (null != (e = arguments[a]))
				for (t in e) n = u[t], r = e[t], u !== r && (l && r && (o.isPlainObject(r) || (i = o.isArray(r))) ? (i ? (i = !1, s = n && o.isArray(n) ? n : []) : s = n && o.isPlainObject(n) ? n : {}, u[t] = o.extend(l, s, r)) : void 0 !== r && (u[t] = r));
		return u
	}, o.extend({
		expando: "jQuery" + (n + Math.random()).replace(/\D/g, ""),
		isReady: !0,
		error: function(e) {
			throw new Error(e)
		},
		noop: function() {},
		isFunction: function(e) {
			return "function" === o.type(e)
		},
		isArray: Array.isArray,
		isWindow: function(e) {
			return null != e && e === e.window
		},
		isNumeric: function(e) {
			return e - parseFloat(e) >= 0
		},
		isPlainObject: function(e) {
			if ("object" !== o.type(e) || e.nodeType || o.isWindow(e)) return !1;
			try {
				if (e.constructor && !j.call(e.constructor.prototype, "isPrototypeOf")) return !1
			} catch (t) {
				return !1
			}
			return !0
		},
		isEmptyObject: function(e) {
			var t;
			for (t in e) return !1;
			return !0
		},
		type: function(e) {
			return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? h[i.call(e)] || "object" : typeof e
		},
		globalEval: function(a) {
			var b, c = eval;
			a = o.trim(a), a && (1 === a.indexOf("use strict") ? (b = m.createElement("script"), b.text = a, m.head.appendChild(b).parentNode.removeChild(b)) : c(a))
		},
		camelCase: function(e) {
			return e.replace(p, "ms-").replace(q, r)
		},
		nodeName: function(e, t) {
			return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
		},
		each: function(e, t, n) {
			var r, i = 0,
				o = e.length,
				u = s(e);
			if (n) {
				if (u) {
					for (; o > i; i++)
						if (r = t.apply(e[i], n), r === !1) break
				} else
					for (i in e)
						if (r = t.apply(e[i], n), r === !1) break
			} else if (u) {
				for (; o > i; i++)
					if (r = t.call(e[i], i, e[i]), r === !1) break
			} else
				for (i in e)
					if (r = t.call(e[i], i, e[i]), r === !1) break;
			return e
		},
		trim: function(e) {
			return null == e ? "" : k.call(e)
		},
		makeArray: function(e, t) {
			var n = t || [];
			return null != e && (s(Object(e)) ? o.merge(n, "string" == typeof e ? [e] : e) : f.call(n, e)), n
		},
		inArray: function(e, t, n) {
			return null == t ? -1 : g.call(t, e, n)
		},
		merge: function(e, t) {
			for (var n = +t.length, r = 0, i = e.length; n > r; r++) e[i++] = t[r];
			return e.length = i, e
		},
		grep: function(e, t, n) {
			for (var r, i = [], s = 0, o = e.length, u = !n; o > s; s++) r = !t(e[s], s), r !== u && i.push(e[s]);
			return i
		},
		map: function(t, n, r) {
			var i, o = 0,
				u = t.length,
				a = s(t),
				f = [];
			if (a)
				for (; u > o; o++) i = n(t[o], o, r), null != i && f.push(i);
			else
				for (o in t) i = n(t[o], o, r), null != i && f.push(i);
			return e.apply([], f)
		},
		guid: 1,
		proxy: function(e, t) {
			var n, r, i;
			return "string" == typeof t && (n = e[t], t = e, e = n), o.isFunction(e) ? (r = d.call(arguments, 2), i = function() {
				return e.apply(t || this, r.concat(d.call(arguments)))
			}, i.guid = e.guid = e.guid || o.guid++, i) : void 0
		},
		now: Date.now,
		support: l
	}), o.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
		h["[object " + t + "]"] = t.toLowerCase()
	});
	var t = function(e) {
		function rt(e, t, r, i) {
			var s, o, u, a, f, h, v, m, w, E;
			if ((t ? t.ownerDocument || t : b) !== c && l(t), t = t || c, r = r || [], !e || "string" != typeof e) return r;
			if (1 !== (a = t.nodeType) && 9 !== a) return [];
			if (p && !i) {
				if (s = G.exec(e))
					if (u = s[1]) {
						if (9 === a) {
							if (o = t.getElementById(u), !o || !o.parentNode) return r;
							if (o.id === u) return r.push(o), r
						} else if (t.ownerDocument && (o = t.ownerDocument.getElementById(u)) && g(t, o) && o.id === u) return r.push(o), r
					} else {
						if (s[2]) return _.apply(r, t.getElementsByTagName(e)), r;
						if ((u = s[3]) && n.getElementsByClassName && t.getElementsByClassName) return _.apply(r, t.getElementsByClassName(u)), r
					} if (n.qsa && (!d || !d.test(e))) {
					if (m = v = y, w = t, E = 9 === a && e, 1 === a && "object" !== t.nodeName.toLowerCase()) {
						h = dt(e), (v = t.getAttribute("id")) ? m = v.replace(Z, "\\$&") : t.setAttribute("id", m), m = "[id='" + m + "'] ", f = h.length;
						while (f--) h[f] = m + vt(h[f]);
						w = Y.test(e) && ht(t.parentNode) || t, E = h.join(",")
					}
					if (E) try {
						return _.apply(r, w.querySelectorAll(E)), r
					} catch (S) {} finally {
						v || t.removeAttribute("id")
					}
				}
			}
			return xt(e.replace(R, "$1"), t, r, i)
		}

		function it() {
			function t(n, i) {
				return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = i
			}
			var e = [];
			return t
		}

		function st(e) {
			return e[y] = !0, e
		}

		function ot(e) {
			var t = c.createElement("div");
			try {
				return !!e(t)
			} catch (n) {
				return !1
			} finally {
				t.parentNode && t.parentNode.removeChild(t), t = null
			}
		}

		function ut(e, t) {
			var n = e.split("|"),
				i = e.length;
			while (i--) r.attrHandle[n[i]] = t
		}

		function at(e, t) {
			var n = t && e,
				r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || k) - (~e.sourceIndex || k);
			if (r) return r;
			if (n)
				while (n = n.nextSibling)
					if (n === t) return -1;
			return e ? 1 : -1
		}

		function ft(e) {
			return function(t) {
				var n = t.nodeName.toLowerCase();
				return "input" === n && t.type === e
			}
		}

		function lt(e) {
			return function(t) {
				var n = t.nodeName.toLowerCase();
				return ("input" === n || "button" === n) && t.type === e
			}
		}

		function ct(e) {
			return st(function(t) {
				return t = +t, st(function(n, r) {
					var i, s = e([], n.length, t),
						o = s.length;
					while (o--) n[i = s[o]] && (n[i] = !(r[i] = n[i]))
				})
			})
		}

		function ht(e) {
			return e && typeof e.getElementsByTagName !== C && e
		}

		function pt() {}

		function dt(e, t) {
			var n, i, s, o, u, a, f, l = x[e + " "];
			if (l) return t ? 0 : l.slice(0);
			u = e, a = [], f = r.preFilter;
			while (u) {
				(!n || (i = U.exec(u))) && (i && (u = u.slice(i[0].length) || u), a.push(s = [])), n = !1, (i = z.exec(u)) && (n = i.shift(), s.push({
					value: n,
					type: i[0].replace(R, " ")
				}), u = u.slice(n.length));
				for (o in r.filter) !(i = $[o].exec(u)) || f[o] && !(i = f[o](i)) || (n = i.shift(), s.push({
					value: n,
					type: o,
					matches: i
				}), u = u.slice(n.length));
				if (!n) break
			}
			return t ? u.length : u ? rt.error(e) : x(e, a).slice(0)
		}

		function vt(e) {
			for (var t = 0, n = e.length, r = ""; n > t; t++) r += e[t].value;
			return r
		}

		function mt(e, t, n) {
			var r = t.dir,
				i = n && "parentNode" === r,
				s = E++;
			return t.first ? function(t, n, s) {
				while (t = t[r])
					if (1 === t.nodeType || i) return e(t, n, s)
			} : function(t, n, o) {
				var u, a, f = [w, s];
				if (o) {
					while (t = t[r])
						if ((1 === t.nodeType || i) && e(t, n, o)) return !0
				} else
					while (t = t[r])
						if (1 === t.nodeType || i) {
							if (a = t[y] || (t[y] = {}), (u = a[r]) && u[0] === w && u[1] === s) return f[2] = u[2];
							if (a[r] = f, f[2] = e(t, n, o)) return !0
						}
			}
		}

		function gt(e) {
			return e.length > 1 ? function(t, n, r) {
				var i = e.length;
				while (i--)
					if (!e[i](t, n, r)) return !1;
				return !0
			} : e[0]
		}

		function yt(e, t, n, r, i) {
			for (var s, o = [], u = 0, a = e.length, f = null != t; a > u; u++)(s = e[u]) && (!n || n(s, r, i)) && (o.push(s), f && t.push(u));
			return o
		}

		function bt(e, t, n, r, i, s) {
			return r && !r[y] && (r = bt(r)), i && !i[y] && (i = bt(i, s)), st(function(s, o, u, a) {
				var f, l, c, h = [],
					p = [],
					d = o.length,
					v = s || St(t || "*", u.nodeType ? [u] : u, []),
					m = !e || !s && t ? v : yt(v, h, e, u, a),
					g = n ? i || (s ? e : d || r) ? [] : o : m;
				if (n && n(m, g, u, a), r) {
					f = yt(g, p), r(f, [], u, a), l = f.length;
					while (l--)(c = f[l]) && (g[p[l]] = !(m[p[l]] = c))
				}
				if (s) {
					if (i || e) {
						if (i) {
							f = [], l = g.length;
							while (l--)(c = g[l]) && f.push(m[l] = c);
							i(null, g = [], f, a)
						}
						l = g.length;
						while (l--)(c = g[l]) && (f = i ? P.call(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c))
					}
				} else g = yt(g === o ? g.splice(d, g.length) : g), i ? i(null, o, g, a) : _.apply(o, g)
			})
		}

		function wt(e) {
			for (var t, n, i, s = e.length, o = r.relative[e[0].type], a = o || r.relative[" "], f = o ? 1 : 0, l = mt(function(e) {
					return e === t
				}, a, !0), c = mt(function(e) {
					return P.call(t, e) > -1
				}, a, !0), h = [function(e, n, r) {
					return !o && (r || n !== u) || ((t = n).nodeType ? l(e, n, r) : c(e, n, r))
				}]; s > f; f++)
				if (n = r.relative[e[f].type]) h = [mt(gt(h), n)];
				else {
					if (n = r.filter[e[f].type].apply(null, e[f].matches), n[y]) {
						for (i = ++f; s > i; i++)
							if (r.relative[e[i].type]) break;
						return bt(f > 1 && gt(h), f > 1 && vt(e.slice(0, f - 1).concat({
							value: " " === e[f - 2].type ? "*" : ""
						})).replace(R, "$1"), n, i > f && wt(e.slice(f, i)), s > i && wt(e = e.slice(i)), s > i && vt(e))
					}
					h.push(n)
				} return gt(h)
		}

		function Et(e, t) {
			var n = t.length > 0,
				i = e.length > 0,
				s = function(s, o, a, f, l) {
					var h, p, d, v = 0,
						m = "0",
						g = s && [],
						y = [],
						b = u,
						E = s || i && r.find.TAG("*", l),
						S = w += null == b ? 1 : Math.random() || .1,
						x = E.length;
					for (l && (u = o !== c && o); m !== x && null != (h = E[m]); m++) {
						if (i && h) {
							p = 0;
							while (d = e[p++])
								if (d(h, o, a)) {
									f.push(h);
									break
								} l && (w = S)
						}
						n && ((h = !d && h) && v--, s && g.push(h))
					}
					if (v += m, n && m !== v) {
						p = 0;
						while (d = t[p++]) d(g, y, o, a);
						if (s) {
							if (v > 0)
								while (m--) g[m] || y[m] || (y[m] = O.call(f));
							y = yt(y)
						}
						_.apply(f, y), l && !s && y.length > 0 && v + t.length > 1 && rt.uniqueSort(f)
					}
					return l && (w = S, u = b), g
				};
			return n ? st(s) : s
		}

		function St(e, t, n) {
			for (var r = 0, i = t.length; i > r; r++) rt(e, t[r], n);
			return n
		}

		function xt(e, t, i, s) {
			var u, a, f, l, c, h = dt(e);
			if (!s && 1 === h.length) {
				if (a = h[0] = h[0].slice(0), a.length > 2 && "ID" === (f = a[0]).type && n.getById && 9 === t.nodeType && p && r.relative[a[1].type]) {
					if (t = (r.find.ID(f.matches[0].replace(et, tt), t) || [])[0], !t) return i;
					e = e.slice(a.shift().value.length)
				}
				u = $.needsContext.test(e) ? 0 : a.length;
				while (u--) {
					if (f = a[u], r.relative[l = f.type]) break;
					if ((c = r.find[l]) && (s = c(f.matches[0].replace(et, tt), Y.test(a[0].type) && ht(t.parentNode) || t))) {
						if (a.splice(u, 1), e = s.length && vt(a), !e) return _.apply(i, s), i;
						break
					}
				}
			}
			return o(e, h)(s, t, !p, i, Y.test(e) && ht(t.parentNode) || t), i
		}
		var t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y = "sizzle" + -(new Date),
			b = e.document,
			w = 0,
			E = 0,
			S = it(),
			x = it(),
			T = it(),
			N = function(e, t) {
				return e === t && (f = !0), 0
			},
			C = "undefined",
			k = 1 << 31,
			L = {}.hasOwnProperty,
			A = [],
			O = A.pop,
			M = A.push,
			_ = A.push,
			D = A.slice,
			P = A.indexOf || function(e) {
				for (var t = 0, n = this.length; n > t; t++)
					if (this[t] === e) return t;
				return -1
			},
			H = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
			B = "[\\x20\\t\\r\\n\\f]",
			j = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
			F = j.replace("w", "w#"),
			I = "\\[" + B + "*(" + j + ")" + B + "*(?:([*^$|!~]?=)" + B + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + F + ")|)|)" + B + "*\\]",
			q = ":(" + j + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + I.replace(3, 8) + ")*)|.*)\\)|)",
			R = new RegExp("^" + B + "+|((?:^|[^\\\\])(?:\\\\.)*)" + B + "+$", "g"),
			U = new RegExp("^" + B + "*," + B + "*"),
			z = new RegExp("^" + B + "*([>+~]|" + B + ")" + B + "*"),
			W = new RegExp("=" + B + "*([^\\]'\"]*?)" + B + "*\\]", "g"),
			X = new RegExp(q),
			V = new RegExp("^" + F + "$"),
			$ = {
				ID: new RegExp("^#(" + j + ")"),
				CLASS: new RegExp("^\\.(" + j + ")"),
				TAG: new RegExp("^(" + j.replace("w", "w*") + ")"),
				ATTR: new RegExp("^" + I),
				PSEUDO: new RegExp("^" + q),
				CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + B + "*(even|odd|(([+-]|)(\\d*)n|)" + B + "*(?:([+-]|)" + B + "*(\\d+)|))" + B + "*\\)|)", "i"),
				bool: new RegExp("^(?:" + H + ")$", "i"),
				needsContext: new RegExp("^" + B + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + B + "*((?:-\\d)?\\d*)" + B + "*\\)|)(?=[^-]|$)", "i")
			},
			J = /^(?:input|select|textarea|button)$/i,
			K = /^h\d$/i,
			Q = /^[^{]+\{\s*\[native \w/,
			G = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
			Y = /[+~]/,
			Z = /'|\\/g,
			et = new RegExp("\\\\([\\da-f]{1,6}" + B + "?|(" + B + ")|.)", "ig"),
			tt = function(e, t, n) {
				var r = "0x" + t - 65536;
				return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
			};
		try {
			_.apply(A = D.call(b.childNodes), b.childNodes), A[b.childNodes.length].nodeType
		} catch (nt) {
			_ = {
				apply: A.length ? function(e, t) {
					M.apply(e, D.call(t))
				} : function(e, t) {
					var n = e.length,
						r = 0;
					while (e[n++] = t[r++]);
					e.length = n - 1
				}
			}
		}
		n = rt.support = {}, s = rt.isXML = function(e) {
			var t = e && (e.ownerDocument || e).documentElement;
			return t ? "HTML" !== t.nodeName : !1
		}, l = rt.setDocument = function(e) {
			var t, i = e ? e.ownerDocument || e : b,
				o = i.defaultView;
			return i !== c && 9 === i.nodeType && i.documentElement ? (c = i, h = i.documentElement, p = !s(i), o && o !== o.top && (o.addEventListener ? o.addEventListener("unload", function() {
				l()
			}, !1) : o.attachEvent && o.attachEvent("onunload", function() {
				l()
			})), n.attributes = ot(function(e) {
				return e.className = "i", !e.getAttribute("className")
			}), n.getElementsByTagName = ot(function(e) {
				return e.appendChild(i.createComment("")), !e.getElementsByTagName("*").length
			}), n.getElementsByClassName = Q.test(i.getElementsByClassName) && ot(function(e) {
				return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length
			}), n.getById = ot(function(e) {
				return h.appendChild(e).id = y, !i.getElementsByName || !i.getElementsByName(y).length
			}), n.getById ? (r.find.ID = function(e, t) {
				if (typeof t.getElementById !== C && p) {
					var n = t.getElementById(e);
					return n && n.parentNode ? [n] : []
				}
			}, r.filter.ID = function(e) {
				var t = e.replace(et, tt);
				return function(e) {
					return e.getAttribute("id") === t
				}
			}) : (delete r.find.ID, r.filter.ID = function(e) {
				var t = e.replace(et, tt);
				return function(e) {
					var n = typeof e.getAttributeNode !== C && e.getAttributeNode("id");
					return n && n.value === t
				}
			}), r.find.TAG = n.getElementsByTagName ? function(e, t) {
				return typeof t.getElementsByTagName !== C ? t.getElementsByTagName(e) : void 0
			} : function(e, t) {
				var n, r = [],
					i = 0,
					s = t.getElementsByTagName(e);
				if ("*" === e) {
					while (n = s[i++]) 1 === n.nodeType && r.push(n);
					return r
				}
				return s
			}, r.find.CLASS = n.getElementsByClassName && function(e, t) {
				return typeof t.getElementsByClassName !== C && p ? t.getElementsByClassName(e) : void 0
			}, v = [], d = [], (n.qsa = Q.test(i.querySelectorAll)) && (ot(function(e) {
				e.innerHTML = "<select t=''><option selected=''></option></select>", e.querySelectorAll("[t^='']").length && d.push("[*^$]=" + B + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || d.push("\\[" + B + "*(?:value|" + H + ")"), e.querySelectorAll(":checked").length || d.push(":checked")
			}), ot(function(e) {
				var t = i.createElement("input");
				t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && d.push("name" + B + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || d.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), d.push(",.*:")
			})), (n.matchesSelector = Q.test(m = h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ot(function(e) {
				n.disconnectedMatch = m.call(e, "div"), m.call(e, "[s!='']:x"), v.push("!=", q)
			}), d = d.length && new RegExp(d.join("|")), v = v.length && new RegExp(v.join("|")), t = Q.test(h.compareDocumentPosition), g = t || Q.test(h.contains) ? function(e, t) {
				var n = 9 === e.nodeType ? e.documentElement : e,
					r = t && t.parentNode;
				return e === r || !!r && 1 === r.nodeType && !!(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))
			} : function(e, t) {
				if (t)
					while (t = t.parentNode)
						if (t === e) return !0;
				return !1
			}, N = t ? function(e, t) {
				if (e === t) return f = !0, 0;
				var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
				return r ? r : (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === i || e.ownerDocument === b && g(b, e) ? -1 : t === i || t.ownerDocument === b && g(b, t) ? 1 : a ? P.call(a, e) - P.call(a, t) : 0 : 4 & r ? -1 : 1)
			} : function(e, t) {
				if (e === t) return f = !0, 0;
				var n, r = 0,
					s = e.parentNode,
					o = t.parentNode,
					u = [e],
					l = [t];
				if (!s || !o) return e === i ? -1 : t === i ? 1 : s ? -1 : o ? 1 : a ? P.call(a, e) - P.call(a, t) : 0;
				if (s === o) return at(e, t);
				n = e;
				while (n = n.parentNode) u.unshift(n);
				n = t;
				while (n = n.parentNode) l.unshift(n);
				while (u[r] === l[r]) r++;
				return r ? at(u[r], l[r]) : u[r] === b ? -1 : l[r] === b ? 1 : 0
			}, i) : c
		}, rt.matches = function(e, t) {
			return rt(e, null, null, t)
		}, rt.matchesSelector = function(e, t) {
			if ((e.ownerDocument || e) !== c && l(e), t = t.replace(W, "='$1']"), !(!n.matchesSelector || !p || v && v.test(t) || d && d.test(t))) try {
				var r = m.call(e, t);
				if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
			} catch (i) {}
			return rt(t, c, null, [e]).length > 0
		}, rt.contains = function(e, t) {
			return (e.ownerDocument || e) !== c && l(e), g(e, t)
		}, rt.attr = function(e, t) {
			(e.ownerDocument || e) !== c && l(e);
			var i = r.attrHandle[t.toLowerCase()],
				s = i && L.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !p) : void 0;
			return void 0 !== s ? s : n.attributes || !p ? e.getAttribute(t) : (s = e.getAttributeNode(t)) && s.specified ? s.value : null
		}, rt.error = function(e) {
			throw new Error("Syntax error, unrecognized expression: " + e)
		}, rt.uniqueSort = function(e) {
			var t, r = [],
				i = 0,
				s = 0;
			if (f = !n.detectDuplicates, a = !n.sortStable && e.slice(0), e.sort(N), f) {
				while (t = e[s++]) t === e[s] && (i = r.push(s));
				while (i--) e.splice(r[i], 1)
			}
			return a = null, e
		}, i = rt.getText = function(e) {
			var t, n = "",
				r = 0,
				s = e.nodeType;
			if (s) {
				if (1 === s || 9 === s || 11 === s) {
					if ("string" == typeof e.textContent) return e.textContent;
					for (e = e.firstChild; e; e = e.nextSibling) n += i(e)
				} else if (3 === s || 4 === s) return e.nodeValue
			} else
				while (t = e[r++]) n += i(t);
			return n
		}, r = rt.selectors = {
			cacheLength: 50,
			createPseudo: st,
			match: $,
			attrHandle: {},
			find: {},
			relative: {
				">": {
					dir: "parentNode",
					first: !0
				},
				" ": {
					dir: "parentNode"
				},
				"+": {
					dir: "previousSibling",
					first: !0
				},
				"~": {
					dir: "previousSibling"
				}
			},
			preFilter: {
				ATTR: function(e) {
					return e[1] = e[1].replace(et, tt), e[3] = (e[4] || e[5] || "").replace(et, tt), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
				},
				CHILD: function(e) {
					return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || rt.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && rt.error(e[0]), e
				},
				PSEUDO: function(e) {
					var t, n = !e[5] && e[2];
					return $.CHILD.test(e[0]) ? null : (e[3] && void 0 !== e[4] ? e[2] = e[4] : n && X.test(n) && (t = dt(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
				}
			},
			filter: {
				TAG: function(e) {
					var t = e.replace(et, tt).toLowerCase();
					return "*" === e ? function() {
						return !0
					} : function(e) {
						return e.nodeName && e.nodeName.toLowerCase() === t
					}
				},
				CLASS: function(e) {
					var t = S[e + " "];
					return t || (t = new RegExp("(^|" + B + ")" + e + "(" + B + "|$)")) && S(e, function(e) {
						return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== C && e.getAttribute("class") || "")
					})
				},
				ATTR: function(e, t, n) {
					return function(r) {
						var i = rt.attr(r, e);
						return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0
					}
				},
				CHILD: function(e, t, n, r, i) {
					var s = "nth" !== e.slice(0, 3),
						o = "last" !== e.slice(-4),
						u = "of-type" === t;
					return 1 === r && 0 === i ? function(e) {
						return !!e.parentNode
					} : function(t, n, a) {
						var f, l, c, h, p, d, v = s !== o ? "nextSibling" : "previousSibling",
							m = t.parentNode,
							g = u && t.nodeName.toLowerCase(),
							b = !a && !u;
						if (m) {
							if (s) {
								while (v) {
									c = t;
									while (c = c[v])
										if (u ? c.nodeName.toLowerCase() === g : 1 === c.nodeType) return !1;
									d = v = "only" === e && !d && "nextSibling"
								}
								return !0
							}
							if (d = [o ? m.firstChild : m.lastChild], o && b) {
								l = m[y] || (m[y] = {}), f = l[e] || [], p = f[0] === w && f[1], h = f[0] === w && f[2], c = p && m.childNodes[p];
								while (c = ++p && c && c[v] || (h = p = 0) || d.pop())
									if (1 === c.nodeType && ++h && c === t) {
										l[e] = [w, p, h];
										break
									}
							} else if (b && (f = (t[y] || (t[y] = {}))[e]) && f[0] === w) h = f[1];
							else
								while (c = ++p && c && c[v] || (h = p = 0) || d.pop())
									if ((u ? c.nodeName.toLowerCase() === g : 1 === c.nodeType) && ++h && (b && ((c[y] || (c[y] = {}))[e] = [w, h]), c === t)) break;
							return h -= i, h === r || h % r === 0 && h / r >= 0
						}
					}
				},
				PSEUDO: function(e, t) {
					var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || rt.error("unsupported pseudo: " + e);
					return i[y] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? st(function(e, n) {
						var r, s = i(e, t),
							o = s.length;
						while (o--) r = P.call(e, s[o]), e[r] = !(n[r] = s[o])
					}) : function(e) {
						return i(e, 0, n)
					}) : i
				}
			},
			pseudos: {
				not: st(function(e) {
					var t = [],
						n = [],
						r = o(e.replace(R, "$1"));
					return r[y] ? st(function(e, t, n, i) {
						var s, o = r(e, null, i, []),
							u = e.length;
						while (u--)(s = o[u]) && (e[u] = !(t[u] = s))
					}) : function(e, i, s) {
						return t[0] = e, r(t, null, s, n), !n.pop()
					}
				}),
				has: st(function(e) {
					return function(t) {
						return rt(e, t).length > 0
					}
				}),
				contains: st(function(e) {
					return function(t) {
						return (t.textContent || t.innerText || i(t)).indexOf(e) > -1
					}
				}),
				lang: st(function(e) {
					return V.test(e || "") || rt.error("unsupported lang: " + e), e = e.replace(et, tt).toLowerCase(),
						function(t) {
							var n;
							do
								if (n = p ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
							return !1
						}
				}),
				target: function(t) {
					var n = e.location && e.location.hash;
					return n && n.slice(1) === t.id
				},
				root: function(e) {
					return e === h
				},
				focus: function(e) {
					return e === c.activeElement && (!c.hasFocus || c.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
				},
				enabled: function(e) {
					return e.disabled === !1
				},
				disabled: function(e) {
					return e.disabled === !0
				},
				checked: function(e) {
					var t = e.nodeName.toLowerCase();
					return "input" === t && !!e.checked || "option" === t && !!e.selected
				},
				selected: function(e) {
					return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
				},
				empty: function(e) {
					for (e = e.firstChild; e; e = e.nextSibling)
						if (e.nodeType < 6) return !1;
					return !0
				},
				parent: function(e) {
					return !r.pseudos.empty(e)
				},
				header: function(e) {
					return K.test(e.nodeName)
				},
				input: function(e) {
					return J.test(e.nodeName)
				},
				button: function(e) {
					var t = e.nodeName.toLowerCase();
					return "input" === t && "button" === e.type || "button" === t
				},
				text: function(e) {
					var t;
					return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
				},
				first: ct(function() {
					return [0]
				}),
				last: ct(function(e, t) {
					return [t - 1]
				}),
				eq: ct(function(e, t, n) {
					return [0 > n ? n + t : n]
				}),
				even: ct(function(e, t) {
					for (var n = 0; t > n; n += 2) e.push(n);
					return e
				}),
				odd: ct(function(e, t) {
					for (var n = 1; t > n; n += 2) e.push(n);
					return e
				}),
				lt: ct(function(e, t, n) {
					for (var r = 0 > n ? n + t : n; --r >= 0;) e.push(r);
					return e
				}),
				gt: ct(function(e, t, n) {
					for (var r = 0 > n ? n + t : n; ++r < t;) e.push(r);
					return e
				})
			}
		}, r.pseudos.nth = r.pseudos.eq;
		for (t in {
				radio: !0,
				checkbox: !0,
				file: !0,
				password: !0,
				image: !0
			}) r.pseudos[t] = ft(t);
		for (t in {
				submit: !0,
				reset: !0
			}) r.pseudos[t] = lt(t);
		return pt.prototype = r.filters = r.pseudos, r.setFilters = new pt, o = rt.compile = function(e, t) {
			var n, r = [],
				i = [],
				s = T[e + " "];
			if (!s) {
				t || (t = dt(e)), n = t.length;
				while (n--) s = wt(t[n]), s[y] ? r.push(s) : i.push(s);
				s = T(e, Et(i, r))
			}
			return s
		}, n.sortStable = y.split("").sort(N).join("") === y, n.detectDuplicates = !!f, l(), n.sortDetached = ot(function(e) {
			return 1 & e.compareDocumentPosition(c.createElement("div"))
		}), ot(function(e) {
			return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
		}) || ut("type|href|height|width", function(e, t, n) {
			return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
		}), n.attributes && ot(function(e) {
			return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
		}) || ut("value", function(e, t, n) {
			return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
		}), ot(function(e) {
			return null == e.getAttribute("disabled")
		}) || ut(H, function(e, t, n) {
			var r;
			return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
		}), rt
	}(a);
	o.find = t, o.expr = t.selectors, o.expr[":"] = o.expr.pseudos, o.unique = t.uniqueSort, o.text = t.getText, o.isXMLDoc = t.isXML, o.contains = t.contains;
	var u = o.expr.match.needsContext,
		v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
		w = /^.[^:#\[\.,]*$/;
	o.filter = function(e, t, n) {
		var r = t[0];
		return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? o.find.matchesSelector(r, e) ? [r] : [] : o.find.matches(e, o.grep(t, function(e) {
			return 1 === e.nodeType
		}))
	}, o.fn.extend({
		find: function(e) {
			var t, n = this.length,
				r = [],
				i = this;
			if ("string" != typeof e) return this.pushStack(o(e).filter(function() {
				for (t = 0; n > t; t++)
					if (o.contains(i[t], this)) return !0
			}));
			for (t = 0; n > t; t++) o.find(e, i[t], r);
			return r = this.pushStack(n > 1 ? o.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r
		},
		filter: function(e) {
			return this.pushStack(x(this, e || [], !1))
		},
		not: function(e) {
			return this.pushStack(x(this, e || [], !0))
		},
		is: function(e) {
			return !!x(this, "string" == typeof e && u.test(e) ? o(e) : e || [], !1).length
		}
	});
	var y, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
		A = o.fn.init = function(e, t) {
			var n, r;
			if (!e) return this;
			if ("string" == typeof e) {
				if (n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : z.exec(e), !n || !n[1] && t) return !t || t.jquery ? (t || y).find(e) : this.constructor(t).find(e);
				if (n[1]) {
					if (t = t instanceof o ? t[0] : t, o.merge(this, o.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : m, !0)), v.test(n[1]) && o.isPlainObject(t))
						for (n in t) o.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]);
					return this
				}
				return r = m.getElementById(n[2]), r && r.parentNode && (this.length = 1, this[0] = r), this.context = m, this.selector = e, this
			}
			return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : o.isFunction(e) ? "undefined" != typeof y.ready ? y.ready(e) : e(o) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), o.makeArray(e, this))
		};
	A.prototype = o.fn, y = o(m);
	var B = /^(?:parents|prev(?:Until|All))/,
		C = {
			children: !0,
			contents: !0,
			next: !0,
			prev: !0
		};
	o.extend({
		dir: function(e, t, n) {
			var r = [],
				i = void 0 !== n;
			while ((e = e[t]) && 9 !== e.nodeType)
				if (1 === e.nodeType) {
					if (i && o(e).is(n)) break;
					r.push(e)
				} return r
		},
		sibling: function(e, t) {
			for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
			return n
		}
	}), o.fn.extend({
		has: function(e) {
			var t = o(e, this),
				n = t.length;
			return this.filter(function() {
				for (var e = 0; n > e; e++)
					if (o.contains(this, t[e])) return !0
			})
		},
		closest: function(e, t) {
			for (var n, r = 0, i = this.length, s = [], a = u.test(e) || "string" != typeof e ? o(e, t || this.context) : 0; i > r; r++)
				for (n = this[r]; n && n !== t; n = n.parentNode)
					if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && o.find.matchesSelector(n, e))) {
						s.push(n);
						break
					} return this.pushStack(s.length > 1 ? o.unique(s) : s)
		},
		index: function(e) {
			return e ? "string" == typeof e ? g.call(o(e), this[0]) : g.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
		},
		add: function(e, t) {
			return this.pushStack(o.unique(o.merge(this.get(), o(e, t))))
		},
		addBack: function(e) {
			return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
		}
	}), o.each({
		parent: function(e) {
			var t = e.parentNode;
			return t && 11 !== t.nodeType ? t : null
		},
		parents: function(e) {
			return o.dir(e, "parentNode")
		},
		parentsUntil: function(e, t, n) {
			return o.dir(e, "parentNode", n)
		},
		next: function(e) {
			return D(e, "nextSibling")
		},
		prev: function(e) {
			return D(e, "previousSibling")
		},
		nextAll: function(e) {
			return o.dir(e, "nextSibling")
		},
		prevAll: function(e) {
			return o.dir(e, "previousSibling")
		},
		nextUntil: function(e, t, n) {
			return o.dir(e, "nextSibling", n)
		},
		prevUntil: function(e, t, n) {
			return o.dir(e, "previousSibling", n)
		},
		siblings: function(e) {
			return o.sibling((e.parentNode || {}).firstChild, e)
		},
		children: function(e) {
			return o.sibling(e.firstChild)
		},
		contents: function(e) {
			return e.contentDocument || o.merge([], e.childNodes)
		}
	}, function(e, t) {
		o.fn[e] = function(n, r) {
			var i = o.map(this, t, n);
			return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = o.filter(r, i)), this.length > 1 && (C[e] || o.unique(i), B.test(e) && i.reverse()), this.pushStack(i)
		}
	});
	var E = /\S+/g,
		F = {};
	o.Callbacks = function(e) {
		e = "string" == typeof e ? F[e] || G(e) : o.extend({}, e);
		var t, n, r, i, s, u, a = [],
			f = !e.once && [],
			l = function(o) {
				for (t = e.memory && o, n = !0, u = i || 0, i = 0, s = a.length, r = !0; a && s > u; u++)
					if (a[u].apply(o[0], o[1]) === !1 && e.stopOnFalse) {
						t = !1;
						break
					} r = !1, a && (f ? f.length && l(f.shift()) : t ? a = [] : c.disable())
			},
			c = {
				add: function() {
					if (a) {
						var n = a.length;
						! function u(t) {
							o.each(t, function(t, n) {
								var r = o.type(n);
								"function" === r ? e.unique && c.has(n) || a.push(n) : n && n.length && "string" !== r && u(n)
							})
						}(arguments), r ? s = a.length : t && (i = n, l(t))
					}
					return this
				},
				remove: function() {
					return a && o.each(arguments, function(e, t) {
						var n;
						while ((n = o.inArray(t, a, n)) > -1) a.splice(n, 1), r && (s >= n && s--, u >= n && u--)
					}), this
				},
				has: function(e) {
					return e ? o.inArray(e, a) > -1 : !!a && !!a.length
				},
				empty: function() {
					return a = [], s = 0, this
				},
				disable: function() {
					return a = f = t = void 0, this
				},
				disabled: function() {
					return !a
				},
				lock: function() {
					return f = void 0, t || c.disable(), this
				},
				locked: function() {
					return !f
				},
				fireWith: function(e, t) {
					return !a || n && !f || (t = t || [], t = [e, t.slice ? t.slice() : t], r ? f.push(t) : l(t)), this
				},
				fire: function() {
					return c.fireWith(this, arguments), this
				},
				fired: function() {
					return !!n
				}
			};
		return c
	}, o.extend({
		Deferred: function(e) {
			var t = [
					["resolve", "done", o.Callbacks("once memory"), "resolved"],
					["reject", "fail", o.Callbacks("once memory"), "rejected"],
					["notify", "progress", o.Callbacks("memory")]
				],
				n = "pending",
				r = {
					state: function() {
						return n
					},
					always: function() {
						return i.done(arguments).fail(arguments), this
					},
					then: function() {
						var e = arguments;
						return o.Deferred(function(n) {
							o.each(t, function(t, s) {
								var u = o.isFunction(e[t]) && e[t];
								i[s[1]](function() {
									var e = u && u.apply(this, arguments);
									e && o.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[s[0] + "With"](this === r ? n.promise() : this, u ? [e] : arguments)
								})
							}), e = null
						}).promise()
					},
					promise: function(e) {
						return null != e ? o.extend(e, r) : r
					}
				},
				i = {};
			return r.pipe = r.then, o.each(t, function(e, s) {
				var o = s[2],
					u = s[3];
				r[s[1]] = o.add, u && o.add(function() {
					n = u
				}, t[1 ^ e][2].disable, t[2][2].lock), i[s[0]] = function() {
					return i[s[0] + "With"](this === i ? r : this, arguments), this
				}, i[s[0] + "With"] = o.fireWith
			}), r.promise(i), e && e.call(i, i), i
		},
		when: function(e) {
			var t = 0,
				n = d.call(arguments),
				r = n.length,
				i = 1 !== r || e && o.isFunction(e.promise) ? r : 0,
				s = 1 === i ? e : o.Deferred(),
				u = function(e, t, n) {
					return function(r) {
						t[e] = this, n[e] = arguments.length > 1 ? d.call(arguments) : r, n === a ? s.notifyWith(t, n) : --i || s.resolveWith(t, n)
					}
				},
				a, f, l;
			if (r > 1)
				for (a = new Array(r), f = new Array(r), l = new Array(r); r > t; t++) n[t] && o.isFunction(n[t].promise) ? n[t].promise().done(u(t, l, n)).fail(s.reject).progress(u(t, f, a)) : --i;
			return i || s.resolveWith(l, n), s.promise()
		}
	});
	var H;
	o.fn.ready = function(e) {
		return o.ready.promise().done(e), this
	}, o.extend({
		isReady: !1,
		readyWait: 1,
		holdReady: function(e) {
			e ? o.readyWait++ : o.ready(!0)
		},
		ready: function(e) {
			(e === !0 ? --o.readyWait : o.isReady) || (o.isReady = !0, e !== !0 && --o.readyWait > 0 || (H.resolveWith(m, [o]), o.fn.trigger && o(m).trigger("ready").off("ready")))
		}
	}), o.ready.promise = function(e) {
		return H || (H = o.Deferred(), "complete" === m.readyState ? setTimeout(o.ready) : (m.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))), H.promise(e)
	}, o.ready.promise();
	var J = o.access = function(e, t, n, r, i, s, u) {
		var a = 0,
			f = e.length,
			l = null == n;
		if ("object" === o.type(n)) {
			i = !0;
			for (a in n) o.access(e, t, a, n[a], !0, s, u)
		} else if (void 0 !== r && (i = !0, o.isFunction(r) || (u = !0), l && (u ? (t.call(e, r), t = null) : (l = t, t = function(e, t, n) {
				return l.call(o(e), n)
			})), t))
			for (; f > a; a++) t(e[a], n, u ? r : r.call(e[a], a, t(e[a], n)));
		return i ? e : l ? t.call(e) : f ? t(e[0], n) : s
	};
	o.acceptData = function(e) {
		return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
	}, K.uid = 1, K.accepts = o.acceptData, K.prototype = {
		key: function(e) {
			if (!K.accepts(e)) return 0;
			var t = {},
				n = e[this.expando];
			if (!n) {
				n = K.uid++;
				try {
					t[this.expando] = {
						value: n
					}, Object.defineProperties(e, t)
				} catch (r) {
					t[this.expando] = n, o.extend(e, t)
				}
			}
			return this.cache[n] || (this.cache[n] = {}), n
		},
		set: function(e, t, n) {
			var r, i = this.key(e),
				s = this.cache[i];
			if ("string" == typeof t) s[t] = n;
			else if (o.isEmptyObject(s)) o.extend(this.cache[i], t);
			else
				for (r in t) s[r] = t[r];
			return s
		},
		get: function(e, t) {
			var n = this.cache[this.key(e)];
			return void 0 === t ? n : n[t]
		},
		access: function(e, t, n) {
			var r;
			return void 0 === t || t && "string" == typeof t && void 0 === n ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, o.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t)
		},
		remove: function(e, t) {
			var n, r, i, s = this.key(e),
				u = this.cache[s];
			if (void 0 === t) this.cache[s] = {};
			else {
				o.isArray(t) ? r = t.concat(t.map(o.camelCase)) : (i = o.camelCase(t), t in u ? r = [t, i] : (r = i, r = r in u ? [r] : r.match(E) || [])), n = r.length;
				while (n--) delete u[r[n]]
			}
		},
		hasData: function(e) {
			return !o.isEmptyObject(this.cache[e[this.expando]] || {})
		},
		discard: function(e) {
			e[this.expando] && delete this.cache[e[this.expando]]
		}
	};
	var L = new K,
		M = new K,
		N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		O = /([A-Z])/g;
	o.extend({
		hasData: function(e) {
			return M.hasData(e) || L.hasData(e)
		},
		data: function(e, t, n) {
			return M.access(e, t, n)
		},
		removeData: function(e, t) {
			M.remove(e, t)
		},
		_data: function(e, t, n) {
			return L.access(e, t, n)
		},
		_removeData: function(e, t) {
			L.remove(e, t)
		}
	}), o.fn.extend({
		data: function(e, t) {
			var n, r, i, s = this[0],
				u = s && s.attributes;
			if (void 0 === e) {
				if (this.length && (i = M.get(s), 1 === s.nodeType && !L.get(s, "hasDataAttrs"))) {
					n = u.length;
					while (n--) r = u[n].name, 0 === r.indexOf("data-") && (r = o.camelCase(r.slice(5)), P(s, r, i[r]));
					L.set(s, "hasDataAttrs", !0)
				}
				return i
			}
			return "object" == typeof e ? this.each(function() {
				M.set(this, e)
			}) : J(this, function(t) {
				var n, r = o.camelCase(e);
				if (s && void 0 === t) {
					if (n = M.get(s, e), void 0 !== n) return n;
					if (n = M.get(s, r), void 0 !== n) return n;
					if (n = P(s, r, void 0), void 0 !== n) return n
				} else this.each(function() {
					var n = M.get(this, r);
					M.set(this, r, t), -1 !== e.indexOf("-") && void 0 !== n && M.set(this, e, t)
				})
			}, null, t, arguments.length > 1, null, !0)
		},
		removeData: function(e) {
			return this.each(function() {
				M.remove(this, e)
			})
		}
	}), o.extend({
		queue: function(e, t, n) {
			var r;
			return e ? (t = (t || "fx") + "queue", r = L.get(e, t), n && (!r || o.isArray(n) ? r = L.access(e, t, o.makeArray(n)) : r.push(n)), r || []) : void 0
		},
		dequeue: function(e, t) {
			t = t || "fx";
			var n = o.queue(e, t),
				r = n.length,
				i = n.shift(),
				s = o._queueHooks(e, t),
				u = function() {
					o.dequeue(e, t)
				};
			"inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete s.stop, i.call(e, u, s)), !r && s && s.empty.fire()
		},
		_queueHooks: function(e, t) {
			var n = t + "queueHooks";
			return L.get(e, n) || L.access(e, n, {
				empty: o.Callbacks("once memory").add(function() {
					L.remove(e, [t + "queue", n])
				})
			})
		}
	}), o.fn.extend({
		queue: function(e, t) {
			var n = 2;
			return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? o.queue(this[0], e) : void 0 === t ? this : this.each(function() {
				var n = o.queue(this, e, t);
				o._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && o.dequeue(this, e)
			})
		},
		dequeue: function(e) {
			return this.each(function() {
				o.dequeue(this, e)
			})
		},
		clearQueue: function(e) {
			return this.queue(e || "fx", [])
		},
		promise: function(e, t) {
			var n, r = 1,
				i = o.Deferred(),
				s = this,
				u = this.length,
				a = function() {
					--r || i.resolveWith(s, [s])
				};
			"string" != typeof e && (t = e, e = void 0), e = e || "fx";
			while (u--) n = L.get(s[u], e + "queueHooks"), n && n.empty && (r++, n.empty.add(a));
			return a(), i.promise(t)
		}
	});
	var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
		R = ["Top", "Right", "Bottom", "Left"],
		S = function(e, t) {
			return e = t || e, "none" === o.css(e, "display") || !o.contains(e.ownerDocument, e)
		},
		T = /^(?:checkbox|radio)$/i;
	! function() {
		var e = m.createDocumentFragment(),
			t = e.appendChild(m.createElement("div"));
		t.innerHTML = "<input type='radio' checked='checked' name='t'/>", l.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
	}();
	var U = "undefined";
	l.focusinBubbles = "onfocusin" in a;
	var V = /^key/,
		W = /^(?:mouse|contextmenu)|click/,
		X = /^(?:focusinfocus|focusoutblur)$/,
		Y = /^([^.]*)(?:\.(.+)|)$/;
	o.event = {
		global: {},
		add: function(e, t, n, r, i) {
			var s, u, a, f, l, c, h, p, d, v, m, g = L.get(e);
			if (g) {
				n.handler && (s = n, n = s.handler, i = s.selector), n.guid || (n.guid = o.guid++), (f = g.events) || (f = g.events = {}), (u = g.handle) || (u = g.handle = function(t) {
					return typeof o !== U && o.event.triggered !== t.type ? o.event.dispatch.apply(e, arguments) : void 0
				}), t = (t || "").match(E) || [""], l = t.length;
				while (l--) a = Y.exec(t[l]) || [], d = m = a[1], v = (a[2] || "").split(".").sort(), d && (h = o.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, h = o.event.special[d] || {}, c = o.extend({
					type: d,
					origType: m,
					data: r,
					handler: n,
					guid: n.guid,
					selector: i,
					needsContext: i && o.expr.match.needsContext.test(i),
					namespace: v.join(".")
				}, s), (p = f[d]) || (p = f[d] = [], p.delegateCount = 0, h.setup && h.setup.call(e, r, v, u) !== !1 || e.addEventListener && e.addEventListener(d, u, !1)), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), o.event.global[d] = !0)
			}
		},
		remove: function(e, t, n, r, i) {
			var s, u, a, f, l, c, h, p, d, v, m, g = L.hasData(e) && L.get(e);
			if (g && (f = g.events)) {
				t = (t || "").match(E) || [""], l = t.length;
				while (l--)
					if (a = Y.exec(t[l]) || [], d = m = a[1], v = (a[2] || "").split(".").sort(), d) {
						h = o.event.special[d] || {}, d = (r ? h.delegateType : h.bindType) || d, p = f[d] || [], a = a[2] && new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)"), u = s = p.length;
						while (s--) c = p[s], !i && m !== c.origType || n && n.guid !== c.guid || a && !a.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(s, 1), c.selector && p.delegateCount--, h.remove && h.remove.call(e, c));
						u && !p.length && (h.teardown && h.teardown.call(e, v, g.handle) !== !1 || o.removeEvent(e, d, g.handle), delete f[d])
					} else
						for (d in f) o.event.remove(e, d + t[l], n, r, !0);
				o.isEmptyObject(f) && (delete g.handle, L.remove(e, "events"))
			}
		},
		trigger: function(e, t, n, r) {
			var i, s, u, f, l, c, h, p = [n || m],
				d = j.call(e, "type") ? e.type : e,
				v = j.call(e, "namespace") ? e.namespace.split(".") : [];
			if (s = u = n = n || m, 3 !== n.nodeType && 8 !== n.nodeType && !X.test(d + o.event.triggered) && (d.indexOf(".") >= 0 && (v = d.split("."), d = v.shift(), v.sort()), l = d.indexOf(":") < 0 && "on" + d, e = e[o.expando] ? e : new o.Event(d, "object" == typeof e && e), e.isTrigger = r ? 2 : 3, e.namespace = v.join("."), e.namespace_re = e.namespace ? new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : o.makeArray(t, [e]), h = o.event.special[d] || {}, r || !h.trigger || h.trigger.apply(n, t) !== !1)) {
				if (!r && !h.noBubble && !o.isWindow(n)) {
					for (f = h.delegateType || d, X.test(f + d) || (s = s.parentNode); s; s = s.parentNode) p.push(s), u = s;
					u === (n.ownerDocument || m) && p.push(u.defaultView || u.parentWindow || a)
				}
				i = 0;
				while ((s = p[i++]) && !e.isPropagationStopped()) e.type = i > 1 ? f : h.bindType || d, c = (L.get(s, "events") || {})[e.type] && L.get(s, "handle"), c && c.apply(s, t), c = l && s[l], c && c.apply && o.acceptData(s) && (e.result = c.apply(s, t), e.result === !1 && e.preventDefault());
				return e.type = d, r || e.isDefaultPrevented() || h._default && h._default.apply(p.pop(), t) !== !1 || !o.acceptData(n) || l && o.isFunction(n[d]) && !o.isWindow(n) && (u = n[l], u && (n[l] = null), o.event.triggered = d, n[d](), o.event.triggered = void 0, u && (n[l] = u)), e.result
			}
		},
		dispatch: function(e) {
			e = o.event.fix(e);
			var t, n, r, i, s, u = [],
				a = d.call(arguments),
				f = (L.get(this, "events") || {})[e.type] || [],
				l = o.event.special[e.type] || {};
			if (a[0] = e, e.delegateTarget = this, !l.preDispatch || l.preDispatch.call(this, e) !== !1) {
				u = o.event.handlers.call(this, e, f), t = 0;
				while ((i = u[t++]) && !e.isPropagationStopped()) {
					e.currentTarget = i.elem, n = 0;
					while ((s = i.handlers[n++]) && !e.isImmediatePropagationStopped())(!e.namespace_re || e.namespace_re.test(s.namespace)) && (e.handleObj = s, e.data = s.data, r = ((o.event.special[s.origType] || {}).handle || s.handler).apply(i.elem, a), void 0 !== r && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()))
				}
				return l.postDispatch && l.postDispatch.call(this, e), e.result
			}
		},
		handlers: function(e, t) {
			var n, r, i, s, u = [],
				a = t.delegateCount,
				f = e.target;
			if (a && f.nodeType && (!e.button || "click" !== e.type))
				for (; f !== this; f = f.parentNode || this)
					if (f.disabled !== !0 || "click" !== e.type) {
						for (r = [], n = 0; a > n; n++) s = t[n], i = s.selector + " ", void 0 === r[i] && (r[i] = s.needsContext ? o(i, this).index(f) >= 0 : o.find(i, this, null, [f]).length), r[i] && r.push(s);
						r.length && u.push({
							elem: f,
							handlers: r
						})
					} return a < t.length && u.push({
				elem: this,
				handlers: t.slice(a)
			}), u
		},
		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
		fixHooks: {},
		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function(e, t) {
				return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
			}
		},
		mouseHooks: {
			props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
			filter: function(e, t) {
				var n, r, i, s = t.button;
				return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || m, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || void 0 === s || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e
			}
		},
		fix: function(e) {
			if (e[o.expando]) return e;
			var t, n, r, i = e.type,
				s = e,
				u = this.fixHooks[i];
			u || (this.fixHooks[i] = u = W.test(i) ? this.mouseHooks : V.test(i) ? this.keyHooks : {}), r = u.props ? this.props.concat(u.props) : this.props, e = new o.Event(s), t = r.length;
			while (t--) n = r[t], e[n] = s[n];
			return e.target || (e.target = m), 3 === e.target.nodeType && (e.target = e.target.parentNode), u.filter ? u.filter(e, s) : e
		},
		special: {
			load: {
				noBubble: !0
			},
			focus: {
				trigger: function() {
					return this !== _() && this.focus ? (this.focus(), !1) : void 0
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					return this === _() && this.blur ? (this.blur(), !1) : void 0
				},
				delegateType: "focusout"
			},
			click: {
				trigger: function() {
					return "checkbox" === this.type && this.click && o.nodeName(this, "input") ? (this.click(), !1) : void 0
				},
				_default: function(e) {
					return o.nodeName(e.target, "a")
				}
			},
			beforeunload: {
				postDispatch: function(e) {
					void 0 !== e.result && (e.originalEvent.returnValue = e.result)
				}
			}
		},
		simulate: function(e, t, n, r) {
			var i = o.extend(new o.Event, n, {
				type: e,
				isSimulated: !0,
				originalEvent: {}
			});
			r ? o.event.trigger(i, null, t) : o.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
		}
	}, o.removeEvent = function(e, t, n) {
		e.removeEventListener && e.removeEventListener(t, n, !1)
	}, o.Event = function(e, t) {
		return this instanceof o.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.getPreventDefault && e.getPreventDefault() ? Z : $) : this.type = e, t && o.extend(this, t), this.timeStamp = e && e.timeStamp || o.now(), void(this[o.expando] = !0)) : new o.Event(e, t)
	}, o.Event.prototype = {
		isDefaultPrevented: $,
		isPropagationStopped: $,
		isImmediatePropagationStopped: $,
		preventDefault: function() {
			var e = this.originalEvent;
			this.isDefaultPrevented = Z, e && e.preventDefault && e.preventDefault()
		},
		stopPropagation: function() {
			var e = this.originalEvent;
			this.isPropagationStopped = Z, e && e.stopPropagation && e.stopPropagation()
		},
		stopImmediatePropagation: function() {
			this.isImmediatePropagationStopped = Z, this.stopPropagation()
		}
	}, o.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout"
	}, function(e, t) {
		o.event.special[e] = {
			delegateType: t,
			bindType: t,
			handle: function(e) {
				var n, r = this,
					i = e.relatedTarget,
					s = e.handleObj;
				return (!i || i !== r && !o.contains(r, i)) && (e.type = s.origType, n = s.handler.apply(this, arguments), e.type = t), n
			}
		}
	}), l.focusinBubbles || o.each({
		focus: "focusin",
		blur: "focusout"
	}, function(e, t) {
		var n = function(e) {
			o.event.simulate(t, e.target, o.event.fix(e), !0)
		};
		o.event.special[t] = {
			setup: function() {
				var r = this.ownerDocument || this,
					i = L.access(r, t);
				i || r.addEventListener(e, n, !0), L.access(r, t, (i || 0) + 1)
			},
			teardown: function() {
				var r = this.ownerDocument || this,
					i = L.access(r, t) - 1;
				i ? L.access(r, t, i) : (r.removeEventListener(e, n, !0), L.remove(r, t))
			}
		}
	}), o.fn.extend({
		on: function(e, t, n, r, i) {
			var s, u;
			if ("object" == typeof e) {
				"string" != typeof t && (n = n || t, t = void 0);
				for (u in e) this.on(u, t, n, e[u], i);
				return this
			}
			if (null == n && null == r ? (r = t, n = t = void 0) : null == r && ("string" == typeof t ? (r = n, n = void 0) : (r = n, n = t, t = void 0)), r === !1) r = $;
			else if (!r) return this;
			return 1 === i && (s = r, r = function(e) {
				return o().off(e), s.apply(this, arguments)
			}, r.guid = s.guid || (s.guid = o.guid++)), this.each(function() {
				o.event.add(this, e, r, n, t)
			})
		},
		one: function(e, t, n, r) {
			return this.on(e, t, n, r, 1)
		},
		off: function(e, t, n) {
			var r, i;
			if (e && e.preventDefault && e.handleObj) return r = e.handleObj, o(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
			if ("object" == typeof e) {
				for (i in e) this.off(i, t, e[i]);
				return this
			}
			return (t === !1 || "function" == typeof t) && (n = t, t = void 0), n === !1 && (n = $), this.each(function() {
				o.event.remove(this, e, n, t)
			})
		},
		trigger: function(e, t) {
			return this.each(function() {
				o.event.trigger(e, t, this)
			})
		},
		triggerHandler: function(e, t) {
			var n = this[0];
			return n ? o.event.trigger(e, t, n, !0) : void 0
		}
	});
	var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
		bb = /<([\w:]+)/,
		cb = /<|&#?\w+;/,
		db = /<(?:script|style|link)/i,
		eb = /checked\s*(?:[^=]|=\s*.checked.)/i,
		fb = /^$|\/(?:java|ecma)script/i,
		gb = /^true\/(.*)/,
		hb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
		ib = {
			option: [1, "<select multiple='multiple'>", "</select>"],
			thead: [1, "<table>", "</table>"],
			col: [2, "<table><colgroup>", "</colgroup></table>"],
			tr: [2, "<table><tbody>", "</tbody></table>"],
			td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
			_default: [0, "", ""]
		};
	ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td, o.extend({
		clone: function(e, t, n) {
			var r, i, s, u, a = e.cloneNode(!0),
				f = o.contains(e.ownerDocument, e);
			if (!(l.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || o.isXMLDoc(e)))
				for (u = ob(a), s = ob(e), r = 0, i = s.length; i > r; r++) pb(s[r], u[r]);
			if (t)
				if (n)
					for (s = s || ob(e), u = u || ob(a), r = 0, i = s.length; i > r; r++) nb(s[r], u[r]);
				else nb(e, a);
			return u = ob(a, "script"), u.length > 0 && mb(u, !f && ob(e, "script")), a
		},
		buildFragment: function(e, t, n, r) {
			for (var i, s, u, a, f, l, c = t.createDocumentFragment(), h = [], p = 0, d = e.length; d > p; p++)
				if (i = e[p], i || 0 === i)
					if ("object" === o.type(i)) o.merge(h, i.nodeType ? [i] : i);
					else if (cb.test(i)) {
				s = s || c.appendChild(t.createElement("div")), u = (bb.exec(i) || ["", ""])[1].toLowerCase(), a = ib[u] || ib._default, s.innerHTML = a[1] + i.replace(ab, "<$1></$2>") + a[2], l = a[0];
				while (l--) s = s.lastChild;
				o.merge(h, s.childNodes), s = c.firstChild, s.textContent = ""
			} else h.push(t.createTextNode(i));
			c.textContent = "", p = 0;
			while (i = h[p++])
				if ((!r || -1 === o.inArray(i, r)) && (f = o.contains(i.ownerDocument, i), s = ob(c.appendChild(i), "script"), f && mb(s), n)) {
					l = 0;
					while (i = s[l++]) fb.test(i.type || "") && n.push(i)
				} return c
		},
		cleanData: function(e) {
			for (var t, n, r, i, s, u, a = o.event.special, f = 0; void 0 !== (n = e[f]); f++) {
				if (o.acceptData(n) && (s = n[L.expando], s && (t = L.cache[s]))) {
					if (r = Object.keys(t.events || {}), r.length)
						for (u = 0; void 0 !== (i = r[u]); u++) a[i] ? o.event.remove(n, i) : o.removeEvent(n, i, t.handle);
					L.cache[s] && delete L.cache[s]
				}
				delete M.cache[n[M.expando]]
			}
		}
	}), o.fn.extend({
		text: function(e) {
			return J(this, function(e) {
				return void 0 === e ? o.text(this) : this.empty().each(function() {
					(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = e)
				})
			}, null, e, arguments.length)
		},
		append: function() {
			return this.domManip(arguments, function(e) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var t = jb(this, e);
					t.appendChild(e)
				}
			})
		},
		prepend: function() {
			return this.domManip(arguments, function(e) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var t = jb(this, e);
					t.insertBefore(e, t.firstChild)
				}
			})
		},
		before: function() {
			return this.domManip(arguments, function(e) {
				this.parentNode && this.parentNode.insertBefore(e, this)
			})
		},
		after: function() {
			return this.domManip(arguments, function(e) {
				this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
			})
		},
		remove: function(e, t) {
			for (var n, r = e ? o.filter(e, this) : this, i = 0; null != (n = r[i]); i++) t || 1 !== n.nodeType || o.cleanData(ob(n)), n.parentNode && (t && o.contains(n.ownerDocument, n) && mb(ob(n, "script")), n.parentNode.removeChild(n));
			return this
		},
		empty: function() {
			for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (o.cleanData(ob(e, !1)), e.textContent = "");
			return this
		},
		clone: function(e, t) {
			return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
				return o.clone(this, e, t)
			})
		},
		html: function(e) {
			return J(this, function(e) {
				var t = this[0] || {},
					n = 0,
					r = this.length;
				if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
				if ("string" == typeof e && !db.test(e) && !ib[(bb.exec(e) || ["", ""])[1].toLowerCase()]) {
					e = e.replace(ab, "<$1></$2>");
					try {
						for (; r > n; n++) t = this[n] || {}, 1 === t.nodeType && (o.cleanData(ob(t, !1)), t.innerHTML = e);
						t = 0
					} catch (i) {}
				}
				t && this.empty().append(e)
			}, null, e, arguments.length)
		},
		replaceWith: function() {
			var e = arguments[0];
			return this.domManip(arguments, function(t) {
				e = this.parentNode, o.cleanData(ob(this)), e && e.replaceChild(t, this)
			}), e && (e.length || e.nodeType) ? this : this.remove()
		},
		detach: function(e) {
			return this.remove(e, !0)
		},
		domManip: function(t, n) {
			t = e.apply([], t);
			var r, i, s, u, a, f, c = 0,
				h = this.length,
				p = this,
				d = h - 1,
				v = t[0],
				m = o.isFunction(v);
			if (m || h > 1 && "string" == typeof v && !l.checkClone && eb.test(v)) return this.each(function(e) {
				var r = p.eq(e);
				m && (t[0] = v.call(this, e, r.html())), r.domManip(t, n)
			});
			if (h && (r = o.buildFragment(t, this[0].ownerDocument, !1, this), i = r.firstChild, 1 === r.childNodes.length && (r = i), i)) {
				for (s = o.map(ob(r, "script"), kb), u = s.length; h > c; c++) a = r, c !== d && (a = o.clone(a, !0, !0), u && o.merge(s, ob(a, "script"))), n.call(this[c], a, c);
				if (u)
					for (f = s[s.length - 1].ownerDocument, o.map(s, lb), c = 0; u > c; c++) a = s[c], fb.test(a.type || "") && !L.access(a, "globalEval") && o.contains(f, a) && (a.src ? o._evalUrl && o._evalUrl(a.src) : o.globalEval(a.textContent.replace(hb, "")))
			}
			return this
		}
	}), o.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function(e, t) {
		o.fn[e] = function(e) {
			for (var n, r = [], i = o(e), s = i.length - 1, u = 0; s >= u; u++) n = u === s ? this : this.clone(!0), o(i[u])[t](n), f.apply(r, n.get());
			return this.pushStack(r)
		}
	});
	var qb, rb = {},
		ub = /^margin/,
		vb = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
		wb = function(e) {
			return e.ownerDocument.defaultView.getComputedStyle(e, null)
		};
	! function() {
		function u() {
			s.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%", r.appendChild(i);
			var n = a.getComputedStyle(s, null);
			e = "1%" !== n.top, t = "4px" === n.width, r.removeChild(i)
		}
		var e, t, n = "padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",
			r = m.documentElement,
			i = m.createElement("div"),
			s = m.createElement("div");
		s.style.backgroundClip = "content-box", s.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === s.style.backgroundClip, i.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", i.appendChild(s), a.getComputedStyle && o.extend(l, {
			pixelPosition: function() {
				return u(), e
			},
			boxSizingReliable: function() {
				return null == t && u(), t
			},
			reliableMarginRight: function() {
				var e, t = s.appendChild(m.createElement("div"));
				return t.style.cssText = s.style.cssText = n, t.style.marginRight = t.style.width = "0", s.style.width = "1px", r.appendChild(i), e = !parseFloat(a.getComputedStyle(t, null).marginRight), r.removeChild(i), s.innerHTML = "", e
			}
		})
	}(), o.swap = function(e, t, n, r) {
		var i, s, o = {};
		for (s in t) o[s] = e.style[s], e.style[s] = t[s];
		i = n.apply(e, r || []);
		for (s in t) e.style[s] = o[s];
		return i
	};
	var zb = /^(none|table(?!-c[ea]).+)/,
		Ab = new RegExp("^(" + Q + ")(.*)$", "i"),
		Bb = new RegExp("^([+-])=(" + Q + ")", "i"),
		Cb = {
			position: "absolute",
			visibility: "hidden",
			display: "block"
		},
		Db = {
			letterSpacing: 0,
			fontWeight: 400
		},
		Eb = ["Webkit", "O", "Moz", "ms"];
	o.extend({
		cssHooks: {
			opacity: {
				get: function(e, t) {
					if (t) {
						var n = xb(e, "opacity");
						return "" === n ? "1" : n
					}
				}
			}
		},
		cssNumber: {
			columnCount: !0,
			fillOpacity: !0,
			fontWeight: !0,
			lineHeight: !0,
			opacity: !0,
			order: !0,
			orphans: !0,
			widows: !0,
			zIndex: !0,
			zoom: !0
		},
		cssProps: {
			"float": "cssFloat"
		},
		style: function(e, t, n, r) {
			if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
				var i, s, u, a = o.camelCase(t),
					f = e.style;
				return t = o.cssProps[a] || (o.cssProps[a] = Fb(f, a)), u = o.cssHooks[t] || o.cssHooks[a], void 0 === n ? u && "get" in u && void 0 !== (i = u.get(e, !1, r)) ? i : f[t] : (s = typeof n, "string" === s && (i = Bb.exec(n)) && (n = (i[1] + 1) * i[2] + parseFloat(o.css(e, t)), s = "number"), null != n && n === n && ("number" !== s || o.cssNumber[a] || (n += "px"), l.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (f[t] = "inherit"), u && "set" in u && void 0 === (n = u.set(e, n, r)) || (f[t] = "", f[t] = n)), void 0)
			}
		},
		css: function(e, t, n, r) {
			var i, s, u, a = o.camelCase(t);
			return t = o.cssProps[a] || (o.cssProps[a] = Fb(e.style, a)), u = o.cssHooks[t] || o.cssHooks[a], u && "get" in u && (i = u.get(e, !0, n)), void 0 === i && (i = xb(e, t, r)), "normal" === i && t in Db && (i = Db[t]), "" === n || n ? (s = parseFloat(i), n === !0 || o.isNumeric(s) ? s || 0 : i) : i
		}
	}), o.each(["height", "width"], function(e, t) {
		o.cssHooks[t] = {
			get: function(e, n, r) {
				return n ? 0 === e.offsetWidth && zb.test(o.css(e, "display")) ? o.swap(e, Cb, function() {
					return Ib(e, t, r)
				}) : Ib(e, t, r) : void 0
			},
			set: function(e, n, r) {
				var i = r && wb(e);
				return Gb(e, n, r ? Hb(e, t, r, "border-box" === o.css(e, "boxSizing", !1, i), i) : 0)
			}
		}
	}), o.cssHooks.marginRight = yb(l.reliableMarginRight, function(e, t) {
		return t ? o.swap(e, {
			display: "inline-block"
		}, xb, [e, "marginRight"]) : void 0
	}), o.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function(e, t) {
		o.cssHooks[e + t] = {
			expand: function(n) {
				for (var r = 0, i = {}, s = "string" == typeof n ? n.split(" ") : [n]; 4 > r; r++) i[e + R[r] + t] = s[r] || s[r - 2] || s[0];
				return i
			}
		}, ub.test(e) || (o.cssHooks[e + t].set = Gb)
	}), o.fn.extend({
		css: function(e, t) {
			return J(this, function(e, t, n) {
				var r, i, s = {},
					u = 0;
				if (o.isArray(t)) {
					for (r = wb(e), i = t.length; i > u; u++) s[t[u]] = o.css(e, t[u], !1, r);
					return s
				}
				return void 0 !== n ? o.style(e, t, n) : o.css(e, t)
			}, e, t, arguments.length > 1)
		},
		show: function() {
			return Jb(this, !0)
		},
		hide: function() {
			return Jb(this)
		},
		toggle: function(e) {
			return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
				S(this) ? o(this).show() : o(this).hide()
			})
		}
	}), o.Tween = Kb, Kb.prototype = {
		constructor: Kb,
		init: function(e, t, n, r, i, s) {
			this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = s || (o.cssNumber[n] ? "" : "px")
		},
		cur: function() {
			var e = Kb.propHooks[this.prop];
			return e && e.get ? e.get(this) : Kb.propHooks._default.get(this)
		},
		run: function(e) {
			var t, n = Kb.propHooks[this.prop];
			return this.pos = t = this.options.duration ? o.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Kb.propHooks._default.set(this), this
		}
	}, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {
		_default: {
			get: function(e) {
				var t;
				return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = o.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
			},
			set: function(e) {
				o.fx.step[e.prop] ? o.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[o.cssProps[e.prop]] || o.cssHooks[e.prop]) ? o.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
			}
		}
	}, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {
		set: function(e) {
			e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
		}
	}, o.easing = {
		linear: function(e) {
			return e
		},
		swing: function(e) {
			return .5 - Math.cos(e * Math.PI) / 2
		}
	}, o.fx = Kb.prototype.init, o.fx.step = {};
	var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,
		Ob = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
		Pb = /queueHooks$/,
		Qb = [Vb],
		Rb = {
			"*": [function(e, t) {
				var n = this.createTween(e, t),
					r = n.cur(),
					i = Ob.exec(t),
					s = i && i[3] || (o.cssNumber[e] ? "" : "px"),
					u = (o.cssNumber[e] || "px" !== s && +r) && Ob.exec(o.css(n.elem, e)),
					a = 1,
					f = 20;
				if (u && u[3] !== s) {
					s = s || u[3], i = i || [], u = +r || 1;
					do a = a || ".5", u /= a, o.style(n.elem, e, u + s); while (a !== (a = n.cur() / r) && 1 !== a && --f)
				}
				return i && (u = n.start = +u || +r || 0, n.unit = s, n.end = i[1] ? u + (i[1] + 1) * i[2] : +i[2]), n
			}]
		};
	o.Animation = o.extend(Xb, {
			tweener: function(e, t) {
				o.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
				for (var n, r = 0, i = e.length; i > r; r++) n = e[r], Rb[n] = Rb[n] || [], Rb[n].unshift(t)
			},
			prefilter: function(e, t) {
				t ? Qb.unshift(e) : Qb.push(e)
			}
		}), o.speed = function(e, t, n) {
			var r = e && "object" == typeof e ? o.extend({}, e) : {
				complete: n || !n && t || o.isFunction(e) && e,
				duration: e,
				easing: n && t || t && !o.isFunction(t) && t
			};
			return r.duration = o.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in o.fx.speeds ? o.fx.speeds[r.duration] : o.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function() {
				o.isFunction(r.old) && r.old.call(this), r.queue && o.dequeue(this, r.queue)
			}, r
		}, o.fn.extend({
			fadeTo: function(e, t, n, r) {
				return this.filter(S).css("opacity", 0).show().end().animate({
					opacity: t
				}, e, n, r)
			},
			animate: function(e, t, n, r) {
				var i = o.isEmptyObject(e),
					s = o.speed(t, n, r),
					u = function() {
						var t = Xb(this, o.extend({}, e), s);
						(i || L.get(this, "finish")) && t.stop(!0)
					};
				return u.finish = u, i || s.queue === !1 ? this.each(u) : this.queue(s.queue, u)
			},
			stop: function(e, t, n) {
				var r = function(e) {
					var t = e.stop;
					delete e.stop, t(n)
				};
				return "string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function() {
					var t = !0,
						i = null != e && e + "queueHooks",
						s = o.timers,
						u = L.get(this);
					if (i) u[i] && u[i].stop && r(u[i]);
					else
						for (i in u) u[i] && u[i].stop && Pb.test(i) && r(u[i]);
					for (i = s.length; i--;) s[i].elem !== this || null != e && s[i].queue !== e || (s[i].anim.stop(n), t = !1, s.splice(i, 1));
					(t || !n) && o.dequeue(this, e)
				})
			},
			finish: function(e) {
				return e !== !1 && (e = e || "fx"), this.each(function() {
					var t, n = L.get(this),
						r = n[e + "queue"],
						i = n[e + "queueHooks"],
						s = o.timers,
						u = r ? r.length : 0;
					for (n.finish = !0, o.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = s.length; t--;) s[t].elem === this && s[t].queue === e && (s[t].anim.stop(!0), s.splice(t, 1));
					for (t = 0; u > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
					delete n.finish
				})
			}
		}), o.each(["toggle", "show", "hide"], function(e, t) {
			var n = o.fn[t];
			o.fn[t] = function(e, r, i) {
				return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(Tb(t, !0), e, r, i)
			}
		}), o.each({
			slideDown: Tb("show"),
			slideUp: Tb("hide"),
			slideToggle: Tb("toggle"),
			fadeIn: {
				opacity: "show"
			},
			fadeOut: {
				opacity: "hide"
			},
			fadeToggle: {
				opacity: "toggle"
			}
		}, function(e, t) {
			o.fn[e] = function(e, n, r) {
				return this.animate(t, e, n, r)
			}
		}), o.timers = [], o.fx.tick = function() {
			var e, t = 0,
				n = o.timers;
			for (Lb = o.now(); t < n.length; t++) e = n[t], e() || n[t] !== e || n.splice(t--, 1);
			n.length || o.fx.stop(), Lb = void 0
		}, o.fx.timer = function(e) {
			o.timers.push(e), e() ? o.fx.start() : o.timers.pop()
		}, o.fx.interval = 13, o.fx.start = function() {
			Mb || (Mb = setInterval(o.fx.tick, o.fx.interval))
		}, o.fx.stop = function() {
			clearInterval(Mb), Mb = null
		}, o.fx.speeds = {
			slow: 600,
			fast: 200,
			_default: 400
		}, o.fn.delay = function(e, t) {
			return e = o.fx ? o.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) {
				var r = setTimeout(t, e);
				n.stop = function() {
					clearTimeout(r)
				}
			})
		},
		function() {
			var e = m.createElement("input"),
				t = m.createElement("select"),
				n = t.appendChild(m.createElement("option"));
			e.type = "checkbox", l.checkOn = "" !== e.value, l.optSelected = n.selected, t.disabled = !0, l.optDisabled = !n.disabled, e = m.createElement("input"), e.value = "t", e.type = "radio", l.radioValue = "t" === e.value
		}();
	var Yb, Zb, $b = o.expr.attrHandle;
	o.fn.extend({
		attr: function(e, t) {
			return J(this, o.attr, e, t, arguments.length > 1)
		},
		removeAttr: function(e) {
			return this.each(function() {
				o.removeAttr(this, e)
			})
		}
	}), o.extend({
		attr: function(e, t, n) {
			var r, i, s = e.nodeType;
			if (e && 3 !== s && 8 !== s && 2 !== s) return typeof e.getAttribute === U ? o.prop(e, t, n) : (1 === s && o.isXMLDoc(e) || (t = t.toLowerCase(), r = o.attrHooks[t] || (o.expr.match.bool.test(t) ? Zb : Yb)), void 0 === n ? r && "get" in r && null !== (i = r.get(e, t)) ? i : (i = o.find.attr(e, t), null == i ? void 0 : i) : null !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : void o.removeAttr(e, t))
		},
		removeAttr: function(e, t) {
			var n, r, i = 0,
				s = t && t.match(E);
			if (s && 1 === e.nodeType)
				while (n = s[i++]) r = o.propFix[n] || n, o.expr.match.bool.test(n) && (e[r] = !1), e.removeAttribute(n)
		},
		attrHooks: {
			type: {
				set: function(e, t) {
					if (!l.radioValue && "radio" === t && o.nodeName(e, "input")) {
						var n = e.value;
						return e.setAttribute("type", t), n && (e.value = n), t
					}
				}
			}
		}
	}), Zb = {
		set: function(e, t, n) {
			return t === !1 ? o.removeAttr(e, n) : e.setAttribute(n, n), n
		}
	}, o.each(o.expr.match.bool.source.match(/\w+/g), function(e, t) {
		var n = $b[t] || o.find.attr;
		$b[t] = function(e, t, r) {
			var i, s;
			return r || (s = $b[t], $b[t] = i, i = null != n(e, t, r) ? t.toLowerCase() : null, $b[t] = s), i
		}
	});
	var _b = /^(?:input|select|textarea|button)$/i;
	o.fn.extend({
		prop: function(e, t) {
			return J(this, o.prop, e, t, arguments.length > 1)
		},
		removeProp: function(e) {
			return this.each(function() {
				delete this[o.propFix[e] || e]
			})
		}
	}), o.extend({
		propFix: {
			"for": "htmlFor",
			"class": "className"
		},
		prop: function(e, t, n) {
			var r, i, s, u = e.nodeType;
			if (e && 3 !== u && 8 !== u && 2 !== u) return s = 1 !== u || !o.isXMLDoc(e), s && (t = o.propFix[t] || t, i = o.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
		},
		propHooks: {
			tabIndex: {
				get: function(e) {
					return e.hasAttribute("tabindex") || _b.test(e.nodeName) || e.href ? e.tabIndex : -1
				}
			}
		}
	}), l.optSelected || (o.propHooks.selected = {
		get: function(e) {
			var t = e.parentNode;
			return t && t.parentNode && t.parentNode.selectedIndex, null
		}
	}), o.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
		o.propFix[this.toLowerCase()] = this
	});
	var ac = /[\t\r\n\f]/g;
	o.fn.extend({
		addClass: function(e) {
			var t, n, r, i, s, u, a = "string" == typeof e && e,
				f = 0,
				l = this.length;
			if (o.isFunction(e)) return this.each(function(t) {
				o(this).addClass(e.call(this, t, this.className))
			});
			if (a)
				for (t = (e || "").match(E) || []; l > f; f++)
					if (n = this[f], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ac, " ") : " ")) {
						s = 0;
						while (i = t[s++]) r.indexOf(" " + i + " ") < 0 && (r += i + " ");
						u = o.trim(r), n.className !== u && (n.className = u)
					} return this
		},
		removeClass: function(e) {
			var t, n, r, i, s, u, a = 0 === arguments.length || "string" == typeof e && e,
				f = 0,
				l = this.length;
			if (o.isFunction(e)) return this.each(function(t) {
				o(this).removeClass(e.call(this, t, this.className))
			});
			if (a)
				for (t = (e || "").match(E) || []; l > f; f++)
					if (n = this[f], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ac, " ") : "")) {
						s = 0;
						while (i = t[s++])
							while (r.indexOf(" " + i + " ") >= 0) r = r.replace(" " + i + " ", " ");
						u = e ? o.trim(r) : "", n.className !== u && (n.className = u)
					} return this
		},
		toggleClass: function(e, t) {
			var n = typeof e;
			return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : this.each(o.isFunction(e) ? function(n) {
				o(this).toggleClass(e.call(this, n, this.className, t), t)
			} : function() {
				if ("string" === n) {
					var t, r = 0,
						i = o(this),
						s = e.match(E) || [];
					while (t = s[r++]) i.hasClass(t) ? i.removeClass(t) : i.addClass(t)
				} else(n === U || "boolean" === n) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : L.get(this, "__className__") || "")
			})
		},
		hasClass: function(e) {
			for (var t = " " + e + " ", n = 0, r = this.length; r > n; n++)
				if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(ac, " ").indexOf(t) >= 0) return !0;
			return !1
		}
	});
	var bc = /\r/g;
	o.fn.extend({
		val: function(e) {
			var t, n, r, i = this[0];
			if (arguments.length) return r = o.isFunction(e), this.each(function(n) {
				var i;
				1 === this.nodeType && (i = r ? e.call(this, n, o(this).val()) : e, null == i ? i = "" : "number" == typeof i ? i += "" : o.isArray(i) && (i = o.map(i, function(e) {
					return null == e ? "" : e + ""
				})), t = o.valHooks[this.type] || o.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i))
			});
			if (i) return t = o.valHooks[i.type] || o.valHooks[i.nodeName.toLowerCase()], t && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : (n = i.value, "string" == typeof n ? n.replace(bc, "") : null == n ? "" : n)
		}
	}), o.extend({
		valHooks: {
			select: {
				get: function(e) {
					for (var t, n, r = e.options, i = e.selectedIndex, s = "select-one" === e.type || 0 > i, u = s ? null : [], a = s ? i + 1 : r.length, f = 0 > i ? a : s ? i : 0; a > f; f++)
						if (n = r[f], !(!n.selected && f !== i || (l.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && o.nodeName(n.parentNode, "optgroup"))) {
							if (t = o(n).val(), s) return t;
							u.push(t)
						} return u
				},
				set: function(e, t) {
					var n, r, i = e.options,
						s = o.makeArray(t),
						u = i.length;
					while (u--) r = i[u], (r.selected = o.inArray(o(r).val(), s) >= 0) && (n = !0);
					return n || (e.selectedIndex = -1), s
				}
			}
		}
	}), o.each(["radio", "checkbox"], function() {
		o.valHooks[this] = {
			set: function(e, t) {
				return o.isArray(t) ? e.checked = o.inArray(o(e).val(), t) >= 0 : void 0
			}
		}, l.checkOn || (o.valHooks[this].get = function(e) {
			return null === e.getAttribute("value") ? "on" : e.value
		})
	}), o.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
		o.fn[t] = function(e, n) {
			return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
		}
	}), o.fn.extend({
		hover: function(e, t) {
			return this.mouseenter(e).mouseleave(t || e)
		},
		bind: function(e, t, n) {
			return this.on(e, null, t, n)
		},
		unbind: function(e, t) {
			return this.off(e, null, t)
		},
		delegate: function(e, t, n, r) {
			return this.on(t, e, n, r)
		},
		undelegate: function(e, t, n) {
			return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
		}
	});
	var cc = o.now(),
		dc = /\?/;
	o.parseJSON = function(e) {
		return JSON.parse(e + "")
	}, o.parseXML = function(e) {
		var t, n;
		if (!e || "string" != typeof e) return null;
		try {
			n = new DOMParser, t = n.parseFromString(e, "text/xml")
		} catch (r) {
			t = void 0
		}
		return (!t || t.getElementsByTagName("parsererror").length) && o.error("Invalid XML: " + e), t
	};
	var ec, fc, gc = /#.*$/,
		hc = /([?&])_=[^&]*/,
		ic = /^(.*?):[ \t]*([^\r\n]*)$/gm,
		jc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		kc = /^(?:GET|HEAD)$/,
		lc = /^\/\//,
		mc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
		nc = {},
		oc = {},
		pc = "*/".concat("*");
	try {
		fc = location.href
	} catch (qc) {
		fc = m.createElement("a"), fc.href = "", fc = fc.href
	}
	ec = mc.exec(fc.toLowerCase()) || [], o.extend({
		active: 0,
		lastModified: {},
		etag: {},
		ajaxSettings: {
			url: fc,
			type: "GET",
			isLocal: jc.test(ec[1]),
			global: !0,
			processData: !0,
			async: !0,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			accepts: {
				"*": pc,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
			contents: {
				xml: /xml/,
				html: /html/,
				json: /json/
			},
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
			converters: {
				"* text": String,
				"text html": !0,
				"text json": o.parseJSON,
				"text xml": o.parseXML
			},
			flatOptions: {
				url: !0,
				context: !0
			}
		},
		ajaxSetup: function(e, t) {
			return t ? tc(tc(e, o.ajaxSettings), t) : tc(o.ajaxSettings, e)
		},
		ajaxPrefilter: rc(nc),
		ajaxTransport: rc(oc),
		ajax: function(e, t) {
			function T(e, t, s, a) {
				var l, g, y, w, E, x = t;
				2 !== b && (b = 2, u && clearTimeout(u), n = void 0, i = a || "", S.readyState = e > 0 ? 4 : 0, l = e >= 200 && 300 > e || 304 === e, s && (w = uc(c, S, s)), w = vc(c, w, S, l), l ? (c.ifModified && (E = S.getResponseHeader("Last-Modified"), E && (o.lastModified[r] = E), E = S.getResponseHeader("etag"), E && (o.etag[r] = E)), 204 === e || "HEAD" === c.type ? x = "nocontent" : 304 === e ? x = "notmodified" : (x = w.state, g = w.data, y = w.error, l = !y)) : (y = x, (e || !x) && (x = "error", 0 > e && (e = 0))), S.status = e, S.statusText = (t || x) + "", l ? d.resolveWith(h, [g, x, S]) : d.rejectWith(h, [S, x, y]), S.statusCode(m), m = void 0, f && p.trigger(l ? "ajaxSuccess" : "ajaxError", [S, c, l ? g : y]), v.fireWith(h, [S, x]), f && (p.trigger("ajaxComplete", [S, c]), --o.active || o.event.trigger("ajaxStop")))
			}
			"object" == typeof e && (t = e, e = void 0), t = t || {};
			var n, r, i, s, u, a, f, l, c = o.ajaxSetup({}, t),
				h = c.context || c,
				p = c.context && (h.nodeType || h.jquery) ? o(h) : o.event,
				d = o.Deferred(),
				v = o.Callbacks("once memory"),
				m = c.statusCode || {},
				g = {},
				y = {},
				b = 0,
				w = "canceled",
				S = {
					readyState: 0,
					getResponseHeader: function(e) {
						var t;
						if (2 === b) {
							if (!s) {
								s = {};
								while (t = ic.exec(i)) s[t[1].toLowerCase()] = t[2]
							}
							t = s[e.toLowerCase()]
						}
						return null == t ? null : t
					},
					getAllResponseHeaders: function() {
						return 2 === b ? i : null
					},
					setRequestHeader: function(e, t) {
						var n = e.toLowerCase();
						return b || (e = y[n] = y[n] || e, g[e] = t), this
					},
					overrideMimeType: function(e) {
						return b || (c.mimeType = e), this
					},
					statusCode: function(e) {
						var t;
						if (e)
							if (2 > b)
								for (t in e) m[t] = [m[t], e[t]];
							else S.always(e[S.status]);
						return this
					},
					abort: function(e) {
						var t = e || w;
						return n && n.abort(t), T(0, t), this
					}
				};
			if (d.promise(S).complete = v.add, S.success = S.done, S.error = S.fail, c.url = ((e || c.url || fc) + "").replace(gc, "").replace(lc, ec[1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = o.trim(c.dataType || "*").toLowerCase().match(E) || [""], null == c.crossDomain && (a = mc.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === ec[1] && a[2] === ec[2] && (a[3] || ("http:" === a[1] ? "80" : "443")) === (ec[3] || ("http:" === ec[1] ? "80" : "443")))), c.data && c.processData && "string" != typeof c.data && (c.data = o.param(c.data, c.traditional)), sc(nc, c, t, S), 2 === b) return S;
			f = c.global, f && 0 === o.active++ && o.event.trigger("ajaxStart"), c.type = c.type.toUpperCase(), c.hasContent = !kc.test(c.type), r = c.url, c.hasContent || (c.data && (r = c.url += (dc.test(r) ? "&" : "?") + c.data, delete c.data), c.cache === !1 && (c.url = hc.test(r) ? r.replace(hc, "$1_=" + cc++) : r + (dc.test(r) ? "&" : "?") + "_=" + cc++)), c.ifModified && (o.lastModified[r] && S.setRequestHeader("If-Modified-Since", o.lastModified[r]), o.etag[r] && S.setRequestHeader("If-None-Match", o.etag[r])), (c.data && c.hasContent && c.contentType !== !1 || t.contentType) && S.setRequestHeader("Content-Type", c.contentType), S.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + ("*" !== c.dataTypes[0] ? ", " + pc + "; q=0.01" : "") : c.accepts["*"]);
			for (l in c.headers) S.setRequestHeader(l, c.headers[l]);
			if (!c.beforeSend || c.beforeSend.call(h, S, c) !== !1 && 2 !== b) {
				w = "abort";
				for (l in {
						success: 1,
						error: 1,
						complete: 1
					}) S[l](c[l]);
				if (n = sc(oc, c, t, S)) {
					S.readyState = 1, f && p.trigger("ajaxSend", [S, c]), c.async && c.timeout > 0 && (u = setTimeout(function() {
						S.abort("timeout")
					}, c.timeout));
					try {
						b = 1, n.send(g, T)
					} catch (x) {
						if (!(2 > b)) throw x;
						T(-1, x)
					}
				} else T(-1, "No Transport");
				return S
			}
			return S.abort()
		},
		getJSON: function(e, t, n) {
			return o.get(e, t, n, "json")
		},
		getScript: function(e, t) {
			return o.get(e, void 0, t, "script")
		}
	}), o.each(["get", "post"], function(e, t) {
		o[t] = function(e, n, r, i) {
			return o.isFunction(n) && (i = i || r, r = n, n = void 0), o.ajax({
				url: e,
				type: t,
				dataType: i,
				data: n,
				success: r
			})
		}
	}), o.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
		o.fn[t] = function(e) {
			return this.on(t, e)
		}
	}), o._evalUrl = function(e) {
		return o.ajax({
			url: e,
			type: "GET",
			dataType: "script",
			async: !1,
			global: !1,
			"throws": !0
		})
	}, o.fn.extend({
		wrapAll: function(e) {
			var t;
			return o.isFunction(e) ? this.each(function(t) {
				o(this).wrapAll(e.call(this, t))
			}) : (this[0] && (t = o(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
				var e = this;
				while (e.firstElementChild) e = e.firstElementChild;
				return e
			}).append(this)), this)
		},
		wrapInner: function(e) {
			return this.each(o.isFunction(e) ? function(t) {
				o(this).wrapInner(e.call(this, t))
			} : function() {
				var t = o(this),
					n = t.contents();
				n.length ? n.wrapAll(e) : t.append(e)
			})
		},
		wrap: function(e) {
			var t = o.isFunction(e);
			return this.each(function(n) {
				o(this).wrapAll(t ? e.call(this, n) : e)
			})
		},
		unwrap: function() {
			return this.parent().each(function() {
				o.nodeName(this, "body") || o(this).replaceWith(this.childNodes)
			}).end()
		}
	}), o.expr.filters.hidden = function(e) {
		return e.offsetWidth <= 0 && e.offsetHeight <= 0
	}, o.expr.filters.visible = function(e) {
		return !o.expr.filters.hidden(e)
	};
	var wc = /%20/g,
		xc = /\[\]$/,
		yc = /\r?\n/g,
		zc = /^(?:submit|button|image|reset|file)$/i,
		Ac = /^(?:input|select|textarea|keygen)/i;
	o.param = function(e, t) {
		var n, r = [],
			i = function(e, t) {
				t = o.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
			};
		if (void 0 === t && (t = o.ajaxSettings && o.ajaxSettings.traditional), o.isArray(e) || e.jquery && !o.isPlainObject(e)) o.each(e, function() {
			i(this.name, this.value)
		});
		else
			for (n in e) Bc(n, e[n], t, i);
		return r.join("&").replace(wc, "+")
	}, o.fn.extend({
		serialize: function() {
			return o.param(this.serializeArray())
		},
		serializeArray: function() {
			return this.map(function() {
				var e = o.prop(this, "elements");
				return e ? o.makeArray(e) : this
			}).filter(function() {
				var e = this.type;
				return this.name && !o(this).is(":disabled") && Ac.test(this.nodeName) && !zc.test(e) && (this.checked || !T.test(e))
			}).map(function(e, t) {
				var n = o(this).val();
				return null == n ? null : o.isArray(n) ? o.map(n, function(e) {
					return {
						name: t.name,
						value: e.replace(yc, "\r\n")
					}
				}) : {
					name: t.name,
					value: n.replace(yc, "\r\n")
				}
			}).get()
		}
	}), o.ajaxSettings.xhr = function() {
		try {
			return new XMLHttpRequest
		} catch (e) {}
	};
	var Cc = 0,
		Dc = {},
		Ec = {
			0: 200,
			1223: 204
		},
		Fc = o.ajaxSettings.xhr();
	a.ActiveXObject && o(a).on("unload", function() {
		for (var e in Dc) Dc[e]()
	}), l.cors = !!Fc && "withCredentials" in Fc, l.ajax = Fc = !!Fc, o.ajaxTransport(function(e) {
		var t;
		return l.cors || Fc && !e.crossDomain ? {
			send: function(n, r) {
				var i, s = e.xhr(),
					o = ++Cc;
				if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
					for (i in e.xhrFields) s[i] = e.xhrFields[i];
				e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
				for (i in n) s.setRequestHeader(i, n[i]);
				t = function(e) {
					return function() {
						t && (delete Dc[o], t = s.onload = s.onerror = null, "abort" === e ? s.abort() : "error" === e ? r(s.status, s.statusText) : r(Ec[s.status] || s.status, s.statusText, "string" == typeof s.responseText ? {
							text: s.responseText
						} : void 0, s.getAllResponseHeaders()))
					}
				}, s.onload = t(), s.onerror = t("error"), t = Dc[o] = t("abort"), s.send(e.hasContent && e.data || null)
			},
			abort: function() {
				t && t()
			}
		} : void 0
	}), o.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /(?:java|ecma)script/
		},
		converters: {
			"text script": function(e) {
				return o.globalEval(e), e
			}
		}
	}), o.ajaxPrefilter("script", function(e) {
		void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
	}), o.ajaxTransport("script", function(e) {
		if (e.crossDomain) {
			var t, n;
			return {
				send: function(r, i) {
					t = o("<script>").prop({
						async: !0,
						charset: e.scriptCharset,
						src: e.url
					}).on("load error", n = function(e) {
						t.remove(), n = null, e && i("error" === e.type ? 404 : 200, e.type)
					}), m.head.appendChild(t[0])
				},
				abort: function() {
					n && n()
				}
			}
		}
	});
	var Gc = [],
		Hc = /(=)\?(?=&|$)|\?\?/;
	o.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var e = Gc.pop() || o.expando + "_" + cc++;
			return this[e] = !0, e
		}
	}), o.ajaxPrefilter("json jsonp", function(e, t, n) {
		var r, i, s, u = e.jsonp !== !1 && (Hc.test(e.url) ? "url" : "string" == typeof e.data && !(e.contentType || "").indexOf("application/x-www-form-urlencoded") && Hc.test(e.data) && "data");
		return u || "jsonp" === e.dataTypes[0] ? (r = e.jsonpCallback = o.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, u ? e[u] = e[u].replace(Hc, "$1" + r) : e.jsonp !== !1 && (e.url += (dc.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function() {
			return s || o.error(r + " was not called"), s[0]
		}, e.dataTypes[0] = "json", i = a[r], a[r] = function() {
			s = arguments
		}, n.always(function() {
			a[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gc.push(r)), s && o.isFunction(i) && i(s[0]), s = i = void 0
		}), "script") : void 0
	}), o.parseHTML = function(e, t, n) {
		if (!e || "string" != typeof e) return null;
		"boolean" == typeof t && (n = t, t = !1), t = t || m;
		var r = v.exec(e),
			i = !n && [];
		return r ? [t.createElement(r[1])] : (r = o.buildFragment([e], t, i), i && i.length && o(i).remove(), o.merge([], r.childNodes))
	};
	var Ic = o.fn.load;
	o.fn.load = function(e, t, n) {
		if ("string" != typeof e && Ic) return Ic.apply(this, arguments);
		var r, i, s, u = this,
			a = e.indexOf(" ");
		return a >= 0 && (r = e.slice(a), e = e.slice(0, a)), o.isFunction(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), u.length > 0 && o.ajax({
			url: e,
			type: i,
			dataType: "html",
			data: t
		}).done(function(e) {
			s = arguments, u.html(r ? o("<div>").append(o.parseHTML(e)).find(r) : e)
		}).complete(n && function(e, t) {
			u.each(n, s || [e.responseText, t, e])
		}), this
	}, o.expr.filters.animated = function(e) {
		return o.grep(o.timers, function(t) {
			return e === t.elem
		}).length
	};
	var Jc = a.document.documentElement;
	o.offset = {
		setOffset: function(e, t, n) {
			var r, i, s, u, a, f, l, c = o.css(e, "position"),
				h = o(e),
				p = {};
			"static" === c && (e.style.position = "relative"), a = h.offset(), s = o.css(e, "top"), f = o.css(e, "left"), l = ("absolute" === c || "fixed" === c) && (s + f).indexOf("auto") > -1, l ? (r = h.position(), u = r.top, i = r.left) : (u = parseFloat(s) || 0, i = parseFloat(f) || 0), o.isFunction(t) && (t = t.call(e, n, a)), null != t.top && (p.top = t.top - a.top + u), null != t.left && (p.left = t.left - a.left + i), "using" in t ? t.using.call(e, p) : h.css(p)
		}
	}, o.fn.extend({
		offset: function(e) {
			if (arguments.length) return void 0 === e ? this : this.each(function(t) {
				o.offset.setOffset(this, e, t)
			});
			var t, n, r = this[0],
				i = {
					top: 0,
					left: 0
				},
				s = r && r.ownerDocument;
			if (s) return t = s.documentElement, o.contains(t, r) ? (typeof r.getBoundingClientRect !== U && (i = r.getBoundingClientRect()), n = Kc(s), {
				top: i.top + n.pageYOffset - t.clientTop,
				left: i.left + n.pageXOffset - t.clientLeft
			}) : i
		},
		position: function() {
			if (this[0]) {
				var e, t, n = this[0],
					r = {
						top: 0,
						left: 0
					};
				return "fixed" === o.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), o.nodeName(e[0], "html") || (r = e.offset()), r.top += o.css(e[0], "borderTopWidth", !0), r.left += o.css(e[0], "borderLeftWidth", !0)), {
					top: t.top - r.top - o.css(n, "marginTop", !0),
					left: t.left - r.left - o.css(n, "marginLeft", !0)
				}
			}
		},
		offsetParent: function() {
			return this.map(function() {
				var e = this.offsetParent || Jc;
				while (e && !o.nodeName(e, "html") && "static" === o.css(e, "position")) e = e.offsetParent;
				return e || Jc
			})
		}
	}), o.each({
		scrollLeft: "pageXOffset",
		scrollTop: "pageYOffset"
	}, function(e, t) {
		var n = "pageYOffset" === t;
		o.fn[e] = function(r) {
			return J(this, function(e, r, i) {
				var s = Kc(e);
				return void 0 === i ? s ? s[t] : e[r] : void(s ? s.scrollTo(n ? a.pageXOffset : i, n ? i : a.pageYOffset) : e[r] = i)
			}, e, r, arguments.length, null)
		}
	}), o.each(["top", "left"], function(e, t) {
		o.cssHooks[t] = yb(l.pixelPosition, function(e, n) {
			return n ? (n = xb(e, t), vb.test(n) ? o(e).position()[t] + "px" : n) : void 0
		})
	}), o.each({
		Height: "height",
		Width: "width"
	}, function(e, t) {
		o.each({
			padding: "inner" + e,
			content: t,
			"": "outer" + e
		}, function(n, r) {
			o.fn[r] = function(r, i) {
				var s = arguments.length && (n || "boolean" != typeof r),
					u = n || (r === !0 || i === !0 ? "margin" : "border");
				return J(this, function(t, n, r) {
					var i;
					return o.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (i = t.documentElement, Math.max(t.body["scroll" + e], i["scroll" + e], t.body["offset" + e], i["offset" + e], i["client" + e])) : void 0 === r ? o.css(t, n, u) : o.style(t, n, r, u)
				}, t, s ? r : void 0, s, null)
			}
		})
	}), o.fn.size = function() {
		return this.length
	}, o.fn.andSelf = o.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
		return o
	});
	var Lc = a.jQuery,
		Mc = a.$;
	return o.noConflict = function(e) {
		return a.$ === o && (a.$ = Mc), e && a.jQuery === o && (a.jQuery = Lc), o
	}, typeof b === U && (a.jQuery = a.$ = o), o
}), define("app/pubsub", ["jquery"], function(e) {
	var t = e({});
	e.subscribe = function() {
		t.on.apply(t, arguments)
	}, e.unsubscribe = function() {
		t.off.apply(t, arguments)
	}, e.publish = function() {
		t.trigger.apply(t, arguments)
	}
}), define("app/sfx", ["AudioContextMonkeyPatch", "app/pubsub"], function() {
	var e = function(e, t, n, r) {
			this.context = e, this.urlList = t, this.onload = n, this.onupdate = r, this.bufferList = new Array, this.loadCount = 0, this.loadBuffer = function(e, t) {
				var n = new XMLHttpRequest;
				n.open("GET", e, !0), n.responseType = "arraybuffer";
				var r = this;
				n.onload = function() {
					r.context.decodeAudioData(n.response, function(n) {
						if (!n) {
							alert("error decoding file data: " + e);
							return
						}
						r.bufferList[t] = n, r.onupdate(r.loadCount + 1, r.urlList.length), ++r.loadCount == r.urlList.length && r.onload(r.bufferList)
					}, function(e) {
						console.error("decodeAudioData error", e)
					})
				}, n.onerror = function() {
					alert("BufferLoader: XHR error")
				}, n.send()
			}, this.load = function() {
				for (var e = 0; e < this.urlList.length; ++e) this.loadBuffer(this.urlList[e], e)
			}
		},
		t = function() {
			function s(e) {
				for (var n = 0; n < e.length; n++) t.push(e[n]);
				$.publish("trackready")
			}

			function o(e, t) {
				$(".pause-load span").html(e + " / " + t)
			}

			function a(e) {
				var n = e.index;
				return function(e) {
					if (t[n]) {
						var r = i.createBufferSource();
						r.buffer = t[n];
						var s = i.createPanner();
						s.coneInnerAngle = 0, s.coneOuterAngle = 180, s.coneOuterGain = .1, s.setOrientation(0, 0, -1);
						var o = i.createGain(),
							a = i.createBiquadFilter(),
							f = i.createBiquadFilter(),
							l = i.createConvolver(),
							c = i.createGain();
						a.type = 0, a.frequency.value = 22e3, f.type = 0, f.frequency.value = 22e3, l.buffer = t[1], r.connect(o), o.connect(s), s.connect(a), a.connect(f), f.connect(i.destination), f.connect(l), l.connect(c), c.connect(i.destination);
						var h = i.createAnalyser();
						h.fftSize = 32;
						var p = i.createBufferSource();
						return p.buffer = t[2], p.connect(h), {
							source: r,
							beatSource: p,
							gain: o,
							panner: s,
							lowPassFilter: a,
							lowPassFilterMenu: f,
							convolver: l,
							revbVolume: c,
							analyser: h,
							soundGain: u
						}
					}
				}
			}

			function c(e) {
				var n = e.index;
				return function() {
					if (!t[n]) return;
					var e = i.createBufferSource();
					e.buffer = t[n];
					var r = i.createGain(),
						s = i.createGain();
					return s.gain.value = audio.gain.gain.value * .2, l.gain.value = .4 * s.gain.value, e.connect(r), r.connect(f), r.connect(s), s.connect(i.destination), e.start(0),
						function() {
							r.gain.setValueAtTime(1, i.currentTime), r.gain.linearRampToValueAtTime(0, i.currentTime + .3), e.stop(i.currentTime + .3), setTimeout(function() {
								r.disconnect(0)
							}, 300)
						}
				}
			}

			function h(e) {
				var n = e.index,
					r = e.gain;
				return function() {
					if (!t[n]) return;
					var e = i.createBufferSource();
					e.buffer = t[n];
					var s = i.createGain();
					s.gain.value = r, u.gain.value = audio.gain.gain.value, e.connect(s), s.connect(u), e.start(0)
				}
			}
			var t = [],
				n, r = this,
				i = new(window.webkitAudioContext || window.AudioContext);
			n = new e(i, ["/track.mp3", "/room.mp3", "/beat.mp3", "/1.mp3", "/2.mp3", "/3.mp3", "/4.mp3", "/5.mp3", "/6.mp3", "/7.mp3", "/squeak.mp3", "/ambient.mp3", "/intro.mp3"], s, o), n.load();
			var u = i.createGain();
			u.connect(i.destination);
			var f = i.createConvolver(),
				l = i.createGain();
			f.connect(l), l.connect(i.destination), $.subscribe("trackready", function() {
				f.buffer = t[1]
			}), this.play = a({
				index: 0
			}), this.keyS = c({
				index: 3,
				freq: 60
			}), this.keyD = c({
				index: 4,
				freq: 61
			}), this.keyF = c({
				index: 5,
				freq: 66
			}), this.keyG = c({
				index: 6,
				freq: 68
			}), this.keyH = c({
				index: 7,
				freq: 72
			}), this.keyJ = c({
				index: 8,
				freq: 73
			}), this.keyK = c({
				index: 9,
				freq: 78
			}), this.squeak = h({
				index: 10,
				gain: .1
			}), this.ambience = h({
				index: 11,
				gain: .1
			}), this.looney = h({
				index: 12,
				gain: 1
			})
		};
	return sfx = new t, sfx
});
var THREE = {
	REVISION: "66"
};
self.console = self.console || {
		info: function() {},
		log: function() {},
		debug: function() {},
		warn: function() {},
		error: function() {}
	},
	function() {
		for (var e = 0, t = ["ms", "moz", "webkit", "o"], n = 0; n < t.length && !self.requestAnimationFrame; ++n) self.requestAnimationFrame = self[t[n] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[t[n] + "CancelAnimationFrame"] || self[t[n] + "CancelRequestAnimationFrame"];
		void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function(t) {
			var n = Date.now(),
				r = Math.max(0, 16 - (n - e)),
				i = self.setTimeout(function() {
					t(n + r)
				}, r);
			return e = n + r, i
		}), void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function(e) {
			self.clearTimeout(e)
		})
	}(), THREE.CullFaceNone = 0, THREE.CullFaceBack = 1, THREE.CullFaceFront = 2, THREE.CullFaceFrontBack = 3, THREE.FrontFaceDirectionCW = 0, THREE.FrontFaceDirectionCCW = 1, THREE.BasicShadowMap = 0, THREE.PCFShadowMap = 1, THREE.PCFSoftShadowMap = 2, THREE.FrontSide = 0, THREE.BackSide = 1, THREE.DoubleSide = 2, THREE.NoShading = 0, THREE.FlatShading = 1, THREE.SmoothShading = 2, THREE.NoColors = 0, THREE.FaceColors = 1, THREE.VertexColors = 2, THREE.NoBlending = 0, THREE.NormalBlending = 1, THREE.AdditiveBlending = 2, THREE.SubtractiveBlending = 3, THREE.MultiplyBlending = 4, THREE.CustomBlending = 5, THREE.AddEquation = 100, THREE.SubtractEquation = 101, THREE.ReverseSubtractEquation = 102, THREE.ZeroFactor = 200, THREE.OneFactor = 201, THREE.SrcColorFactor = 202, THREE.OneMinusSrcColorFactor = 203, THREE.SrcAlphaFactor = 204, THREE.OneMinusSrcAlphaFactor = 205, THREE.DstAlphaFactor = 206, THREE.OneMinusDstAlphaFactor = 207, THREE.DstColorFactor = 208, THREE.OneMinusDstColorFactor = 209, THREE.SrcAlphaSaturateFactor = 210, THREE.MultiplyOperation = 0, THREE.MixOperation = 1, THREE.AddOperation = 2, THREE.UVMapping = function() {}, THREE.CubeReflectionMapping = function() {}, THREE.CubeRefractionMapping = function() {}, THREE.SphericalReflectionMapping = function() {}, THREE.SphericalRefractionMapping = function() {}, THREE.RepeatWrapping = 1e3, THREE.ClampToEdgeWrapping = 1001, THREE.MirroredRepeatWrapping = 1002, THREE.NearestFilter = 1003, THREE.NearestMipMapNearestFilter = 1004, THREE.NearestMipMapLinearFilter = 1005, THREE.LinearFilter = 1006, THREE.LinearMipMapNearestFilter = 1007, THREE.LinearMipMapLinearFilter = 1008, THREE.UnsignedByteType = 1009, THREE.ByteType = 1010, THREE.ShortType = 1011, THREE.UnsignedShortType = 1012, THREE.IntType = 1013, THREE.UnsignedIntType = 1014, THREE.FloatType = 1015, THREE.UnsignedShort4444Type = 1016, THREE.UnsignedShort5551Type = 1017, THREE.UnsignedShort565Type = 1018, THREE.AlphaFormat = 1019, THREE.RGBFormat = 1020, THREE.RGBAFormat = 1021, THREE.LuminanceFormat = 1022, THREE.LuminanceAlphaFormat = 1023, THREE.RGB_S3TC_DXT1_Format = 2001, THREE.RGBA_S3TC_DXT1_Format = 2002, THREE.RGBA_S3TC_DXT3_Format = 2003, THREE.RGBA_S3TC_DXT5_Format = 2004, THREE.Color = function(e) {
		return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(e)
	}, THREE.Color.prototype = {
		constructor: THREE.Color,
		r: 1,
		g: 1,
		b: 1,
		set: function(e) {
			return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
		},
		setHex: function(e) {
			return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this
		},
		setRGB: function(e, t, n) {
			return this.r = e, this.g = t, this.b = n, this
		},
		setHSL: function(e, t, n) {
			if (0 === t) this.r = this.g = this.b = n;
			else {
				var r = function(e, t, n) {
					return 0 > n && (n += 1), 1 < n && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : .5 > n ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
				};
				t = .5 >= n ? n * (1 + t) : n + t - n * t, n = 2 * n - t, this.r = r(n, t, e + 1 / 3), this.g = r(n, t, e), this.b = r(n, t, e - 1 / 3)
			}
			return this
		},
		setStyle: function(e) {
			if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(e)) return e = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(e), this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, this;
			if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(e)) return e = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(e), this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, this;
			if (/^\#([0-9a-f]{6})$/i.test(e)) return e = /^\#([0-9a-f]{6})$/i.exec(e), this.setHex(parseInt(e[1], 16)), this;
			if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(e)) return e = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(e), this.setHex(parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3], 16)), this;
			if (/^(\w+)$/i.test(e)) return this.setHex(THREE.ColorKeywords[e]), this
		},
		copy: function(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		},
		copyGammaToLinear: function(e) {
			return this.r = e.r * e.r, this.g = e.g * e.g, this.b = e.b * e.b, this
		},
		copyLinearToGamma: function(e) {
			return this.r = Math.sqrt(e.r), this.g = Math.sqrt(e.g), this.b = Math.sqrt(e.b), this
		},
		convertGammaToLinear: function() {
			var e = this.r,
				t = this.g,
				n = this.b;
			return this.r = e * e, this.g = t * t, this.b = n * n, this
		},
		convertLinearToGamma: function() {
			return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
		},
		getHex: function() {
			return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
		},
		getHexString: function() {
			return ("000000" + this.getHex().toString(16)).slice(-6)
		},
		getHSL: function(e) {
			e = e || {
				h: 0,
				s: 0,
				l: 0
			};
			var t = this.r,
				n = this.g,
				r = this.b,
				i = Math.max(t, n, r),
				s = Math.min(t, n, r),
				o, u = (s + i) / 2;
			if (s === i) s = o = 0;
			else {
				var a = i - s,
					s = .5 >= u ? a / (i + s) : a / (2 - i - s);
				switch (i) {
					case t:
						o = (n - r) / a + (n < r ? 6 : 0);
						break;
					case n:
						o = (r - t) / a + 2;
						break;
					case r:
						o = (t - n) / a + 4
				}
				o /= 6
			}
			return e.h = o, e.s = s, e.l = u, e
		},
		getStyle: function() {
			return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
		},
		offsetHSL: function(e, t, n) {
			var r = this.getHSL();
			return r.h += e, r.s += t, r.l += n, this.setHSL(r.h, r.s, r.l), this
		},
		add: function(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this
		},
		addColors: function(e, t) {
			return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
		},
		addScalar: function(e) {
			return this.r += e, this.g += e, this.b += e, this
		},
		multiply: function(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
		},
		multiplyScalar: function(e) {
			return this.r *= e, this.g *= e, this.b *= e, this
		},
		lerp: function(e, t) {
			return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
		},
		equals: function(e) {
			return e.r === this.r && e.g === this.g && e.b === this.b
		},
		fromArray: function(e) {
			return this.r = e[0], this.g = e[1], this.b = e[2], this
		},
		toArray: function() {
			return [this.r, this.g, this.b]
		},
		clone: function() {
			return (new THREE.Color).setRGB(this.r, this.g, this.b)
		}
	}, THREE.ColorKeywords = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	}, THREE.Quaternion = function(e, t, n, r) {
		this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
	}, THREE.Quaternion.prototype = {
		constructor: THREE.Quaternion,
		_x: 0,
		_y: 0,
		_z: 0,
		_w: 0,
		_euler: void 0,
		_updateEuler: function(e) {
			void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1)
		},
		get x() {
			return this._x
		},
		set x(e) {
			this._x = e, this._updateEuler()
		},
		get y() {
			return this._y
		},
		set y(e) {
			this._y = e, this._updateEuler()
		},
		get z() {
			return this._z
		},
		set z(e) {
			this._z = e, this._updateEuler()
		},
		get w() {
			return this._w
		},
		set w(e) {
			this._w = e, this._updateEuler()
		},
		set: function(e, t, n, r) {
			return this._x = e, this._y = t, this._z = n, this._w = r, this._updateEuler(), this
		},
		copy: function(e) {
			return this._x = e._x, this._y = e._y, this._z = e._z, this._w = e._w, this._updateEuler(), this
		},
		setFromEuler: function(e, t) {
			if (0 == e instanceof THREE.Euler) throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
			var n = Math.cos(e._x / 2),
				r = Math.cos(e._y / 2),
				i = Math.cos(e._z / 2),
				s = Math.sin(e._x / 2),
				o = Math.sin(e._y / 2),
				u = Math.sin(e._z / 2);
			return "XYZ" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "YXZ" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "ZXY" === e.order ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "ZYX" === e.order ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "YZX" === e.order ? (this._x = s * r * i + n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i - s * o * u) : "XZY" === e.order && (this._x = s * r * i - n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i + s * o * u), !1 !== t && this._updateEuler(), this
		},
		setFromAxisAngle: function(e, t) {
			var n = t / 2,
				r = Math.sin(n);
			return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._updateEuler(), this
		},
		setFromRotationMatrix: function(e) {
			var t = e.elements,
				n = t[0];
			e = t[4];
			var r = t[8],
				i = t[1],
				s = t[5],
				o = t[9],
				u = t[2],
				a = t[6],
				t = t[10],
				f = n + s + t;
			return 0 < f ? (n = .5 / Math.sqrt(f + 1), this._w = .25 / n, this._x = (a - o) * n, this._y = (r - u) * n, this._z = (i - e) * n) : n > s && n > t ? (n = 2 * Math.sqrt(1 + n - s - t), this._w = (a - o) / n, this._x = .25 * n, this._y = (e + i) / n, this._z = (r + u) / n) : s > t ? (n = 2 * Math.sqrt(1 + s - n - t), this._w = (r - u) / n, this._x = (e + i) / n, this._y = .25 * n, this._z = (o + a) / n) : (n = 2 * Math.sqrt(1 + t - n - s), this._w = (i - e) / n, this._x = (r + u) / n, this._y = (o + a) / n, this._z = .25 * n), this._updateEuler(), this
		},
		inverse: function() {
			return this.conjugate().normalize(), this
		},
		conjugate: function() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this._updateEuler(), this
		},
		lengthSq: function() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		},
		length: function() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
		},
		normalize: function() {
			var e = this.length();
			return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
		},
		multiplyQuaternions: function(e, t) {
			var n = e._x,
				r = e._y,
				i = e._z,
				s = e._w,
				o = t._x,
				u = t._y,
				a = t._z,
				f = t._w;
			return this._x = n * f + s * o + r * a - i * u, this._y = r * f + s * u + i * o - n * a, this._z = i * f + s * a + n * u - r * o, this._w = s * f - n * o - r * u - i * a, this._updateEuler(), this
		},
		multiplyVector3: function(e) {
			return console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
		},
		slerp: function(e, t) {
			var n = this._x,
				r = this._y,
				i = this._z,
				s = this._w,
				o = s * e._w + n * e._x + r * e._y + i * e._z;
			0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e);
			if (1 <= o) return this._w = s, this._x = n, this._y = r, this._z = i, this;
			var u = Math.acos(o),
				a = Math.sqrt(1 - o * o);
			return .001 > Math.abs(a) ? (this._w = .5 * (s + this._w), this._x = .5 * (n + this._x), this._y = .5 * (r + this._y), this._z = .5 * (i + this._z), this) : (o = Math.sin((1 - t) * u) / a, u = Math.sin(t * u) / a, this._w = s * o + this._w * u, this._x = n * o + this._x * u, this._y = r * o + this._y * u, this._z = i * o + this._z * u, this._updateEuler(), this)
		},
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
		},
		fromArray: function(e) {
			return this._x = e[0], this._y = e[1], this._z = e[2], this._w = e[3], this._updateEuler(), this
		},
		toArray: function() {
			return [this._x, this._y, this._z, this._w]
		},
		clone: function() {
			return new THREE.Quaternion(this._x, this._y, this._z, this._w)
		}
	}, THREE.Quaternion.slerp = function(e, t, n, r) {
		return n.copy(e).slerp(t, r)
	}, THREE.Vector2 = function(e, t) {
		this.x = e || 0, this.y = t || 0
	}, THREE.Vector2.prototype = {
		constructor: THREE.Vector2,
		set: function(e, t) {
			return this.x = e, this.y = t, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e) : this.y = this.x = 0, this
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector2, t = new THREE.Vector2), e.set(n, n), t.set(r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
		},
		negate: function() {
			return this.multiplyScalar(-1)
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x;
			return e = this.y - e.y, t * t + e * e
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this
		},
		toArray: function() {
			return [this.x, this.y]
		},
		clone: function() {
			return new THREE.Vector2(this.x, this.y)
		}
	}, THREE.Vector3 = function(e, t, n) {
		this.x = e || 0, this.y = t || 0, this.z = n || 0
	}, THREE.Vector3.prototype = {
		constructor: THREE.Vector3,
		set: function(e, t, n) {
			return this.x = e, this.y = t, this.z = n, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		},
		multiplyVectors: function(e, t) {
			return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
		},
		applyEuler: function() {
			var e;
			return function(t) {
				return 0 == t instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code."), void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
			}
		}(),
		applyAxisAngle: function() {
			var e;
			return function(t, n) {
				return void 0 === e && (e = new THREE.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, n)), this
			}
		}(),
		applyMatrix3: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[3] * n + e[6] * r, this.y = e[1] * t + e[4] * n + e[7] * r, this.z = e[2] * t + e[5] * n + e[8] * r, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12], this.y = e[1] * t + e[5] * n + e[9] * r + e[13], this.z = e[2] * t + e[6] * n + e[10] * r + e[14], this
		},
		applyProjection: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			e = e.elements;
			var i = 1 / (e[3] * t + e[7] * n + e[11] * r + e[15]);
			return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i, this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i, this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i, this
		},
		applyQuaternion: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z,
				i = e.x,
				s = e.y,
				o = e.z;
			e = e.w;
			var u = e * t + s * r - o * n,
				a = e * n + o * t - i * r,
				f = e * r + i * n - s * t,
				t = -i * t - s * n - o * r;
			return this.x = u * e + t * -i + a * -o - f * -s, this.y = a * e + t * -s + f * -i - u * -o, this.z = f * e + t * -o + u * -s - a * -i, this
		},
		transformDirection: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r, this.y = e[1] * t + e[5] * n + e[9] * r, this.z = e[2] * t + e[6] * n + e[10] * r, this.normalize(), this
		},
		divide: function(e) {
			return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0, this
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector3, t = new THREE.Vector3), e.set(n, n, n), t.set(r, r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
		},
		negate: function() {
			return this.multiplyScalar(-1)
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		},
		lengthManhattan: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
		},
		cross: function(e, t) {
			if (void 0 !== t) return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
			var n = this.x,
				r = this.y,
				i = this.z;
			return this.x = r * e.z - i * e.y, this.y = i * e.x - n * e.z, this.z = n * e.y - r * e.x, this
		},
		crossVectors: function(e, t) {
			var n = e.x,
				r = e.y,
				i = e.z,
				s = t.x,
				o = t.y,
				u = t.z;
			return this.x = r * u - i * o, this.y = i * s - n * u, this.z = n * o - r * s, this
		},
		projectOnVector: function() {
			var e, t;
			return function(n) {
				return void 0 === e && (e = new THREE.Vector3), e.copy(n).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
			}
		}(),
		projectOnPlane: function() {
			var e;
			return function(t) {
				return void 0 === e && (e = new THREE.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
			}
		}(),
		reflect: function() {
			var e;
			return function(t) {
				return void 0 === e && (e = new THREE.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
			}
		}(),
		angleTo: function(e) {
			return e = this.dot(e) / (this.length() * e.length()), Math.acos(THREE.Math.clamp(e, -1, 1))
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x,
				n = this.y - e.y;
			return e = this.z - e.z, t * t + n * n + e * e
		},
		setEulerFromRotationMatrix: function(e, t) {
			console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")
		},
		setEulerFromQuaternion: function(e, t) {
			console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")
		},
		getPositionFromMatrix: function(e) {
			return console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code."), this.setFromMatrixPosition(e)
		},
		getScaleFromMatrix: function(e) {
			return console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code."), this.setFromMatrixScale(e)
		},
		getColumnFromMatrix: function(e, t) {
			return console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code."), this.setFromMatrixColumn(e, t)
		},
		setFromMatrixPosition: function(e) {
			return this.x = e.elements[12], this.y = e.elements[13], this.z = e.elements[14], this
		},
		setFromMatrixScale: function(e) {
			var t = this.set(e.elements[0], e.elements[1], e.elements[2]).length(),
				n = this.set(e.elements[4], e.elements[5], e.elements[6]).length();
			return e = this.set(e.elements[8], e.elements[9], e.elements[10]).length(), this.x = t, this.y = n, this.z = e, this
		},
		setFromMatrixColumn: function(e, t) {
			var n = 4 * e,
				r = t.elements;
			return this.x = r[n], this.y = r[n + 1], this.z = r[n + 2], this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this.z = e[2], this
		},
		toArray: function() {
			return [this.x, this.y, this.z]
		},
		clone: function() {
			return new THREE.Vector3(this.x, this.y, this.z)
		}
	}, THREE.Vector4 = function(e, t, n, r) {
		this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
	}, THREE.Vector4.prototype = {
		constructor: THREE.Vector4,
		set: function(e, t, n, r) {
			return this.x = e, this.y = t, this.z = n, this.w = r, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setW: function(e) {
			return this.w = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				case 3:
					this.w = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this.w += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				n = this.y,
				r = this.z,
				i = this.w;
			return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i, this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i, this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i, this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i, this
		},
		divideScalar: function(e) {
			return 0 !== e ? (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.z = this.y = this.x = 0, this.w = 1), this
		},
		setAxisAngleFromQuaternion: function(e) {
			this.w = 2 * Math.acos(e.w);
			var t = Math.sqrt(1 - e.w * e.w);
			return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
		},
		setAxisAngleFromRotationMatrix: function(e) {
			var t, n, r;
			e = e.elements;
			var i = e[0];
			r = e[4];
			var s = e[8],
				o = e[1],
				u = e[5],
				a = e[9];
			n = e[2], t = e[6];
			var f = e[10];
			return .01 > Math.abs(r - o) && .01 > Math.abs(s - n) && .01 > Math.abs(a - t) ? .1 > Math.abs(r + o) && .1 > Math.abs(s + n) && .1 > Math.abs(a + t) && .1 > Math.abs(i + u + f - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, i = (i + 1) / 2, u = (u + 1) / 2, f = (f + 1) / 2, r = (r + o) / 4, s = (s + n) / 4, a = (a + t) / 4, i > u && i > f ? .01 > i ? (t = 0, r = n = .707106781) : (t = Math.sqrt(i), n = r / t, r = s / t) : u > f ? .01 > u ? (t = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(u), t = r / n, r = a / n) : .01 > f ? (n = t = .707106781, r = 0) : (r = Math.sqrt(f), t = s / r, n = a / r), this.set(t, n, r, e), this) : (e = Math.sqrt((t - a) * (t - a) + (s - n) * (s - n) + (o - r) * (o - r)), .001 > Math.abs(e) && (e = 1), this.x = (t - a) / e, this.y = (s - n) / e, this.z = (o - r) / e, this.w = Math.acos((i + u + f - 1) / 2), this)
		},
		min: function(e) {
			return this.x > e.x && (this.x = e.x), this.y > e.y && (this.y = e.y), this.z > e.z && (this.z = e.z), this.w > e.w && (this.w = e.w), this
		},
		max: function(e) {
			return this.x < e.x && (this.x = e.x), this.y < e.y && (this.y = e.y), this.z < e.z && (this.z = e.z), this.w < e.w && (this.w = e.w), this
		},
		clamp: function(e, t) {
			return this.x < e.x ? this.x = e.x : this.x > t.x && (this.x = t.x), this.y < e.y ? this.y = e.y : this.y > t.y && (this.y = t.y), this.z < e.z ? this.z = e.z : this.z > t.z && (this.z = t.z), this.w < e.w ? this.w = e.w : this.w > t.w && (this.w = t.w), this
		},
		clampScalar: function() {
			var e, t;
			return function(n, r) {
				return void 0 === e && (e = new THREE.Vector4, t = new THREE.Vector4), e.set(n, n, n, n), t.set(r, r, r, r), this.clamp(e, t)
			}
		}(),
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
		},
		negate: function() {
			return this.multiplyScalar(-1)
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		},
		lengthManhattan: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
		},
		normalize: function() {
			return this.divideScalar(this.length())
		},
		setLength: function(e) {
			var t = this.length();
			return 0 !== t && e !== t && this.multiplyScalar(e / t), this
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
		},
		fromArray: function(e) {
			return this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3], this
		},
		toArray: function() {
			return [this.x, this.y, this.z, this.w]
		},
		clone: function() {
			return new THREE.Vector4(this.x, this.y, this.z, this.w)
		}
	}, THREE.Euler = function(e, t, n, r) {
		this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || THREE.Euler.DefaultOrder
	}, THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), THREE.Euler.DefaultOrder = "XYZ", THREE.Euler.prototype = {
		constructor: THREE.Euler,
		_x: 0,
		_y: 0,
		_z: 0,
		_order: THREE.Euler.DefaultOrder,
		_quaternion: void 0,
		_updateQuaternion: function() {
			void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1)
		},
		get x() {
			return this._x
		},
		set x(e) {
			this._x = e, this._updateQuaternion()
		},
		get y() {
			return this._y
		},
		set y(e) {
			this._y = e, this._updateQuaternion()
		},
		get z() {
			return this._z
		},
		set z(e) {
			this._z = e, this._updateQuaternion()
		},
		get order() {
			return this._order
		},
		set order(e) {
			this._order = e, this._updateQuaternion()
		},
		set: function(e, t, n, r) {
			return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._updateQuaternion(), this
		},
		copy: function(e) {
			return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._updateQuaternion(), this
		},
		setFromRotationMatrix: function(e, t) {
			function n(e) {
				return Math.min(Math.max(e, -1), 1)
			}
			var r = e.elements,
				i = r[0],
				s = r[4],
				o = r[8],
				u = r[1],
				a = r[5],
				f = r[9],
				l = r[2],
				c = r[6],
				r = r[10];
			return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(n(o)), .99999 > Math.abs(o) ? (this._x = Math.atan2(-f, r), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(c, a), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(f)), .99999 > Math.abs(f) ? (this._y = Math.atan2(o, r), this._z = Math.atan2(u, a)) : (this._y = Math.atan2(-l, i), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(c)), .99999 > Math.abs(c) ? (this._y = Math.atan2(-l, r), this._z = Math.atan2(-s, a)) : (this._y = 0, this._z = Math.atan2(u, i))) : "ZYX" === t ? (this._y = Math.asin(-n(l)), .99999 > Math.abs(l) ? (this._x = Math.atan2(c, r), this._z = Math.atan2(u, i)) : (this._x = 0, this._z = Math.atan2(-s, a))) : "YZX" === t ? (this._z = Math.asin(n(u)), .99999 > Math.abs(u) ? (this._x = Math.atan2(-f, a), this._y = Math.atan2(-l, i)) : (this._x = 0, this._y = Math.atan2(o, r))) : "XZY" === t ? (this._z = Math.asin(-n(s)), .99999 > Math.abs(s) ? (this._x = Math.atan2(c, a), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-f, r), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + t), this._order = t, this._updateQuaternion(), this
		},
		setFromQuaternion: function(e, t, n) {
			function r(e) {
				return Math.min(Math.max(e, -1), 1)
			}
			var i = e.x * e.x,
				s = e.y * e.y,
				o = e.z * e.z,
				u = e.w * e.w;
			return t = t || this._order, "XYZ" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.y * e.z), u - i - s + o), this._y = Math.asin(r(2 * (e.x * e.z + e.y * e.w))), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u + i - s - o)) : "YXZ" === t ? (this._x = Math.asin(r(2 * (e.x * e.w - e.y * e.z))), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u - i - s + o), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u - i + s - o)) : "ZXY" === t ? (this._x = Math.asin(r(2 * (e.x * e.w + e.y * e.z))), this._y = Math.atan2(2 * (e.y * e.w - e.z * e.x), u - i - s + o), this._z = Math.atan2(2 * (e.z * e.w - e.x * e.y), u - i + s - o)) : "ZYX" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.z * e.y), u - i - s + o), this._y = Math.asin(r(2 * (e.y * e.w - e.x * e.z))), this._z = Math.atan2(2 * (e.x * e.y + e.z * e.w), u + i - s - o)) : "YZX" === t ? (this._x = Math.atan2(2 * (e.x * e.w - e.z * e.y), u - i + s - o), this._y = Math.atan2(2 * (e.y * e.w - e.x * e.z), u + i - s - o), this._z = Math.asin(r(2 * (e.x * e.y + e.z * e.w)))) : "XZY" === t ? (this._x = Math.atan2(2 * (e.x * e.w + e.y * e.z), u - i + s - o), this._y = Math.atan2(2 * (e.x * e.z + e.y * e.w), u + i - s - o), this._z = Math.asin(r(2 * (e.z * e.w - e.x * e.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + t), this._order = t, !1 !== n && this._updateQuaternion(), this
		},
		reorder: function() {
			var e = new THREE.Quaternion;
			return function(t) {
				e.setFromEuler(this), this.setFromQuaternion(e, t)
			}
		}(),
		fromArray: function(e) {
			return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._updateQuaternion(), this
		},
		toArray: function() {
			return [this._x, this._y, this._z, this._order]
		},
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
		},
		clone: function() {
			return new THREE.Euler(this._x, this._y, this._z, this._order)
		}
	}, THREE.Line3 = function(e, t) {
		this.start = void 0 !== e ? e : new THREE.Vector3, this.end = void 0 !== t ? t : new THREE.Vector3
	}, THREE.Line3.prototype = {
		constructor: THREE.Line3,
		set: function(e, t) {
			return this.start.copy(e), this.end.copy(t), this
		},
		copy: function(e) {
			return this.start.copy(e.start), this.end.copy(e.end), this
		},
		center: function(e) {
			return (e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
		},
		delta: function(e) {
			return (e || new THREE.Vector3).subVectors(this.end, this.start)
		},
		distanceSq: function() {
			return this.start.distanceToSquared(this.end)
		},
		distance: function() {
			return this.start.distanceTo(this.end)
		},
		at: function(e, t) {
			var n = t || new THREE.Vector3;
			return this.delta(n).multiplyScalar(e).add(this.start)
		},
		closestPointToPointParameter: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n, r) {
				e.subVectors(n, this.start), t.subVectors(this.end, this.start);
				var i = t.dot(t),
					i = t.dot(e) / i;
				return r && (i = THREE.Math.clamp(i, 0, 1)), i
			}
		}(),
		closestPointToPoint: function(e, t, n) {
			return e = this.closestPointToPointParameter(e, t), n = n || new THREE.Vector3, this.delta(n).multiplyScalar(e).add(this.start)
		},
		applyMatrix4: function(e) {
			return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
		},
		equals: function(e) {
			return e.start.equals(this.start) && e.end.equals(this.end)
		},
		clone: function() {
			return (new THREE.Line3).copy(this)
		}
	}, THREE.Box2 = function(e, t) {
		this.min = void 0 !== e ? e : new THREE.Vector2(Infinity, Infinity), this.max = void 0 !== t ? t : new THREE.Vector2(-Infinity, -Infinity)
	}, THREE.Box2.prototype = {
		constructor: THREE.Box2,
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		setFromPoints: function(e) {
			if (0 < e.length) {
				var t = e[0];
				this.min.copy(t), this.max.copy(t);
				for (var n = 1, r = e.length; n < r; n++) t = e[n], t.x < this.min.x ? this.min.x = t.x : t.x > this.max.x && (this.max.x = t.x), t.y < this.min.y ? this.min.y = t.y : t.y > this.max.y && (this.max.y = t.y)
			} else this.makeEmpty();
			return this
		},
		setFromCenterAndSize: function() {
			var e = new THREE.Vector2;
			return function(t, n) {
				var r = e.copy(n).multiplyScalar(.5);
				return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
			}
		}(),
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -Infinity, this
		},
		empty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y
		},
		center: function(e) {
			return (e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
		},
		size: function(e) {
			return (e || new THREE.Vector2).subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		containsPoint: function(e) {
			return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1
		},
		getParameter: function(e, t) {
			return (t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
		},
		isIntersectionBox: function(e) {
			return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
		},
		clampPoint: function(e, t) {
			return (t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector2;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		},
		clone: function() {
			return (new THREE.Box2).copy(this)
		}
	}, THREE.Box3 = function(e, t) {
		this.min = void 0 !== e ? e : new THREE.Vector3(Infinity, Infinity, Infinity), this.max = void 0 !== t ? t : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
	}, THREE.Box3.prototype = {
		constructor: THREE.Box3,
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		addPoint: function(e) {
			e.x < this.min.x ? this.min.x = e.x : e.x > this.max.x && (this.max.x = e.x), e.y < this.min.y ? this.min.y = e.y : e.y > this.max.y && (this.max.y = e.y), e.z < this.min.z ? this.min.z = e.z : e.z > this.max.z && (this.max.z = e.z)
		},
		setFromPoints: function(e) {
			if (0 < e.length) {
				var t = e[0];
				this.min.copy(t), this.max.copy(t);
				for (var t = 1, n = e.length; t < n; t++) this.addPoint(e[t])
			} else this.makeEmpty();
			return this
		},
		setFromCenterAndSize: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				var r = e.copy(n).multiplyScalar(.5);
				return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
			}
		}(),
		setFromObject: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = this;
				return t.updateMatrixWorld(!0), this.makeEmpty(), t.traverse(function(t) {
					if (void 0 !== t.geometry && void 0 !== t.geometry.vertices)
						for (var r = t.geometry.vertices, i = 0, s = r.length; i < s; i++) e.copy(r[i]), e.applyMatrix4(t.matrixWorld), n.expandByPoint(e)
				}), this
			}
		}(),
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this
		},
		empty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
		},
		center: function(e) {
			return (e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
		},
		size: function(e) {
			return (e || new THREE.Vector3).subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		containsPoint: function(e) {
			return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1
		},
		getParameter: function(e, t) {
			return (t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
		},
		isIntersectionBox: function(e) {
			return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
		},
		clampPoint: function(e, t) {
			return (t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		getBoundingSphere: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return t = t || new THREE.Sphere, t.center = this.center(), t.radius = .5 * this.size(e).length(), t
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		applyMatrix4: function() {
			var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
			return function(t) {
				return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
			}
		}(),
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		},
		clone: function() {
			return (new THREE.Box3).copy(this)
		}
	}, THREE.Matrix3 = function(e, t, n, r, i, s, o, u, a) {
		this.elements = new Float32Array(9), this.set(void 0 !== e ? e : 1, t || 0, n || 0, r || 0, void 0 !== i ? i : 1, s || 0, o || 0, u || 0, void 0 !== a ? a : 1)
	}, THREE.Matrix3.prototype = {
		constructor: THREE.Matrix3,
		set: function(e, t, n, r, i, s, o, u, a) {
			var f = this.elements;
			return f[0] = e, f[3] = t, f[6] = n, f[1] = r, f[4] = i, f[7] = s, f[2] = o, f[5] = u, f[8] = a, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
		},
		copy: function(e) {
			return e = e.elements, this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
		},
		multiplyVector3: function(e) {
			return console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
		},
		multiplyVector3Array: function() {
			var e = new THREE.Vector3;
			return function(t) {
				for (var n = 0, r = t.length; n < r; n += 3) e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyMatrix3(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
				return t
			}
		}(),
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
		},
		determinant: function() {
			var e = this.elements,
				t = e[0],
				n = e[1],
				r = e[2],
				i = e[3],
				s = e[4],
				o = e[5],
				u = e[6],
				a = e[7],
				e = e[8];
			return t * s * e - t * o * a - n * i * e + n * o * u + r * i * a - r * s * u
		},
		getInverse: function(e, t) {
			var n = e.elements,
				r = this.elements;
			r[0] = n[10] * n[5] - n[6] * n[9], r[1] = -n[10] * n[1] + n[2] * n[9], r[2] = n[6] * n[1] - n[2] * n[5], r[3] = -n[10] * n[4] + n[6] * n[8], r[4] = n[10] * n[0] - n[2] * n[8], r[5] = -n[6] * n[0] + n[2] * n[4], r[6] = n[9] * n[4] - n[5] * n[8], r[7] = -n[9] * n[0] + n[1] * n[8], r[8] = n[5] * n[0] - n[1] * n[4], n = n[0] * r[0] + n[1] * r[3] + n[2] * r[6];
			if (0 === n) {
				if (t) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
				return console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
			}
			return this.multiplyScalar(1 / n), this
		},
		transpose: function() {
			var e, t = this.elements;
			return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
		},
		getNormalMatrix: function(e) {
			return this.getInverse(e).transpose(), this
		},
		transposeIntoArray: function(e) {
			var t = this.elements;
			return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
		},
		fromArray: function(e) {
			return this.elements.set(e), this
		},
		toArray: function() {
			var e = this.elements;
			return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
		},
		clone: function() {
			var e = this.elements;
			return new THREE.Matrix3(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8])
		}
	}, THREE.Matrix4 = function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
		var m = this.elements = new Float32Array(16);
		m[0] = void 0 !== e ? e : 1, m[4] = t || 0, m[8] = n || 0, m[12] = r || 0, m[1] = i || 0, m[5] = void 0 !== s ? s : 1, m[9] = o || 0, m[13] = u || 0, m[2] = a || 0, m[6] = f || 0, m[10] = void 0 !== l ? l : 1, m[14] = c || 0, m[3] = h || 0, m[7] = p || 0, m[11] = d || 0, m[15] = void 0 !== v ? v : 1
	}, THREE.Matrix4.prototype = {
		constructor: THREE.Matrix4,
		set: function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
			var m = this.elements;
			return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = s, m[9] = o, m[13] = u, m[2] = a, m[6] = f, m[10] = l, m[14] = c, m[3] = h, m[7] = p, m[11] = d, m[15] = v, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		copy: function(e) {
			return this.elements.set(e.elements), this
		},
		extractPosition: function(e) {
			return console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
		},
		copyPosition: function(e) {
			var t = this.elements;
			return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
		},
		extractRotation: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = this.elements;
				t = t.elements;
				var r = 1 / e.set(t[0], t[1], t[2]).length(),
					i = 1 / e.set(t[4], t[5], t[6]).length(),
					s = 1 / e.set(t[8], t[9], t[10]).length();
				return n[0] = t[0] * r, n[1] = t[1] * r, n[2] = t[2] * r, n[4] = t[4] * i, n[5] = t[5] * i, n[6] = t[6] * i, n[8] = t[8] * s, n[9] = t[9] * s, n[10] = t[10] * s, this
			}
		}(),
		makeRotationFromEuler: function(e) {
			0 == e instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
			var t = this.elements,
				n = e.x,
				r = e.y,
				i = e.z,
				s = Math.cos(n),
				n = Math.sin(n),
				o = Math.cos(r),
				r = Math.sin(r),
				u = Math.cos(i),
				i = Math.sin(i);
			if ("XYZ" === e.order) {
				e = s * u;
				var a = s * i,
					f = n * u,
					l = n * i;
				t[0] = o * u, t[4] = -o * i, t[8] = r, t[1] = a + f * r, t[5] = e - l * r, t[9] = -n * o, t[2] = l - e * r, t[6] = f + a * r, t[10] = s * o
			} else "YXZ" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e + l * n, t[4] = f * n - a, t[8] = s * r, t[1] = s * i, t[5] = s * u, t[9] = -n, t[2] = a * n - f, t[6] = l + e * n, t[10] = s * o) : "ZXY" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e - l * n, t[4] = -s * i, t[8] = f + a * n, t[1] = a + f * n, t[5] = s * u, t[9] = l - e * n, t[2] = -s * r, t[6] = n, t[10] = s * o) : "ZYX" === e.order ? (e = s * u, a = s * i, f = n * u, l = n * i, t[0] = o * u, t[4] = f * r - a, t[8] = e * r + l, t[1] = o * i, t[5] = l * r + e, t[9] = a * r - f, t[2] = -r, t[6] = n * o, t[10] = s * o) : "YZX" === e.order ? (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = l - e * i, t[8] = f * i + a, t[1] = i, t[5] = s * u, t[9] = -n * u, t[2] = -r * u, t[6] = a * i + f, t[10] = e - l * i) : "XZY" === e.order && (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = -i, t[8] = r * u, t[1] = e * i + l, t[5] = s * u, t[9] = a * i - f, t[2] = f * i - a, t[6] = n * u, t[10] = l * i + e);
			return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
		},
		setRotationFromQuaternion: function(e) {
			return console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code."), this.makeRotationFromQuaternion(e)
		},
		makeRotationFromQuaternion: function(e) {
			var t = this.elements,
				n = e.x,
				r = e.y,
				i = e.z,
				s = e.w,
				o = n + n,
				u = r + r,
				a = i + i;
			e = n * o;
			var f = n * u,
				n = n * a,
				l = r * u,
				r = r * a,
				i = i * a,
				o = s * o,
				u = s * u,
				s = s * a;
			return t[0] = 1 - (l + i), t[4] = f - s, t[8] = n + u, t[1] = f + s, t[5] = 1 - (e + i), t[9] = r - o, t[2] = n - u, t[6] = r + o, t[10] = 1 - (e + l), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
		},
		lookAt: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Vector3;
			return function(r, i, s) {
				var o = this.elements;
				return n.subVectors(r, i).normalize(), 0 === n.length() && (n.z = 1), e.crossVectors(s, n).normalize(), 0 === e.length() && (n.x += 1e-4, e.crossVectors(s, n).normalize()), t.crossVectors(n, e), o[0] = e.x, o[4] = t.x, o[8] = n.x, o[1] = e.y, o[5] = t.y, o[9] = n.y, o[2] = e.z, o[6] = t.z, o[10] = n.z, this
			}
		}(),
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
		},
		multiplyMatrices: function(e, t) {
			var n = e.elements,
				r = t.elements,
				i = this.elements,
				s = n[0],
				o = n[4],
				u = n[8],
				a = n[12],
				f = n[1],
				l = n[5],
				c = n[9],
				h = n[13],
				p = n[2],
				d = n[6],
				v = n[10],
				m = n[14],
				g = n[3],
				y = n[7],
				b = n[11],
				n = n[15],
				w = r[0],
				E = r[4],
				S = r[8],
				x = r[12],
				T = r[1],
				N = r[5],
				C = r[9],
				k = r[13],
				L = r[2],
				A = r[6],
				O = r[10],
				M = r[14],
				_ = r[3],
				D = r[7],
				P = r[11],
				r = r[15];
			return i[0] = s * w + o * T + u * L + a * _, i[4] = s * E + o * N + u * A + a * D, i[8] = s * S + o * C + u * O + a * P, i[12] = s * x + o * k + u * M + a * r, i[1] = f * w + l * T + c * L + h * _, i[5] = f * E + l * N + c * A + h * D, i[9] = f * S + l * C + c * O + h * P, i[13] = f * x + l * k + c * M + h * r, i[2] = p * w + d * T + v * L + m * _, i[6] = p * E + d * N + v * A + m * D, i[10] = p * S + d * C + v * O + m * P, i[14] = p * x + d * k + v * M + m * r, i[3] = g * w + y * T + b * L + n * _, i[7] = g * E + y * N + b * A + n * D, i[11] = g * S + y * C + b * O + n * P, i[15] = g * x + y * k + b * M + n * r, this
		},
		multiplyToArray: function(e, t, n) {
			var r = this.elements;
			return this.multiplyMatrices(e, t), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], n[4] = r[4], n[5] = r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8], n[9] = r[9], n[10] = r[10], n[11] = r[11], n[12] = r[12], n[13] = r[13], n[14] = r[14], n[15] = r[15], this
		},
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
		},
		multiplyVector3: function(e) {
			return console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
		},
		multiplyVector4: function(e) {
			return console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		multiplyVector3Array: function() {
			var e = new THREE.Vector3;
			return function(t) {
				for (var n = 0, r = t.length; n < r; n += 3) e.x = t[n], e.y = t[n + 1], e.z = t[n + 2], e.applyProjection(this), t[n] = e.x, t[n + 1] = e.y, t[n + 2] = e.z;
				return t
			}
		}(),
		rotateAxis: function(e) {
			console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
		},
		crossVector: function(e) {
			return console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		determinant: function() {
			var e = this.elements,
				t = e[0],
				n = e[4],
				r = e[8],
				i = e[12],
				s = e[1],
				o = e[5],
				u = e[9],
				a = e[13],
				f = e[2],
				l = e[6],
				c = e[10],
				h = e[14];
			return e[3] * (+i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) + e[7] * (+t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) + e[11] * (+t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) + e[15] * (-r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f)
		},
		transpose: function() {
			var e = this.elements,
				t;
			return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
		},
		flattenToArray: function(e) {
			var t = this.elements;
			return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
		},
		flattenToArrayOffset: function(e, t) {
			var n = this.elements;
			return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
		},
		getPosition: function() {
			var e = new THREE.Vector3;
			return function() {
				console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
				var t = this.elements;
				return e.set(t[12], t[13], t[14])
			}
		}(),
		setPosition: function(e) {
			var t = this.elements;
			return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
		},
		getInverse: function(e, t) {
			var n = this.elements,
				r = e.elements,
				i = r[0],
				s = r[4],
				o = r[8],
				u = r[12],
				a = r[1],
				f = r[5],
				l = r[9],
				c = r[13],
				h = r[2],
				p = r[6],
				d = r[10],
				v = r[14],
				m = r[3],
				g = r[7],
				y = r[11],
				r = r[15];
			n[0] = l * v * g - c * d * g + c * p * y - f * v * y - l * p * r + f * d * r, n[4] = u * d * g - o * v * g - u * p * y + s * v * y + o * p * r - s * d * r, n[8] = o * c * g - u * l * g + u * f * y - s * c * y - o * f * r + s * l * r, n[12] = u * l * p - o * c * p - u * f * d + s * c * d + o * f * v - s * l * v, n[1] = c * d * m - l * v * m - c * h * y + a * v * y + l * h * r - a * d * r, n[5] = o * v * m - u * d * m + u * h * y - i * v * y - o * h * r + i * d * r, n[9] = u * l * m - o * c * m - u * a * y + i * c * y + o * a * r - i * l * r, n[13] = o * c * h - u * l * h + u * a * d - i * c * d - o * a * v + i * l * v, n[2] = f * v * m - c * p * m + c * h * g - a * v * g - f * h * r + a * p * r, n[6] = u * p * m - s * v * m - u * h * g + i * v * g + s * h * r - i * p * r, n[10] = s * c * m - u * f * m + u * a * g - i * c * g - s * a * r + i * f * r, n[14] = u * f * h - s * c * h - u * a * p + i * c * p + s * a * v - i * f * v, n[3] = l * p * m - f * d * m - l * h * g + a * d * g + f * h * y - a * p * y, n[7] = s * d * m - o * p * m + o * h * g - i * d * g - s * h * y + i * p * y, n[11] = o * f * m - s * l * m - o * a * g + i * l * g + s * a * y - i * f * y, n[15] = s * l * h - o * f * h + o * a * p - i * l * p - s * a * d + i * f * d, n = i * n[0] + a * n[4] + h * n[8] + m * n[12];
			if (0 == n) {
				if (t) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
				return console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity(), this
			}
			return this.multiplyScalar(1 / n), this
		},
		translate: function(e) {
			console.warn("DEPRECATED: Matrix4's .translate() has been removed.")
		},
		rotateX: function(e) {
			console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")
		},
		rotateY: function(e) {
			console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")
		},
		rotateZ: function(e) {
			console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")
		},
		rotateByAxis: function(e, t) {
			console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")
		},
		scale: function(e) {
			var t = this.elements,
				n = e.x,
				r = e.y;
			return e = e.z, t[0] *= n, t[4] *= r, t[8] *= e, t[1] *= n, t[5] *= r, t[9] *= e, t[2] *= n, t[6] *= r, t[10] *= e, t[3] *= n, t[7] *= r, t[11] *= e, this
		},
		getMaxScaleOnAxis: function() {
			var e = this.elements;
			return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], Math.max(e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])))
		},
		makeTranslation: function(e, t, n) {
			return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
		},
		makeRotationX: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
		},
		makeRotationY: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
		},
		makeRotationZ: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		makeRotationAxis: function(e, t) {
			var n = Math.cos(t),
				r = Math.sin(t),
				i = 1 - n,
				s = e.x,
				o = e.y,
				u = e.z,
				a = i * s,
				f = i * o;
			return this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1), this
		},
		makeScale: function(e, t, n) {
			return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
		},
		compose: function(e, t, n) {
			return this.makeRotationFromQuaternion(t), this.scale(n), this.setPosition(e), this
		},
		decompose: function() {
			var e = new THREE.Vector3,
				t = new THREE.Matrix4;
			return function(n, r, i) {
				var s = this.elements,
					o = e.set(s[0], s[1], s[2]).length(),
					u = e.set(s[4], s[5], s[6]).length(),
					f = e.set(s[8], s[9], s[10]).length();
				0 > this.determinant() && (o = -o), n.x = s[12], n.y = s[13], n.z = s[14], t.elements.set(this.elements), n = 1 / o;
				var s = 1 / u,
					l = 1 / f;
				return t.elements[0] *= n, t.elements[1] *= n, t.elements[2] *= n, t.elements[4] *= s, t.elements[5] *= s, t.elements[6] *= s, t.elements[8] *= l, t.elements[9] *= l, t.elements[10] *= l, r.setFromRotationMatrix(t), i.x = o, i.y = u, i.z = f, this
			}
		}(),
		makeFrustum: function(e, t, n, r, i, s) {
			var o = this.elements;
			return o[0] = 2 * i / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, o[5] = 2 * i / (r - n), o[9] = (r + n) / (r - n), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(s + i) / (s - i), o[14] = -2 * s * i / (s - i), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
		},
		makePerspective: function(e, t, n, r) {
			e = n * Math.tan(THREE.Math.degToRad(.5 * e));
			var i = -e;
			return this.makeFrustum(i * t, e * t, i, e, n, r)
		},
		makeOrthographic: function(e, t, n, r, i, s) {
			var o = this.elements,
				u = t - e,
				a = n - r,
				f = s - i;
			return o[0] = 2 / u, o[4] = 0, o[8] = 0, o[12] = -((t + e) / u), o[1] = 0, o[5] = 2 / a, o[9] = 0, o[13] = -((n + r) / a), o[2] = 0, o[6] = 0, o[10] = -2 / f, o[14] = -((s + i) / f), o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
		},
		fromArray: function(e) {
			return this.elements.set(e), this
		},
		toArray: function() {
			var e = this.elements;
			return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
		},
		clone: function() {
			var e = this.elements;
			return new THREE.Matrix4(e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15])
		}
	}, THREE.Ray = function(e, t) {
		this.origin = void 0 !== e ? e : new THREE.Vector3, this.direction = void 0 !== t ? t : new THREE.Vector3
	}, THREE.Ray.prototype = {
		constructor: THREE.Ray,
		set: function(e, t) {
			return this.origin.copy(e), this.direction.copy(t), this
		},
		copy: function(e) {
			return this.origin.copy(e.origin), this.direction.copy(e.direction), this
		},
		at: function(e, t) {
			return (t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
		},
		recast: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return this.origin.copy(this.at(t, e)), this
			}
		}(),
		closestPointToPoint: function(e, t) {
			var n = t || new THREE.Vector3;
			n.subVectors(e, this.origin);
			var r = n.dot(this.direction);
			return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
		},
		distanceToPoint: function() {
			var e = new THREE.Vector3;
			return function(t) {
				var n = e.subVectors(t, this.origin).dot(this.direction);
				return 0 > n ? this.origin.distanceTo(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceTo(t))
			}
		}(),
		distanceSqToSegment: function(e, t, n, r) {
			var i = e.clone().add(t).multiplyScalar(.5),
				s = t.clone().sub(e).normalize(),
				o = .5 * e.distanceTo(t),
				u = this.origin.clone().sub(i);
			e = -this.direction.dot(s), t = u.dot(this.direction);
			var a = -u.dot(s),
				f = u.lengthSq(),
				l = Math.abs(1 - e * e),
				c, h;
			return 0 <= l ? (u = e * a - t, c = e * t - a, h = o * l, 0 <= u ? c >= -h ? c <= h ? (o = 1 / l, u *= o, c *= o, e = u * (u + e * c + 2 * t) + c * (e * u + c + 2 * a) + f) : (c = o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f) : (c = -o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f) : c <= -h ? (u = Math.max(0, -(-e * o + t)), c = 0 < u ? -o : Math.min(Math.max(-o, -a), o), e = -u * u + c * (c + 2 * a) + f) : c <= h ? (u = 0, c = Math.min(Math.max(-o, -a), o), e = c * (c + 2 * a) + f) : (u = Math.max(0, -(e * o + t)), c = 0 < u ? o : Math.min(Math.max(-o, -a), o), e = -u * u + c * (c + 2 * a) + f)) : (c = 0 < e ? -o : o, u = Math.max(0, -(e * c + t)), e = -u * u + c * (c + 2 * a) + f), n && n.copy(this.direction.clone().multiplyScalar(u).add(this.origin)), r && r.copy(s.clone().multiplyScalar(c).add(i)), e
		},
		isIntersectionSphere: function(e) {
			return this.distanceToPoint(e.center) <= e.radius
		},
		isIntersectionPlane: function(e) {
			var t = e.distanceToPoint(this.origin);
			return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
		},
		distanceToPlane: function(e) {
			var t = e.normal.dot(this.direction);
			return 0 == t ? 0 == e.distanceToPoint(this.origin) ? 0 : null : (e = -(this.origin.dot(e.normal) + e.constant) / t, 0 <= e ? e : null)
		},
		intersectPlane: function(e, t) {
			var n = this.distanceToPlane(e);
			return null === n ? null : this.at(n, t)
		},
		isIntersectionBox: function() {
			var e = new THREE.Vector3;
			return function(t) {
				return null !== this.intersectBox(t, e)
			}
		}(),
		intersectBox: function(e, t) {
			var n, r, i, s, o;
			r = 1 / this.direction.x, s = 1 / this.direction.y, o = 1 / this.direction.z;
			var u = this.origin;
			0 <= r ? (n = (e.min.x - u.x) * r, r *= e.max.x - u.x) : (n = (e.max.x - u.x) * r, r *= e.min.x - u.x), 0 <= s ? (i = (e.min.y - u.y) * s, s *= e.max.y - u.y) : (i = (e.max.y - u.y) * s, s *= e.min.y - u.y);
			if (n > s || i > r) return null;
			if (i > n || n !== n) n = i;
			if (s < r || r !== r) r = s;
			0 <= o ? (i = (e.min.z - u.z) * o, o *= e.max.z - u.z) : (i = (e.max.z - u.z) * o, o *= e.min.z - u.z);
			if (n > o || i > r) return null;
			if (i > n || n !== n) n = i;
			if (o < r || r !== r) r = o;
			return 0 > r ? null : this.at(0 <= n ? n : r, t)
		},
		intersectTriangle: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Vector3,
				r = new THREE.Vector3;
			return function(i, s, o, u, f) {
				t.subVectors(s, i), n.subVectors(o, i), r.crossVectors(t, n), s = this.direction.dot(r);
				if (0 < s) {
					if (u) return null;
					u = 1
				} else {
					if (!(0 > s)) return null;
					u = -1, s = -s
				}
				return e.subVectors(this.origin, i), i = u * this.direction.dot(n.crossVectors(e, n)), 0 > i ? null : (o = u * this.direction.dot(t.cross(e)), 0 > o || i + o > s ? null : (i = -u * e.dot(r), 0 > i ? null : this.at(i / s, f)))
			}
		}(),
		applyMatrix4: function(e) {
			return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
		},
		equals: function(e) {
			return e.origin.equals(this.origin) && e.direction.equals(this.direction)
		},
		clone: function() {
			return (new THREE.Ray).copy(this)
		}
	}, THREE.Sphere = function(e, t) {
		this.center = void 0 !== e ? e : new THREE.Vector3, this.radius = void 0 !== t ? t : 0
	}, THREE.Sphere.prototype = {
		constructor: THREE.Sphere,
		set: function(e, t) {
			return this.center.copy(e), this.radius = t, this
		},
		setFromPoints: function() {
			var e = new THREE.Box3;
			return function(t, n) {
				var r = this.center;
				void 0 !== n ? r.copy(n) : e.setFromPoints(t).center(r);
				for (var i = 0, s = 0, o = t.length; s < o; s++) i = Math.max(i, r.distanceToSquared(t[s]));
				return this.radius = Math.sqrt(i), this
			}
		}(),
		copy: function(e) {
			return this.center.copy(e.center), this.radius = e.radius, this
		},
		empty: function() {
			return 0 >= this.radius
		},
		containsPoint: function(e) {
			return e.distanceToSquared(this.center) <= this.radius * this.radius
		},
		distanceToPoint: function(e) {
			return e.distanceTo(this.center) - this.radius
		},
		intersectsSphere: function(e) {
			var t = this.radius + e.radius;
			return e.center.distanceToSquared(this.center) <= t * t
		},
		clampPoint: function(e, t) {
			var n = this.center.distanceToSquared(e),
				r = t || new THREE.Vector3;
			return r.copy(e), n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r
		},
		getBoundingBox: function(e) {
			return e = e || new THREE.Box3, e.set(this.center, this.center), e.expandByScalar(this.radius), e
		},
		applyMatrix4: function(e) {
			return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
		},
		translate: function(e) {
			return this.center.add(e), this
		},
		equals: function(e) {
			return e.center.equals(this.center) && e.radius === this.radius
		},
		clone: function() {
			return (new THREE.Sphere).copy(this)
		}
	}, THREE.Frustum = function(e, t, n, r, i, s) {
		this.planes = [void 0 !== e ? e : new THREE.Plane, void 0 !== t ? t : new THREE.Plane, void 0 !== n ? n : new THREE.Plane, void 0 !== r ? r : new THREE.Plane, void 0 !== i ? i : new THREE.Plane, void 0 !== s ? s : new THREE.Plane]
	}, THREE.Frustum.prototype = {
		constructor: THREE.Frustum,
		set: function(e, t, n, r, i, s) {
			var o = this.planes;
			return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this
		},
		copy: function(e) {
			for (var t = this.planes, n = 0; 6 > n; n++) t[n].copy(e.planes[n]);
			return this
		},
		setFromMatrix: function(e) {
			var t = this.planes,
				n = e.elements;
			e = n[0];
			var r = n[1],
				i = n[2],
				s = n[3],
				o = n[4],
				u = n[5],
				a = n[6],
				f = n[7],
				l = n[8],
				c = n[9],
				h = n[10],
				p = n[11],
				d = n[12],
				v = n[13],
				m = n[14],
				n = n[15];
			return t[0].setComponents(s - e, f - o, p - l, n - d).normalize(), t[1].setComponents(s + e, f + o, p + l, n + d).normalize(), t[2].setComponents(s + r, f + u, p + c, n + v).normalize(), t[3].setComponents(s - r, f - u, p - c, n - v).normalize(), t[4].setComponents(s - i, f - a, p - h, n - m).normalize(), t[5].setComponents(s + i, f + a, p + h, n + m).normalize(), this
		},
		intersectsObject: function() {
			var e = new THREE.Sphere;
			return function(t) {
				var n = t.geometry;
				return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
			}
		}(),
		intersectsSphere: function(e) {
			var t = this.planes,
				n = e.center;
			e = -e.radius;
			for (var r = 0; 6 > r; r++)
				if (t[r].distanceToPoint(n) < e) return !1;
			return !0
		},
		intersectsBox: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n) {
				for (var r = this.planes, i = 0; 6 > i; i++) {
					var s = r[i];
					e.x = 0 < s.normal.x ? n.min.x : n.max.x, t.x = 0 < s.normal.x ? n.max.x : n.min.x, e.y = 0 < s.normal.y ? n.min.y : n.max.y, t.y = 0 < s.normal.y ? n.max.y : n.min.y, e.z = 0 < s.normal.z ? n.min.z : n.max.z, t.z = 0 < s.normal.z ? n.max.z : n.min.z;
					var o = s.distanceToPoint(e),
						s = s.distanceToPoint(t);
					if (0 > o && 0 > s) return !1
				}
				return !0
			}
		}(),
		containsPoint: function(e) {
			for (var t = this.planes, n = 0; 6 > n; n++)
				if (0 > t[n].distanceToPoint(e)) return !1;
			return !0
		},
		clone: function() {
			return (new THREE.Frustum).copy(this)
		}
	}, THREE.Plane = function(e, t) {
		this.normal = void 0 !== e ? e : new THREE.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
	}, THREE.Plane.prototype = {
		constructor: THREE.Plane,
		set: function(e, t) {
			return this.normal.copy(e), this.constant = t, this
		},
		setComponents: function(e, t, n, r) {
			return this.normal.set(e, t, n), this.constant = r, this
		},
		setFromNormalAndCoplanarPoint: function(e, t) {
			return this.normal.copy(e), this.constant = -t.dot(this.normal), this
		},
		setFromCoplanarPoints: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n, r, i) {
				return r = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(), this.setFromNormalAndCoplanarPoint(r, n), this
			}
		}(),
		copy: function(e) {
			return this.normal.copy(e.normal), this.constant = e.constant, this
		},
		normalize: function() {
			var e = 1 / this.normal.length();
			return this.normal.multiplyScalar(e), this.constant *= e, this
		},
		negate: function() {
			return this.constant *= -1, this.normal.negate(), this
		},
		distanceToPoint: function(e) {
			return this.normal.dot(e) + this.constant
		},
		distanceToSphere: function(e) {
			return this.distanceToPoint(e.center) - e.radius
		},
		projectPoint: function(e, t) {
			return this.orthoPoint(e, t).sub(e).negate()
		},
		orthoPoint: function(e, t) {
			var n = this.distanceToPoint(e);
			return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(n)
		},
		isIntersectionLine: function(e) {
			var t = this.distanceToPoint(e.start);
			return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
		},
		intersectLine: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				var r = n || new THREE.Vector3,
					i = t.delta(e),
					s = this.normal.dot(i);
				if (0 != s) return s = -(t.start.dot(this.normal) + this.constant) / s, 0 > s || 1 < s ? void 0 : r.copy(i).multiplyScalar(s).add(t.start);
				if (0 == this.distanceToPoint(t.start)) return r.copy(t.start)
			}
		}(),
		coplanarPoint: function(e) {
			return (e || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
		},
		applyMatrix4: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3,
				n = new THREE.Matrix3;
			return function(r, i) {
				var s = i || n.getNormalMatrix(r),
					s = e.copy(this.normal).applyMatrix3(s),
					o = this.coplanarPoint(t);
				return o.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(s, o), this
			}
		}(),
		translate: function(e) {
			return this.constant -= e.dot(this.normal), this
		},
		equals: function(e) {
			return e.normal.equals(this.normal) && e.constant == this.constant
		},
		clone: function() {
			return (new THREE.Plane).copy(this)
		}
	}, THREE.Math = {
		PI2: 2 * Math.PI,
		generateUUID: function() {
			var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
				t = Array(36),
				n = 0,
				r;
			return function() {
				for (var i = 0; 36 > i; i++) 8 == i || 13 == i || 18 == i || 23 == i ? t[i] = "-" : 14 == i ? t[i] = "4" : (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), r = n & 15, n >>= 4, t[i] = e[19 == i ? r & 3 | 8 : r]);
				return t.join("")
			}
		}(),
		clamp: function(e, t, n) {
			return e < t ? t : e > n ? n : e
		},
		clampBottom: function(e, t) {
			return e < t ? t : e
		},
		mapLinear: function(e, t, n, r, i) {
			return r + (e - t) * (i - r) / (n - t)
		},
		smoothstep: function(e, t, n) {
			return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
		},
		smootherstep: function(e, t, n) {
			return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
		},
		random16: function() {
			return (65280 * Math.random() + 255 * Math.random()) / 65535
		},
		randInt: function(e, t) {
			return e + Math.floor(Math.random() * (t - e + 1))
		},
		randFloat: function(e, t) {
			return e + Math.random() * (t - e)
		},
		randFloatSpread: function(e) {
			return e * (.5 - Math.random())
		},
		sign: function(e) {
			return 0 > e ? -1 : 0 < e ? 1 : 0
		},
		degToRad: function() {
			var e = Math.PI / 180;
			return function(t) {
				return t * e
			}
		}(),
		radToDeg: function() {
			var e = 180 / Math.PI;
			return function(t) {
				return t * e
			}
		}(),
		isPowerOfTwo: function(e) {
			return 0 === (e & e - 1) && 0 !== e
		}
	}, THREE.Spline = function(e) {
		function t(e, t, n, r, i, s, o) {
			return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * o + (-3 * (t - n) - 2 * e - r) * s + e * i + t
		}
		this.points = e;
		var n = [],
			r = {
				x: 0,
				y: 0,
				z: 0
			},
			i, s, o, u, a, f, l, c, h;
		this.initFromArray = function(e) {
			this.points = [];
			for (var t = 0; t < e.length; t++) this.points[t] = {
				x: e[t][0],
				y: e[t][1],
				z: e[t][2]
			}
		}, this.getPoint = function(e) {
			return i = (this.points.length - 1) * e, s = Math.floor(i), o = i - s, n[0] = 0 === s ? s : s - 1, n[1] = s, n[2] = s > this.points.length - 2 ? this.points.length - 1 : s + 1, n[3] = s > this.points.length - 3 ? this.points.length - 1 : s + 2, f = this.points[n[0]], l = this.points[n[1]], c = this.points[n[2]], h = this.points[n[3]], u = o * o, a = o * u, r.x = t(f.x, l.x, c.x, h.x, o, u, a), r.y = t(f.y, l.y, c.y, h.y, o, u, a), r.z = t(f.z, l.z, c.z, h.z, o, u, a), r
		}, this.getControlPointsArray = function() {
			var e, t, n = this.points.length,
				r = [];
			for (e = 0; e < n; e++) t = this.points[e], r[e] = [t.x, t.y, t.z];
			return r
		}, this.getLength = function(e) {
			var t, n, r, i = t = t = 0,
				s = new THREE.Vector3,
				o = new THREE.Vector3,
				u = [],
				a = 0;
			u[0] = 0, e || (e = 100), n = this.points.length * e, s.copy(this.points[0]);
			for (e = 1; e < n; e++) t = e / n, r = this.getPoint(t), o.copy(r), a += o.distanceTo(s), s.copy(r), t *= this.points.length - 1, t = Math.floor(t), t != i && (u[t] = a, i = t);
			return u[u.length] = a, {
				chunks: u,
				total: a
			}
		}, this.reparametrizeByArcLength = function(e) {
			var t, n, r, i, s, o, u = [],
				a = new THREE.Vector3,
				f = this.getLength();
			u.push(a.copy(this.points[0]).clone());
			for (t = 1; t < this.points.length; t++) {
				n = f.chunks[t] - f.chunks[t - 1], o = Math.ceil(e * n / f.total), i = (t - 1) / (this.points.length - 1), s = t / (this.points.length - 1);
				for (n = 1; n < o - 1; n++) r = i + 1 / o * n * (s - i), r = this.getPoint(r), u.push(a.copy(r).clone());
				u.push(a.copy(this.points[t]).clone())
			}
			this.points = u
		}
	}, THREE.Triangle = function(e, t, n) {
		this.a = void 0 !== e ? e : new THREE.Vector3, this.b = void 0 !== t ? t : new THREE.Vector3, this.c = void 0 !== n ? n : new THREE.Vector3
	}, THREE.Triangle.normal = function() {
		var e = new THREE.Vector3;
		return function(t, n, r, i) {
			return i = i || new THREE.Vector3, i.subVectors(r, n), e.subVectors(t, n), i.cross(e), t = i.lengthSq(), 0 < t ? i.multiplyScalar(1 / Math.sqrt(t)) : i.set(0, 0, 0)
		}
	}(), THREE.Triangle.barycoordFromPoint = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3,
			n = new THREE.Vector3;
		return function(r, i, s, o, u) {
			e.subVectors(o, i), t.subVectors(s, i), n.subVectors(r, i), r = e.dot(e), i = e.dot(t), s = e.dot(n);
			var f = t.dot(t);
			o = t.dot(n);
			var l = r * f - i * i;
			return u = u || new THREE.Vector3, 0 == l ? u.set(-2, -1, -1) : (l = 1 / l, f = (f * s - i * o) * l, r = (r * o - i * s) * l, u.set(1 - f - r, r, f))
		}
	}(), THREE.Triangle.containsPoint = function() {
		var e = new THREE.Vector3;
		return function(t, n, r, i) {
			return t = THREE.Triangle.barycoordFromPoint(t, n, r, i, e), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
		}
	}(), THREE.Triangle.prototype = {
		constructor: THREE.Triangle,
		set: function(e, t, n) {
			return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
		},
		setFromPointsAndIndices: function(e, t, n, r) {
			return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
		},
		copy: function(e) {
			return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
		},
		area: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function() {
				return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
			}
		}(),
		midpoint: function(e) {
			return (e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
		},
		normal: function(e) {
			return THREE.Triangle.normal(this.a, this.b, this.c, e)
		},
		plane: function(e) {
			return (e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
		},
		barycoordFromPoint: function(e, t) {
			return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
		},
		containsPoint: function(e) {
			return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
		},
		equals: function(e) {
			return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
		},
		clone: function() {
			return (new THREE.Triangle).copy(this)
		}
	}, THREE.Vertex = function(e) {
		return console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead."), e
	}, THREE.UV = function(e, t) {
		return console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead."), new THREE.Vector2(e, t)
	}, THREE.Clock = function(e) {
		this.autoStart = void 0 !== e ? e : !0, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
	}, THREE.Clock.prototype = {
		constructor: THREE.Clock,
		start: function() {
			this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), this.running = !0
		},
		stop: function() {
			this.getElapsedTime(), this.running = !1
		},
		getElapsedTime: function() {
			return this.getDelta(), this.elapsedTime
		},
		getDelta: function() {
			var e = 0;
			this.autoStart && !this.running && this.start();
			if (this.running) {
				var t = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
					e = .001 * (t - this.oldTime);
				this.oldTime = t, this.elapsedTime += e
			}
			return e
		}
	}, THREE.EventDispatcher = function() {}, THREE.EventDispatcher.prototype = {
		constructor: THREE.EventDispatcher,
		apply: function(e) {
			e.addEventListener = THREE.EventDispatcher.prototype.addEventListener, e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener, e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
		},
		addEventListener: function(e, t) {
			void 0 === this._listeners && (this._listeners = {});
			var n = this._listeners;
			void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
		},
		hasEventListener: function(e, t) {
			if (void 0 === this._listeners) return !1;
			var n = this._listeners;
			return void 0 !== n[e] && -1 !== n[e].indexOf(t) ? !0 : !1
		},
		removeEventListener: function(e, t) {
			if (void 0 !== this._listeners) {
				var n = this._listeners[e];
				if (void 0 !== n) {
					var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
				}
			}
		},
		dispatchEvent: function() {
			var e = [];
			return function(t) {
				if (void 0 !== this._listeners) {
					var n = this._listeners[t.type];
					if (void 0 !== n) {
						t.target = this;
						for (var r = n.length, i = 0; i < r; i++) e[i] = n[i];
						for (i = 0; i < r; i++) e[i].call(this, t)
					}
				}
			}
		}()
	},
	function(e) {
		e.Raycaster = function(t, n, r, i) {
			this.ray = new e.Ray(t, n), this.near = r || 0, this.far = i || Infinity
		};
		var t = new e.Sphere,
			n = new e.Ray;
		new e.Plane, new e.Vector3;
		var r = new e.Vector3,
			i = new e.Matrix4,
			s = function(e, t) {
				return e.distance - t.distance
			},
			o = new e.Vector3,
			u = new e.Vector3,
			a = new e.Vector3,
			f = function(s, l, p) {
				if (s instanceof e.Sprite) {
					r.setFromMatrixPosition(s.matrixWorld);
					var v = l.ray.distanceToPoint(r);
					if (v > s.scale.x) return p;
					p.push({
						distance: v,
						point: s.position,
						face: null,
						object: s
					})
				} else if (s instanceof e.LOD) r.setFromMatrixPosition(s.matrixWorld), v = l.ray.origin.distanceTo(r), f(s.getObjectForDistance(v), l, p);
				else if (s instanceof e.Mesh) {
					var m = s.geometry;
					null === m.boundingSphere && m.computeBoundingSphere(), t.copy(m.boundingSphere), t.applyMatrix4(s.matrixWorld);
					if (!1 === l.ray.isIntersectionSphere(t)) return p;
					i.getInverse(s.matrixWorld), n.copy(l.ray).applyMatrix4(i);
					if (null !== m.boundingBox && !1 === n.isIntersectionBox(m.boundingBox)) return p;
					if (m instanceof e.BufferGeometry) {
						var y = s.material;
						if (void 0 === y) return p;
						var w = m.attributes,
							E, S, x = l.precision;
						if (void 0 !== w.index)
							for (var T = m.offsets, N = w.index.array, C = w.position.array, L = 0, A = T.length; L < A; ++L)
								for (var w = T[L].start, O = T[L].index, m = w, M = w + T[L].count; m < M; m += 3) {
									w = O + N[m], E = O + N[m + 1], S = O + N[m + 2], o.set(C[3 * w], C[3 * w + 1], C[3 * w + 2]), u.set(C[3 * E], C[3 * E + 1], C[3 * E + 2]), a.set(C[3 * S], C[3 * S + 1], C[3 * S + 2]);
									var _ = y.side === e.BackSide ? n.intersectTriangle(a, u, o, !0) : n.intersectTriangle(o, u, a, y.side !== e.DoubleSide);
									null !== _ && (_.applyMatrix4(s.matrixWorld), v = l.ray.origin.distanceTo(_), v < x || v < l.near || v > l.far || p.push({
										distance: v,
										point: _,
										indices: [w, E, S],
										face: null,
										faceIndex: null,
										object: s
									}))
								} else
									for (C = w.position.array, m = 0, M = w.position.array.length; m < M; m += 3) w = m, E = m + 1, S = m + 2, o.set(C[3 * w], C[3 * w + 1], C[3 * w + 2]), u.set(C[3 * E], C[3 * E + 1], C[3 * E + 2]), a.set(C[3 * S], C[3 * S + 1], C[3 * S + 2]), _ = y.side === e.BackSide ? n.intersectTriangle(a, u, o, !0) : n.intersectTriangle(o, u, a, y.side !== e.DoubleSide), null !== _ && (_.applyMatrix4(s.matrixWorld), v = l.ray.origin.distanceTo(_), v < x || v < l.near || v > l.far || p.push({
										distance: v,
										point: _,
										indices: [w, E, S],
										face: null,
										faceIndex: null,
										object: s
									}))
					} else if (m instanceof e.Geometry)
						for (N = s.material instanceof e.MeshFaceMaterial, C = !0 === N ? s.material.materials : null, x = l.precision, T = m.vertices, L = 0, A = m.faces.length; L < A; L++)
							if (O = m.faces[L], y = !0 === N ? C[O.materialIndex] : s.material, void 0 !== y) {
								w = T[O.a], E = T[O.b], S = T[O.c];
								if (!0 === y.morphTargets) {
									v = m.morphTargets, _ = s.morphTargetInfluences, o.set(0, 0, 0), u.set(0, 0, 0), a.set(0, 0, 0);
									for (var M = 0, D = v.length; M < D; M++) {
										var P = _[M];
										if (0 !== P) {
											var H = v[M].vertices;
											o.x += (H[O.a].x - w.x) * P, o.y += (H[O.a].y - w.y) * P, o.z += (H[O.a].z - w.z) * P, u.x += (H[O.b].x - E.x) * P, u.y += (H[O.b].y - E.y) * P, u.z += (H[O.b].z - E.z) * P, a.x += (H[O.c].x - S.x) * P, a.y += (H[O.c].y - S.y) * P, a.z += (H[O.c].z - S.z) * P
										}
									}
									o.add(w), u.add(E), a.add(S), w = o, E = u, S = a
								}
								_ = y.side === e.BackSide ? n.intersectTriangle(S, E, w, !0) : n.intersectTriangle(w, E, S, y.side !== e.DoubleSide), null !== _ && (_.applyMatrix4(s.matrixWorld), v = l.ray.origin.distanceTo(_), v < x || v < l.near || v > l.far || p.push({
									distance: v,
									point: _,
									face: O,
									faceIndex: L,
									object: s
								}))
							}
				} else if (s instanceof e.Line) {
					x = l.linePrecision, y = x * x, m = s.geometry, null === m.boundingSphere && m.computeBoundingSphere(), t.copy(m.boundingSphere), t.applyMatrix4(s.matrixWorld);
					if (!1 === l.ray.isIntersectionSphere(t)) return p;
					i.getInverse(s.matrixWorld), n.copy(l.ray).applyMatrix4(i);
					if (m instanceof e.Geometry)
						for (T = m.vertices, x = T.length, w = new e.Vector3, E = new e.Vector3, S = s.type === e.LineStrip ? 1 : 2, m = 0; m < x - 1; m += S) n.distanceSqToSegment(T[m], T[m + 1], E, w) > y || (v = n.origin.distanceTo(E), v < l.near || v > l.far || p.push({
							distance: v,
							point: w.clone().applyMatrix4(s.matrixWorld),
							face: null,
							faceIndex: null,
							object: s
						}))
				}
			},
			l = function(e, t, n) {
				e = e.getDescendants();
				for (var r = 0, i = e.length; r < i; r++) f(e[r], t, n)
			};
		e.Raycaster.prototype.precision = 1e-4, e.Raycaster.prototype.linePrecision = 1, e.Raycaster.prototype.set = function(e, t) {
			this.ray.set(e, t)
		}, e.Raycaster.prototype.intersectObject = function(e, t) {
			var n = [];
			return !0 === t && l(e, this, n), f(e, this, n), n.sort(s), n
		}, e.Raycaster.prototype.intersectObjects = function(e, t) {
			for (var n = [], r = 0, i = e.length; r < i; r++) f(e[r], this, n), !0 === t && l(e[r], this, n);
			return n.sort(s), n
		}
	}(THREE), THREE.Object3D = function() {
		this.id = THREE.Object3DIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.parent = void 0, this.children = [], this.up = new THREE.Vector3(0, 1, 0), this.position = new THREE.Vector3, this._rotation = new THREE.Euler, this._quaternion = new THREE.Quaternion, this.scale = new THREE.Vector3(1, 1, 1), this._rotation._quaternion = this.quaternion, this._quaternion._euler = this.rotation, this.renderDepth = null, this.rotationAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.matrixWorld = new THREE.Matrix4, this.visible = this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.userData = {}
	}, THREE.Object3D.prototype = {
		constructor: THREE.Object3D,
		get rotation() {
			return this._rotation
		},
		set rotation(e) {
			this._rotation = e, this._rotation._quaternion = this._quaternion, this._quaternion._euler = this._rotation, this._rotation._updateQuaternion()
		},
		get quaternion() {
			return this._quaternion
		},
		set quaternion(e) {
			this._quaternion = e, this._quaternion._euler = this._rotation, this._rotation._quaternion = this._quaternion, this._quaternion._updateEuler()
		},
		get eulerOrder() {
			return console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order
		},
		set eulerOrder(e) {
			console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order."), this.rotation.order = e
		},
		get useQuaternion() {
			console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
		},
		set useQuaternion(e) {
			console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
		},
		applyMatrix: function(e) {
			this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
		},
		setRotationFromAxisAngle: function(e, t) {
			this.quaternion.setFromAxisAngle(e, t)
		},
		setRotationFromEuler: function(e) {
			this.quaternion.setFromEuler(e, !0)
		},
		setRotationFromMatrix: function(e) {
			this.quaternion.setFromRotationMatrix(e)
		},
		setRotationFromQuaternion: function(e) {
			this.quaternion.copy(e)
		},
		rotateOnAxis: function() {
			var e = new THREE.Quaternion;
			return function(t, n) {
				return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
			}
		}(),
		rotateX: function() {
			var e = new THREE.Vector3(1, 0, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateY: function() {
			var e = new THREE.Vector3(0, 1, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateZ: function() {
			var e = new THREE.Vector3(0, 0, 1);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		translateOnAxis: function() {
			var e = new THREE.Vector3;
			return function(t, n) {
				return e.copy(t), e.applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
			}
		}(),
		translate: function(e, t) {
			return console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed."), this.translateOnAxis(t, e)
		},
		translateX: function() {
			var e = new THREE.Vector3(1, 0, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateY: function() {
			var e = new THREE.Vector3(0, 1, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateZ: function() {
			var e = new THREE.Vector3(0, 0, 1);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		localToWorld: function(e) {
			return e.applyMatrix4(this.matrixWorld)
		},
		worldToLocal: function() {
			var e = new THREE.Matrix4;
			return function(t) {
				return t.applyMatrix4(e.getInverse(this.matrixWorld))
			}
		}(),
		lookAt: function() {
			var e = new THREE.Matrix4;
			return function(t) {
				e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
			}
		}(),
		add: function(e) {
			if (e === this) console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
			else if (e instanceof THREE.Object3D) {
				void 0 !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
					type: "added"
				}), this.children.push(e);
				for (var t = this; void 0 !== t.parent;) t = t.parent;
				void 0 !== t && t instanceof THREE.Scene && t.__addObject(e)
			}
		},
		remove: function(e) {
			var t = this.children.indexOf(e);
			if (-1 !== t) {
				e.parent = void 0, e.dispatchEvent({
					type: "removed"
				}), this.children.splice(t, 1);
				for (t = this; void 0 !== t.parent;) t = t.parent;
				void 0 !== t && t instanceof THREE.Scene && t.__removeObject(e)
			}
		},
		traverse: function(e) {
			e(this);
			for (var t = 0, n = this.children.length; t < n; t++) this.children[t].traverse(e)
		},
		getObjectById: function(e, t) {
			for (var n = 0, r = this.children.length; n < r; n++) {
				var i = this.children[n];
				if (i.id === e || !0 === t && (i = i.getObjectById(e, t), void 0 !== i)) return i
			}
		},
		getObjectByName: function(e, t) {
			for (var n = 0, r = this.children.length; n < r; n++) {
				var i = this.children[n];
				if (i.name === e || !0 === t && (i = i.getObjectByName(e, t), void 0 !== i)) return i
			}
		},
		getChildByName: function(e, t) {
			return console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e, t)
		},
		getDescendants: function(e) {
			void 0 === e && (e = []), Array.prototype.push.apply(e, this.children);
			for (var t = 0, n = this.children.length; t < n; t++) this.children[t].getDescendants(e);
			return e
		},
		updateMatrix: function() {
			this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
		},
		updateMatrixWorld: function(e) {
			!0 === this.matrixAutoUpdate && this.updateMatrix();
			if (!0 === this.matrixWorldNeedsUpdate || !0 === e) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0;
			for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e)
		},
		clone: function(e, t) {
			void 0 === e && (e = new THREE.Object3D), void 0 === t && (t = !0), e.name = this.name, e.up.copy(this.up), e.position.copy(this.position), e.quaternion.copy(this.quaternion), e.scale.copy(this.scale), e.renderDepth = this.renderDepth, e.rotationAutoUpdate = this.rotationAutoUpdate, e.matrix.copy(this.matrix), e.matrixWorld.copy(this.matrixWorld), e.matrixAutoUpdate = this.matrixAutoUpdate, e.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, e.visible = this.visible, e.castShadow = this.castShadow, e.receiveShadow = this.receiveShadow, e.frustumCulled = this.frustumCulled, e.userData = JSON.parse(JSON.stringify(this.userData));
			if (!0 === t)
				for (var n = 0; n < this.children.length; n++) e.add(this.children[n].clone());
			return e
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype), THREE.Object3DIdCount = 0, THREE.Projector = function() {
		function e() {
			if (l === h) {
				var e = new THREE.RenderableVertex;
				return c.push(e), h++, l++, e
			}
			return c[l++]
		}

		function t() {
			if (d === m) {
				var e = new THREE.RenderableFace;
				return v.push(e), m++, d++, e
			}
			return v[d++]
		}

		function n() {
			if (y === w) {
				var e = new THREE.RenderableLine;
				return b.push(e), w++, y++, e
			}
			return b[y++]
		}

		function r(e, t) {
			return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0
		}

		function i(e, t) {
			var n = 0,
				r = 1,
				i = e.z + e.w,
				s = t.z + t.w,
				o = -e.z + e.w,
				u = -t.z + t.w;
			return 0 <= i && 0 <= s && 0 <= o && 0 <= u ? !0 : 0 > i && 0 > s || 0 > o && 0 > u ? !1 : (0 > i ? n = Math.max(n, i / (i - s)) : 0 > s && (r = Math.min(r, i / (i - s))), 0 > o ? n = Math.max(n, o / (o - u)) : 0 > u && (r = Math.min(r, o / (o - u))), r < n ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0))
		}
		var s, o, u = [],
			a = 0,
			f, l, c = [],
			h = 0,
			p, d, v = [],
			m = 0,
			g, y, b = [],
			w = 0,
			E, S, x = [],
			T = 0,
			N = {
				objects: [],
				lights: [],
				elements: []
			},
			C = new THREE.Vector3,
			k = new THREE.Vector3,
			L = new THREE.Vector3,
			A = new THREE.Vector3,
			O = new THREE.Vector4,
			M = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
			_ = new THREE.Box3,
			D = Array(3),
			P = new THREE.Matrix4,
			H = new THREE.Matrix4,
			B, j = new THREE.Matrix4,
			F = new THREE.Matrix3,
			I = new THREE.Frustum,
			q = new THREE.Vector4,
			R = new THREE.Vector4;
		this.projectVector = function(e, t) {
			return t.matrixWorldInverse.getInverse(t.matrixWorld), H.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), e.applyProjection(H)
		}, this.unprojectVector = function() {
			var e = new THREE.Matrix4;
			return function(t, n) {
				return e.getInverse(n.projectionMatrix), H.multiplyMatrices(n.matrixWorld, e), t.applyProjection(H)
			}
		}(), this.pickingRay = function(e, t) {
			e.z = -1;
			var n = new THREE.Vector3(e.x, e.y, 1);
			return this.unprojectVector(e, t), this.unprojectVector(n, t), n.sub(e).normalize(), new THREE.Raycaster(e, n)
		};
		var U = function(e) {
				if (!1 !== e.visible) {
					if (e instanceof THREE.Light) N.lights.push(e);
					else if (e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Sprite)
						if (!1 === e.frustumCulled || !0 === I.intersectsObject(e)) {
							if (o === a) {
								var t = new THREE.RenderableObject;
								u.push(t), a++, o++, s = t
							} else s = u[o++];
							s.id = e.id, s.object = e, null !== e.renderDepth ? s.z = e.renderDepth : (A.setFromMatrixPosition(e.matrixWorld), A.applyProjection(H), s.z = A.z), N.objects.push(s)
						} for (var t = 0, n = e.children.length; t < n; t++) U(e.children[t])
				}
			},
			z = new function() {
				var r = [],
					i = null,
					s = new THREE.Matrix3,
					o = function(e) {
						var t = e.positionWorld,
							n = e.positionScreen;
						t.copy(e.position).applyMatrix4(B), n.copy(t).applyMatrix4(H), t = 1 / n.w, n.x *= t, n.y *= t, n.z *= t, e.visible = -1 <= n.x && 1 >= n.x && -1 <= n.y && 1 >= n.y && -1 <= n.z && 1 >= n.z
					},
					u = function(e, t, n) {
						return D[0] = e.positionScreen, D[1] = t.positionScreen, D[2] = n.positionScreen, !0 === e.visible || !0 === t.visible || !0 === n.visible || M.isIntersectionBox(_.setFromPoints(D)) ? 0 > (n.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (n.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x) : !1
					};
				return {
					setObject: function(e) {
						i = e, s.getNormalMatrix(i.matrixWorld), r.length = 0
					},
					projectVertex: o,
					checkTriangleVisibility: u,
					pushVertex: function(t, n, r) {
						f = e(), f.position.set(t, n, r), o(f)
					},
					pushNormal: function(e, t, n) {
						r.push(e, t, n)
					},
					pushLine: function(e, t) {
						var r = c[e],
							s = c[t];
						g = n(), g.id = i.id, g.v1.copy(r), g.v2.copy(s), g.z = (r.positionScreen.z + s.positionScreen.z) / 2, g.material = i.material, N.elements.push(g)
					},
					pushTriangle: function(e, n, o) {
						var a = c[e],
							f = c[n],
							l = c[o];
						if (!0 === u(a, f, l)) {
							p = t(), p.id = i.id, p.v1.copy(a), p.v2.copy(f), p.v3.copy(l), p.z = (a.positionScreen.z + f.positionScreen.z + l.positionScreen.z) / 3;
							for (a = 0; 3 > a; a++) f = 3 * arguments[a], l = p.vertexNormalsModel[a], l.set(r[f + 0], r[f + 1], r[f + 2]), l.applyMatrix3(s).normalize();
							p.vertexNormalsLength = 3, p.material = i.material, N.elements.push(p)
						}
					}
				}
			};
		this.projectScene = function(s, u, a, f) {
			var h, v, m, b, w, A, M, _, D;
			S = y = d = 0, N.elements.length = 0, !0 === s.autoUpdate && s.updateMatrixWorld(), void 0 === u.parent && u.updateMatrixWorld(), P.copy(u.matrixWorldInverse.getInverse(u.matrixWorld)), H.multiplyMatrices(u.projectionMatrix, P), I.setFromMatrix(H), o = 0, N.objects.length = 0, N.lights.length = 0, U(s), !0 === a && N.objects.sort(r), s = 0;
			for (a = N.objects.length; s < a; s++)
				if (h = N.objects[s].object, v = h.geometry, z.setObject(h), B = h.matrixWorld, l = 0, h instanceof THREE.Mesh) {
					if (v instanceof THREE.BufferGeometry) {
						if (A = v.attributes, h = v.offsets, void 0 !== A.position) {
							_ = A.position.array, v = 0;
							for (b = _.length; v < b; v += 3) z.pushVertex(_[v], _[v + 1], _[v + 2]);
							D = A.normal.array, v = 0;
							for (b = D.length; v < b; v += 3) z.pushNormal(D[v], D[v + 1], D[v + 2]);
							if (void 0 !== A.index)
								if (A = A.index.array, 0 < h.length)
									for (s = 0; s < h.length; s++)
										for (b = h[s], _ = b.index, v = b.start, b = b.start + b.count; v < b; v += 3) z.pushTriangle(A[v] + _, A[v + 1] + _, A[v + 2] + _);
								else
									for (v = 0, b = A.length; v < b; v += 3) z.pushTriangle(A[v], A[v + 1], A[v + 2]);
							else
								for (v = 0, b = _.length / 3; v < b; v += 3) z.pushTriangle(v, v + 1, v + 2)
						}
					} else if (v instanceof THREE.Geometry) {
						m = v.vertices, b = v.faces, A = v.faceVertexUvs, F.getNormalMatrix(B), _ = h.material instanceof THREE.MeshFaceMaterial, D = !0 === _ ? h.material : null;
						for (var X = 0, $ = m.length; X < $; X++) {
							var Z = m[X];
							z.pushVertex(Z.x, Z.y, Z.z)
						}
						X = 0;
						for ($ = b.length; X < $; X++) {
							m = b[X];
							var et = !0 === _ ? D.materials[m.materialIndex] : h.material;
							if (void 0 !== et) {
								M = et.side;
								var Z = c[m.a],
									tt = c[m.b],
									nt = c[m.c];
								if (!0 === et.morphTargets) {
									w = v.morphTargets;
									var rt = h.morphTargetInfluences,
										it = Z.position,
										st = tt.position,
										ot = nt.position;
									C.set(0, 0, 0), k.set(0, 0, 0), L.set(0, 0, 0);
									for (var ut = 0, at = w.length; ut < at; ut++) {
										var ft = rt[ut];
										if (0 !== ft) {
											var lt = w[ut].vertices;
											C.x += (lt[m.a].x - it.x) * ft, C.y += (lt[m.a].y - it.y) * ft, C.z += (lt[m.a].z - it.z) * ft, k.x += (lt[m.b].x - st.x) * ft, k.y += (lt[m.b].y - st.y) * ft, k.z += (lt[m.b].z - st.z) * ft, L.x += (lt[m.c].x - ot.x) * ft, L.y += (lt[m.c].y - ot.y) * ft, L.z += (lt[m.c].z - ot.z) * ft
										}
									}
									Z.position.add(C), tt.position.add(k), nt.position.add(L), z.projectVertex(Z), z.projectVertex(tt), z.projectVertex(nt)
								}
								rt = z.checkTriangleVisibility(Z, tt, nt);
								if (!(!1 === rt && M === THREE.FrontSide || !0 === rt && M === THREE.BackSide)) {
									p = t(), p.id = h.id, p.v1.copy(Z), p.v2.copy(tt), p.v3.copy(nt), p.normalModel.copy(m.normal), !1 !== rt || M !== THREE.BackSide && M !== THREE.DoubleSide || p.normalModel.negate(), p.normalModel.applyMatrix3(F).normalize(), p.centroidModel.copy(m.centroid).applyMatrix4(B), w = m.vertexNormals, it = 0;
									for (st = Math.min(w.length, 3); it < st; it++) ot = p.vertexNormalsModel[it], ot.copy(w[it]), !1 !== rt || M !== THREE.BackSide && M !== THREE.DoubleSide || ot.negate(), ot.applyMatrix3(F).normalize();
									p.vertexNormalsLength = w.length, w = 0;
									for (rt = Math.min(A.length, 3); w < rt; w++)
										if (M = A[w][X], void 0 !== M)
											for (it = 0, st = M.length; it < st; it++) p.uvs[w][it] = M[it];
									p.color = m.color, p.material = et, p.z = (Z.positionScreen.z + tt.positionScreen.z + nt.positionScreen.z) / 3, N.elements.push(p)
								}
							}
						}
					}
				} else if (h instanceof THREE.Line) {
				if (v instanceof THREE.BufferGeometry) {
					if (A = v.attributes, void 0 !== A.position) {
						_ = A.position.array, v = 0;
						for (b = _.length; v < b; v += 3) z.pushVertex(_[v], _[v + 1], _[v + 2]);
						if (void 0 !== A.index)
							for (A = A.index.array, v = 0, b = A.length; v < b; v += 2) z.pushLine(A[v], A[v + 1]);
						else
							for (v = 0, b = _.length / 3 - 1; v < b; v++) z.pushLine(v, v + 1)
					}
				} else if (v instanceof THREE.Geometry && (j.multiplyMatrices(H, B), m = h.geometry.vertices, 0 !== m.length))
					for (Z = e(), Z.positionScreen.copy(m[0]).applyMatrix4(j), v = h.type === THREE.LinePieces ? 2 : 1, X = 1, $ = m.length; X < $; X++) Z = e(), Z.positionScreen.copy(m[X]).applyMatrix4(j), 0 < (X + 1) % v || (tt = c[l - 2], q.copy(Z.positionScreen), R.copy(tt.positionScreen), !0 === i(q, R) && (q.multiplyScalar(1 / q.w), R.multiplyScalar(1 / R.w), g = n(), g.id = h.id, g.v1.positionScreen.copy(q), g.v2.positionScreen.copy(R), g.z = Math.max(q.z, R.z), g.material = h.material, h.material.vertexColors === THREE.VertexColors && (g.vertexColors[0].copy(h.geometry.colors[X]), g.vertexColors[1].copy(h.geometry.colors[X - 1])), N.elements.push(g)))
			} else h instanceof THREE.Sprite && (O.set(B.elements[12], B.elements[13], B.elements[14], 1), O.applyMatrix4(H), v = 1 / O.w, O.z *= v, -1 <= O.z && 1 >= O.z && (S === T ? (b = new THREE.RenderableSprite, x.push(b), T++, S++, E = b) : E = x[S++], E.id = h.id, E.x = O.x * v, E.y = O.y * v, E.z = O.z, E.object = h, E.rotation = h.rotation, E.scale.x = h.scale.x * Math.abs(E.x - (O.x + u.projectionMatrix.elements[0]) / (O.w + u.projectionMatrix.elements[12])), E.scale.y = h.scale.y * Math.abs(E.y - (O.y + u.projectionMatrix.elements[5]) / (O.w + u.projectionMatrix.elements[13])), E.material = h.material, N.elements.push(E)));
			return !0 === f && N.elements.sort(r), N
		}
	}, THREE.Face3 = function(e, t, n, r, i, s) {
		this.a = e, this.b = t, this.c = n, this.normal = r instanceof THREE.Vector3 ? r : new THREE.Vector3, this.vertexNormals = r instanceof Array ? r : [], this.color = i instanceof THREE.Color ? i : new THREE.Color, this.vertexColors = i instanceof Array ? i : [], this.vertexTangents = [], this.materialIndex = void 0 !== s ? s : 0, this.centroid = new THREE.Vector3
	}, THREE.Face3.prototype = {
		constructor: THREE.Face3,
		clone: function() {
			var e = new THREE.Face3(this.a, this.b, this.c);
			e.normal.copy(this.normal), e.color.copy(this.color), e.centroid.copy(this.centroid), e.materialIndex = this.materialIndex;
			var t, n;
			t = 0;
			for (n = this.vertexNormals.length; t < n; t++) e.vertexNormals[t] = this.vertexNormals[t].clone();
			t = 0;
			for (n = this.vertexColors.length; t < n; t++) e.vertexColors[t] = this.vertexColors[t].clone();
			t = 0;
			for (n = this.vertexTangents.length; t < n; t++) e.vertexTangents[t] = this.vertexTangents[t].clone();
			return e
		}
	}, THREE.Face4 = function(e, t, n, r, i, s, o) {
		return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new THREE.Face3(e, t, n, i, s, o)
	}, THREE.BufferGeometry = function() {
		this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.attributes = {}, this.offsets = [], this.boundingSphere = this.boundingBox = null
	}, THREE.BufferGeometry.prototype = {
		constructor: THREE.BufferGeometry,
		addAttribute: function(e, t, n, r) {
			return this.attributes[e] = {
				array: new t(n * r),
				itemSize: r
			}, this.attributes[e]
		},
		applyMatrix: function(e) {
			var t = this.attributes.position;
			void 0 !== t && (e.multiplyVector3Array(t.array), t.needsUpdate = !0), t = this.attributes.normal, void 0 !== t && ((new THREE.Matrix3).getNormalMatrix(e).multiplyVector3Array(t.array), t.needsUpdate = !0)
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new THREE.Box3);
			var e = this.attributes.position.array;
			if (e) {
				var t = this.boundingBox;
				3 <= e.length && (t.min.x = t.max.x = e[0], t.min.y = t.max.y = e[1], t.min.z = t.max.z = e[2]);
				for (var n = 3, r = e.length; n < r; n += 3) {
					var i = e[n],
						s = e[n + 1],
						o = e[n + 2];
					i < t.min.x ? t.min.x = i : i > t.max.x && (t.max.x = i), s < t.min.y ? t.min.y = s : s > t.max.y && (t.max.y = s), o < t.min.z ? t.min.z = o : o > t.max.z && (t.max.z = o)
				}
			}
			if (void 0 === e || 0 === e.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)
		},
		computeBoundingSphere: function() {
			var e = new THREE.Box3,
				t = new THREE.Vector3;
			return function() {
				null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
				var n = this.attributes.position.array;
				if (n) {
					e.makeEmpty();
					for (var r = this.boundingSphere.center, i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), e.addPoint(t);
					e.center(r);
					for (var o = 0, i = 0, s = n.length; i < s; i += 3) t.set(n[i], n[i + 1], n[i + 2]), o = Math.max(o, r.distanceToSquared(t));
					this.boundingSphere.radius = Math.sqrt(o)
				}
			}
		}(),
		computeVertexNormals: function() {
			if (this.attributes.position) {
				var e, t, n, r;
				e = this.attributes.position.array.length;
				if (void 0 === this.attributes.normal) this.attributes.normal = {
					itemSize: 3,
					array: new Float32Array(e)
				};
				else
					for (e = 0, t = this.attributes.normal.array.length; e < t; e++) this.attributes.normal.array[e] = 0;
				var i = this.attributes.position.array,
					s = this.attributes.normal.array,
					o, u, a, f, l, c, h = new THREE.Vector3,
					p = new THREE.Vector3,
					d = new THREE.Vector3,
					v = new THREE.Vector3,
					m = new THREE.Vector3;
				if (this.attributes.index) {
					var g = this.attributes.index.array,
						y = this.offsets;
					n = 0;
					for (r = y.length; n < r; ++n) {
						t = y[n].start, o = y[n].count;
						var b = y[n].index;
						e = t;
						for (t += o; e < t; e += 3) o = b + g[e], u = b + g[e + 1], a = b + g[e + 2], f = i[3 * o], l = i[3 * o + 1], c = i[3 * o + 2], h.set(f, l, c), f = i[3 * u], l = i[3 * u + 1], c = i[3 * u + 2], p.set(f, l, c), f = i[3 * a], l = i[3 * a + 1], c = i[3 * a + 2], d.set(f, l, c), v.subVectors(d, p), m.subVectors(h, p), v.cross(m), s[3 * o] += v.x, s[3 * o + 1] += v.y, s[3 * o + 2] += v.z, s[3 * u] += v.x, s[3 * u + 1] += v.y, s[3 * u + 2] += v.z, s[3 * a] += v.x, s[3 * a + 1] += v.y, s[3 * a + 2] += v.z
					}
				} else
					for (e = 0, t = i.length; e < t; e += 9) f = i[e], l = i[e + 1], c = i[e + 2], h.set(f, l, c), f = i[e + 3], l = i[e + 4], c = i[e + 5], p.set(f, l, c), f = i[e + 6], l = i[e + 7], c = i[e + 8], d.set(f, l, c), v.subVectors(d, p), m.subVectors(h, p), v.cross(m), s[e] = v.x, s[e + 1] = v.y, s[e + 2] = v.z, s[e + 3] = v.x, s[e + 4] = v.y, s[e + 5] = v.z, s[e + 6] = v.x, s[e + 7] = v.y, s[e + 8] = v.z;
				this.normalizeNormals(), this.normalsNeedUpdate = !0
			}
		},
		normalizeNormals: function() {
			for (var e = this.attributes.normal.array, t, n, r, i = 0, s = e.length; i < s; i += 3) t = e[i], n = e[i + 1], r = e[i + 2], t = 1 / Math.sqrt(t * t + n * n + r * r), e[i] *= t, e[i + 1] *= t, e[i + 2] *= t
		},
		computeTangents: function() {
			function e(e, t, n) {
				c = r[3 * e], h = r[3 * e + 1], p = r[3 * e + 2], d = r[3 * t], v = r[3 * t + 1], m = r[3 * t + 2], g = r[3 * n], y = r[3 * n + 1], b = r[3 * n + 2], w = s[2 * e], E = s[2 * e + 1], S = s[2 * t], x = s[2 * t + 1], T = s[2 * n], N = s[2 * n + 1], C = d - c, k = g - c, L = v - h, A = y - h, O = m - p, M = b - p, _ = S - w, D = T - w, P = x - E, H = N - E, B = 1 / (_ * H - D * P), j.set((H * C - P * k) * B, (H * L - P * A) * B, (H * O - P * M) * B), F.set((_ * k - D * C) * B, (_ * A - D * L) * B, (_ * M - D * O) * B), a[e].add(j), a[t].add(j), a[n].add(j), f[e].add(F), f[t].add(F), f[n].add(F)
			}

			function t(e) {
				J.x = i[3 * e], J.y = i[3 * e + 1], J.z = i[3 * e + 2], K.copy(J), G = a[e], V.copy(G), V.sub(J.multiplyScalar(J.dot(G))).normalize(), $.crossVectors(K, G), Y = $.dot(f[e]), Q = 0 > Y ? -1 : 1, u[4 * e] = V.x, u[4 * e + 1] = V.y, u[4 * e + 2] = V.z, u[4 * e + 3] = Q
			}
			if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
			else {
				var n = this.attributes.index.array,
					r = this.attributes.position.array,
					i = this.attributes.normal.array,
					s = this.attributes.uv.array,
					o = r.length / 3;
				void 0 === this.attributes.tangent && (this.attributes.tangent = {
					itemSize: 4,
					array: new Float32Array(4 * o)
				});
				for (var u = this.attributes.tangent.array, a = [], f = [], l = 0; l < o; l++) a[l] = new THREE.Vector3, f[l] = new THREE.Vector3;
				var c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D, P, H, B, j = new THREE.Vector3,
					F = new THREE.Vector3,
					I, q, R, U, z, W = this.offsets,
					l = 0;
				for (q = W.length; l < q; ++l) {
					I = W[l].start, R = W[l].count;
					var X = W[l].index,
						o = I;
					for (I += R; o < I; o += 3) R = X + n[o], U = X + n[o + 1], z = X + n[o + 2], e(R, U, z)
				}
				var V = new THREE.Vector3,
					$ = new THREE.Vector3,
					J = new THREE.Vector3,
					K = new THREE.Vector3,
					Q, G, Y, l = 0;
				for (q = W.length; l < q; ++l)
					for (I = W[l].start, R = W[l].count, X = W[l].index, o = I, I += R; o < I; o += 3) R = X + n[o], U = X + n[o + 1], z = X + n[o + 2], t(R), t(U), t(z)
			}
		},
		computeOffsets: function(e) {
			var t = e;
			void 0 === e && (t = 65535), Date.now(), e = this.attributes.index.array;
			for (var n = this.attributes.position.array, r = e.length / 3, i = new Uint16Array(e.length), s = 0, o = 0, u = [{
					start: 0,
					count: 0,
					index: 0
				}], a = u[0], f = 0, l = 0, c = new Int32Array(6), h = new Int32Array(n.length), p = new Int32Array(n.length), d = 0; d < n.length; d++) h[d] = -1, p[d] = -1;
			for (n = 0; n < r; n++) {
				for (var v = l = 0; 3 > v; v++) d = e[3 * n + v], -1 == h[d] ? (c[2 * v] = d, c[2 * v + 1] = -1, l++) : h[d] < a.index ? (c[2 * v] = d, c[2 * v + 1] = -1, f++) : (c[2 * v] = d, c[2 * v + 1] = h[d]);
				if (o + l > a.index + t)
					for (a = {
							start: s,
							count: 0,
							index: o
						}, u.push(a), l = 0; 6 > l; l += 2) v = c[l + 1], -1 < v && v < a.index && (c[l + 1] = -1);
				for (l = 0; 6 > l; l += 2) d = c[l], v = c[l + 1], -1 === v && (v = o++), h[d] = v, p[v] = d, i[s++] = v - a.index, a.count++
			}
			return this.reorderBuffers(i, p, o), this.offsets = u
		},
		reorderBuffers: function(e, t, n) {
			var r = {},
				i = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
				s;
			for (s in this.attributes)
				if ("index" != s)
					for (var o = this.attributes[s].array, u = 0, a = i.length; u < a; u++) {
						var f = i[u];
						if (o instanceof f) {
							r[s] = new f(this.attributes[s].itemSize * n);
							break
						}
					}
			for (i = 0; i < n; i++)
				for (s in o = t[i], this.attributes)
					if ("index" != s)
						for (var u = this.attributes[s].array, a = this.attributes[s].itemSize, f = r[s], l = 0; l < a; l++) f[i * a + l] = u[o * a + l];
			this.attributes.index.array = e;
			for (s in this.attributes) "index" != s && (this.attributes[s].array = r[s], this.attributes[s].numItems = this.attributes[s].itemSize * n)
		},
		clone: function() {
			var e = new THREE.BufferGeometry,
				t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array],
				n;
			for (n in this.attributes) {
				for (var r = this.attributes[n], i = r.array, s = {
						itemSize: r.itemSize,
						array: null
					}, r = 0, o = t.length; r < o; r++) {
					var u = t[r];
					if (i instanceof u) {
						s.array = new u(i);
						break
					}
				}
				e.attributes[n] = s
			}
			r = 0;
			for (o = this.offsets.length; r < o; r++) t = this.offsets[r], e.offsets.push({
				start: t.start,
				index: t.index,
				count: t.count
			});
			return e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype), THREE.Geometry = function() {
		this.id = THREE.GeometryIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
			[]
		], this.morphTargets = [], this.morphColors = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.hasTangents = !1, this.dynamic = !0, this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
	}, THREE.Geometry.prototype = {
		constructor: THREE.Geometry,
		applyMatrix: function(e) {
			for (var t = (new THREE.Matrix3).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(e);
			n = 0;
			for (r = this.faces.length; n < r; n++) {
				var i = this.faces[n];
				i.normal.applyMatrix3(t).normalize();
				for (var s = 0, o = i.vertexNormals.length; s < o; s++) i.vertexNormals[s].applyMatrix3(t).normalize();
				i.centroid.applyMatrix4(e)
			}
			this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox(), this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
		},
		computeCentroids: function() {
			var e, t, n;
			e = 0;
			for (t = this.faces.length; e < t; e++) n = this.faces[e], n.centroid.set(0, 0, 0), n.centroid.add(this.vertices[n.a]), n.centroid.add(this.vertices[n.b]), n.centroid.add(this.vertices[n.c]), n.centroid.divideScalar(3)
		},
		computeFaceNormals: function() {
			for (var e = new THREE.Vector3, t = new THREE.Vector3, n = 0, r = this.faces.length; n < r; n++) {
				var i = this.faces[n],
					s = this.vertices[i.a],
					o = this.vertices[i.b];
				e.subVectors(this.vertices[i.c], o), t.subVectors(s, o), e.cross(t), e.normalize(), i.normal.copy(e)
			}
		},
		computeVertexNormals: function(e) {
			var t, n, r;
			r = Array(this.vertices.length), t = 0;
			for (n = this.vertices.length; t < n; t++) r[t] = new THREE.Vector3;
			if (e) {
				var i, s, o, u = new THREE.Vector3,
					a = new THREE.Vector3;
				new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, e = 0;
				for (t = this.faces.length; e < t; e++) n = this.faces[e], i = this.vertices[n.a], s = this.vertices[n.b], o = this.vertices[n.c], u.subVectors(o, s), a.subVectors(i, s), u.cross(a), r[n.a].add(u), r[n.b].add(u), r[n.c].add(u)
			} else
				for (e = 0, t = this.faces.length; e < t; e++) n = this.faces[e], r[n.a].add(n.normal), r[n.b].add(n.normal), r[n.c].add(n.normal);
			t = 0;
			for (n = this.vertices.length; t < n; t++) r[t].normalize();
			e = 0;
			for (t = this.faces.length; e < t; e++) n = this.faces[e], n.vertexNormals[0] = r[n.a].clone(), n.vertexNormals[1] = r[n.b].clone(), n.vertexNormals[2] = r[n.c].clone()
		},
		computeMorphNormals: function() {
			var e, t, n, r, i;
			n = 0;
			for (r = this.faces.length; n < r; n++)
				for (i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
			var s = new THREE.Geometry;
			s.faces = this.faces, e = 0;
			for (t = this.morphTargets.length; e < t; e++) {
				if (!this.morphNormals[e]) {
					this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [], i = this.morphNormals[e].faceNormals;
					var o = this.morphNormals[e].vertexNormals,
						u, a;
					n = 0;
					for (r = this.faces.length; n < r; n++) u = new THREE.Vector3, a = {
						a: new THREE.Vector3,
						b: new THREE.Vector3,
						c: new THREE.Vector3
					}, i.push(u), o.push(a)
				}
				o = this.morphNormals[e], s.vertices = this.morphTargets[e].vertices, s.computeFaceNormals(), s.computeVertexNormals(), n = 0;
				for (r = this.faces.length; n < r; n++) i = this.faces[n], u = o.faceNormals[n], a = o.vertexNormals[n], u.copy(i.normal), a.a.copy(i.vertexNormals[0]), a.b.copy(i.vertexNormals[1]), a.c.copy(i.vertexNormals[2])
			}
			n = 0;
			for (r = this.faces.length; n < r; n++) i = this.faces[n], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
		},
		computeTangents: function() {
			var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g = [],
				y = [];
			n = new THREE.Vector3;
			var b = new THREE.Vector3,
				w = new THREE.Vector3,
				E = new THREE.Vector3,
				S = new THREE.Vector3;
			e = 0;
			for (t = this.vertices.length; e < t; e++) g[e] = new THREE.Vector3, y[e] = new THREE.Vector3;
			e = 0;
			for (t = this.faces.length; e < t; e++) i = this.faces[e], s = this.faceVertexUvs[0][e], r = i.a, m = i.b, i = i.c, o = this.vertices[r], u = this.vertices[m], a = this.vertices[i], f = s[0], l = s[1], c = s[2], s = u.x - o.x, h = a.x - o.x, p = u.y - o.y, d = a.y - o.y, u = u.z - o.z, o = a.z - o.z, a = l.x - f.x, v = c.x - f.x, l = l.y - f.y, f = c.y - f.y, c = 1 / (a * f - v * l), n.set((f * s - l * h) * c, (f * p - l * d) * c, (f * u - l * o) * c), b.set((a * h - v * s) * c, (a * d - v * p) * c, (a * o - v * u) * c), g[r].add(n), g[m].add(n), g[i].add(n), y[r].add(b), y[m].add(b), y[i].add(b);
			b = ["a", "b", "c", "d"], e = 0;
			for (t = this.faces.length; e < t; e++)
				for (i = this.faces[e], n = 0; n < Math.min(i.vertexNormals.length, 3); n++) S.copy(i.vertexNormals[n]), r = i[b[n]], m = g[r], w.copy(m), w.sub(S.multiplyScalar(S.dot(m))).normalize(), E.crossVectors(i.vertexNormals[n], m), r = E.dot(y[r]), r = 0 > r ? -1 : 1, i.vertexTangents[n] = new THREE.Vector4(w.x, w.y, w.z, r);
			this.hasTangents = !0
		},
		computeLineDistances: function() {
			for (var e = 0, t = this.vertices, n = 0, r = t.length; n < r; n++) 0 < n && (e += t[n].distanceTo(t[n - 1])), this.lineDistances[n] = e
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new THREE.Box3), this.boundingBox.setFromPoints(this.vertices)
		},
		computeBoundingSphere: function() {
			null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), this.boundingSphere.setFromPoints(this.vertices)
		},
		mergeVertices: function() {
			var e = {},
				t = [],
				n = [],
				r, i = Math.pow(10, 4),
				s, o;
			s = 0;
			for (o = this.vertices.length; s < o; s++) r = this.vertices[s], r = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i), void 0 === e[r] ? (e[r] = s, t.push(this.vertices[s]), n[s] = t.length - 1) : n[s] = n[e[r]];
			e = [], s = 0;
			for (o = this.faces.length; s < o; s++)
				for (i = this.faces[s], i.a = n[i.a], i.b = n[i.b], i.c = n[i.c], i = [i.a, i.b, i.c], r = 0; 3 > r; r++)
					if (i[r] == i[(r + 1) % 3]) {
						e.push(s);
						break
					} for (s = e.length - 1; 0 <= s; s--)
				for (i = e[s], this.faces.splice(i, 1), n = 0, o = this.faceVertexUvs.length; n < o; n++) this.faceVertexUvs[n].splice(i, 1);
			return s = this.vertices.length - t.length, this.vertices = t, s
		},
		makeGroups: function() {
			var e = 0;
			return function(t) {
				var n, r, i, s, o = {},
					u = this.morphTargets.length,
					f = this.morphNormals.length;
				this.geometryGroups = {}, n = 0;
				for (r = this.faces.length; n < r; n++) i = this.faces[n], i = t ? i.materialIndex : 0, i in o || (o[i] = {
					hash: i,
					counter: 0
				}), s = o[i].hash + "_" + o[i].counter, s in this.geometryGroups || (this.geometryGroups[s] = {
					faces3: [],
					materialIndex: i,
					vertices: 0,
					numMorphTargets: u,
					numMorphNormals: f
				}), 65535 < this.geometryGroups[s].vertices + 3 && (o[i].counter += 1, s = o[i].hash + "_" + o[i].counter, s in this.geometryGroups || (this.geometryGroups[s] = {
					faces3: [],
					materialIndex: i,
					vertices: 0,
					numMorphTargets: u,
					numMorphNormals: f
				})), this.geometryGroups[s].faces3.push(n), this.geometryGroups[s].vertices += 3;
				this.geometryGroupsList = [];
				for (var l in this.geometryGroups) this.geometryGroups[l].id = e++, this.geometryGroupsList.push(this.geometryGroups[l])
			}
		}(),
		clone: function() {
			for (var e = new THREE.Geometry, t = this.vertices, n = 0, r = t.length; n < r; n++) e.vertices.push(t[n].clone());
			t = this.faces, n = 0;
			for (r = t.length; n < r; n++) e.faces.push(t[n].clone());
			t = this.faceVertexUvs[0], n = 0;
			for (r = t.length; n < r; n++) {
				for (var i = t[n], s = [], o = 0, u = i.length; o < u; o++) s.push(new THREE.Vector2(i[o].x, i[o].y));
				e.faceVertexUvs[0].push(s)
			}
			return e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype), THREE.GeometryIdCount = 0, THREE.Geometry2 = function(e) {
		THREE.BufferGeometry.call(this), this.vertices = this.addAttribute("position", Float32Array, e, 3).array, this.normals = this.addAttribute("normal", Float32Array, e, 3).array, this.uvs = this.addAttribute("uv", Float32Array, e, 2).array, this.boundingSphere = this.boundingBox = null
	}, THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype), THREE.Camera = function() {
		THREE.Object3D.call(this), this.matrixWorldInverse = new THREE.Matrix4, this.projectionMatrix = new THREE.Matrix4
	}, THREE.Camera.prototype = Object.create(THREE.Object3D.prototype), THREE.Camera.prototype.lookAt = function() {
		var e = new THREE.Matrix4;
		return function(t) {
			e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
		}
	}(), THREE.Camera.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Camera), THREE.Object3D.prototype.clone.call(this, e), e.matrixWorldInverse.copy(this.matrixWorldInverse), e.projectionMatrix.copy(this.projectionMatrix), e
	}, THREE.OrthographicCamera = function(e, t, n, r, i, s) {
		THREE.Camera.call(this), this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = void 0 !== i ? i : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
	}, THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype), THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
		this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
	}, THREE.OrthographicCamera.prototype.clone = function() {
		var e = new THREE.OrthographicCamera;
		return THREE.Camera.prototype.clone.call(this, e), e.left = this.left, e.right = this.right, e.top = this.top, e.bottom = this.bottom, e.near = this.near, e.far = this.far, e
	}, THREE.PerspectiveCamera = function(e, t, n, r) {
		THREE.Camera.call(this), this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype), THREE.PerspectiveCamera.prototype.setLens = function(e, t) {
		void 0 === t && (t = 24), this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype.setViewOffset = function(e, t, n, r, i, s) {
		this.fullWidth = e, this.fullHeight = t, this.x = n, this.y = r, this.width = i, this.height = s, this.updateProjectionMatrix()
	}, THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
		if (this.fullWidth) {
			var e = this.fullWidth / this.fullHeight,
				t = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near,
				n = -t,
				r = e * n,
				e = Math.abs(e * t - r),
				n = Math.abs(t - n);
			this.projectionMatrix.makeFrustum(r + this.x * e / this.fullWidth, r + (this.x + this.width) * e / this.fullWidth, t - (this.y + this.height) * n / this.fullHeight, t - this.y * n / this.fullHeight, this.near, this.far)
		} else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
	}, THREE.PerspectiveCamera.prototype.clone = function() {
		var e = new THREE.PerspectiveCamera;
		return THREE.Camera.prototype.clone.call(this, e), e.fov = this.fov, e.aspect = this.aspect, e.near = this.near, e.far = this.far, e
	}, THREE.Light = function(e) {
		THREE.Object3D.call(this), this.color = new THREE.Color(e)
	}, THREE.Light.prototype = Object.create(THREE.Object3D.prototype), THREE.Light.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Light), THREE.Object3D.prototype.clone.call(this, e), e.color.copy(this.color), e
	}, THREE.AmbientLight = function(e) {
		THREE.Light.call(this, e)
	}, THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype), THREE.AmbientLight.prototype.clone = function() {
		var e = new THREE.AmbientLight;
		return THREE.Light.prototype.clone.call(this, e), e
	}, THREE.AreaLight = function(e, t) {
		THREE.Light.call(this, e), this.normal = new THREE.Vector3(0, -1, 0), this.right = new THREE.Vector3(1, 0, 0), this.intensity = void 0 !== t ? t : 1, this.height = this.width = 1, this.constantAttenuation = 1.5, this.linearAttenuation = .5, this.quadraticAttenuation = .1
	}, THREE.AreaLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight = function(e, t) {
		THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraLeft = -500, this.shadowCameraTop = this.shadowCameraRight = 500, this.shadowCameraBottom = -500, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowCascade = !1, this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1e3), this.shadowCascadeCount = 2, this.shadowCascadeBias = [0, 0, 0], this.shadowCascadeWidth = [512, 512, 512], this.shadowCascadeHeight = [512, 512, 512], this.shadowCascadeNearZ = [-1, .99, .998], this.shadowCascadeFarZ = [.99, .998, 1], this.shadowCascadeArray = [], this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
	}, THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype), THREE.DirectionalLight.prototype.clone = function() {
		var e = new THREE.DirectionalLight;
		return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e
	}, THREE.HemisphereLight = function(e, t, n) {
		THREE.Light.call(this, e), this.position.set(0, 100, 0), this.groundColor = new THREE.Color(t), this.intensity = void 0 !== n ? n : 1
	}, THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype), THREE.HemisphereLight.prototype.clone = function() {
		var e = new THREE.HemisphereLight;
		return THREE.Light.prototype.clone.call(this, e), e.groundColor.copy(this.groundColor), e.intensity = this.intensity, e
	}, THREE.PointLight = function(e, t, n) {
		THREE.Light.call(this, e), this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0
	}, THREE.PointLight.prototype = Object.create(THREE.Light.prototype), THREE.PointLight.prototype.clone = function() {
		var e = new THREE.PointLight;
		return THREE.Light.prototype.clone.call(this, e), e.intensity = this.intensity, e.distance = this.distance, e
	}, THREE.SpotLight = function(e, t, n, r, i) {
		THREE.Light.call(this, e), this.position.set(0, 1, 0), this.target = new THREE.Object3D, this.intensity = void 0 !== t ? t : 1, this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.exponent = void 0 !== i ? i : 10, this.onlyShadow = this.castShadow = !1, this.shadowCameraNear = 50, this.shadowCameraFar = 5e3, this.shadowCameraFov = 50, this.shadowCameraVisible = !1, this.shadowBias = 0, this.shadowDarkness = .5, this.shadowMapHeight = this.shadowMapWidth = 512, this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
	}, THREE.SpotLight.prototype = Object.create(THREE.Light.prototype), THREE.SpotLight.prototype.clone = function() {
		var e = new THREE.SpotLight;
		return THREE.Light.prototype.clone.call(this, e), e.target = this.target.clone(), e.intensity = this.intensity, e.distance = this.distance, e.angle = this.angle, e.exponent = this.exponent, e.castShadow = this.castShadow, e.onlyShadow = this.onlyShadow, e
	}, THREE.Loader = function(e) {
		this.statusDomElement = (this.showStatus = e) ? THREE.Loader.prototype.addStatusElement() : null, this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
	}, THREE.Loader.prototype = {
		constructor: THREE.Loader,
		crossOrigin: void 0,
		addStatusElement: function() {
			var e = document.createElement("div");
			return e.style.position = "absolute", e.style.right = "0px", e.style.top = "0px", e.style.fontSize = "0.8em", e.style.textAlign = "left", e.style.background = "rgba(0,0,0,0.25)", e.style.color = "#fff", e.style.width = "120px", e.style.padding = "0.5em 0.5em 0.5em 0.5em", e.style.zIndex = 1e3, e.innerHTML = "Loading ...", e
		},
		updateProgress: function(e) {
			var t = "Loaded ",
				t = e.total ? t + ((100 * e.loaded / e.total).toFixed(0) + "%") : t + ((e.loaded / 1e3).toFixed(2) + " KB");
			this.statusDomElement.innerHTML = t
		},
		extractUrlBase: function(e) {
			return e = e.split("/"), 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
		},
		initMaterials: function(e, t) {
			for (var n = [], r = 0; r < e.length; ++r) n[r] = THREE.Loader.prototype.createMaterial(e[r], t);
			return n
		},
		needsTangents: function(e) {
			for (var t = 0, n = e.length; t < n; t++)
				if (e[t] instanceof THREE.ShaderMaterial) return !0;
			return !1
		},
		createMaterial: function(e, t) {
			function n(e) {
				return e = Math.log(e) / Math.LN2, Math.floor(e) == e
			}

			function r(e) {
				return e = Math.log(e) / Math.LN2, Math.pow(2, Math.round(e))
			}

			function i(e, t) {
				var i = new Image;
				i.onload = function() {
					if (n(this.width) && n(this.height)) e.image = this;
					else {
						var t = r(this.width),
							i = r(this.height);
						e.image.width = t, e.image.height = i, e.image.getContext("2d").drawImage(this, 0, 0, t, i)
					}
					e.needsUpdate = !0
				}, void 0 !== u.crossOrigin && (i.crossOrigin = u.crossOrigin), i.src = t
			}

			function s(e, n, r, s, o, u, a) {
				var f = /\.dds$/i.test(r),
					l = t + r;
				if (f) {
					var c = THREE.ImageUtils.loadCompressedTexture(l);
					e[n] = c
				} else c = document.createElement("canvas"), e[n] = new THREE.Texture(c);
				e[n].sourceFile = r, s && (e[n].repeat.set(s[0], s[1]), 1 !== s[0] && (e[n].wrapS = THREE.RepeatWrapping), 1 !== s[1] && (e[n].wrapT = THREE.RepeatWrapping)), o && e[n].offset.set(o[0], o[1]), u && (r = {
					repeat: THREE.RepeatWrapping,
					mirror: THREE.MirroredRepeatWrapping
				}, void 0 !== r[u[0]] && (e[n].wrapS = r[u[0]]), void 0 !== r[u[1]] && (e[n].wrapT = r[u[1]])), a && (e[n].anisotropy = a), f || i(e[n], l)
			}

			function o(e) {
				return (255 * e[0] << 16) + (255 * e[1] << 8) + 255 * e[2]
			}
			var u = this,
				a = "MeshLambertMaterial",
				f = {
					color: 15658734,
					opacity: 1,
					map: null,
					lightMap: null,
					normalMap: null,
					bumpMap: null,
					wireframe: !1
				};
			if (e.shading) {
				var l = e.shading.toLowerCase();
				"phong" === l ? a = "MeshPhongMaterial" : "basic" === l && (a = "MeshBasicMaterial")
			}
			void 0 !== e.blending && void 0 !== THREE[e.blending] && (f.blending = THREE[e.blending]);
			if (void 0 !== e.transparent || 1 > e.opacity) f.transparent = e.transparent;
			return void 0 !== e.depthTest && (f.depthTest = e.depthTest), void 0 !== e.depthWrite && (f.depthWrite = e.depthWrite), void 0 !== e.visible && (f.visible = e.visible), void 0 !== e.flipSided && (f.side = THREE.BackSide), void 0 !== e.doubleSided && (f.side = THREE.DoubleSide), void 0 !== e.wireframe && (f.wireframe = e.wireframe), void 0 !== e.vertexColors && ("face" === e.vertexColors ? f.vertexColors = THREE.FaceColors : e.vertexColors && (f.vertexColors = THREE.VertexColors)), e.colorDiffuse ? f.color = o(e.colorDiffuse) : e.DbgColor && (f.color = e.DbgColor), e.colorSpecular && (f.specular = o(e.colorSpecular)), e.colorAmbient && (f.ambient = o(e.colorAmbient)), e.transparency && (f.opacity = e.transparency), e.specularCoef && (f.shininess = e.specularCoef), e.mapDiffuse && t && s(f, "map", e.mapDiffuse, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy), e.mapLight && t && s(f, "lightMap", e.mapLight, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy), e.mapBump && t && s(f, "bumpMap", e.mapBump, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy), e.mapNormal && t && s(f, "normalMap", e.mapNormal, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy), e.mapSpecular && t && s(f, "specularMap", e.mapSpecular, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy), e.mapBumpScale && (f.bumpScale = e.mapBumpScale), e.mapNormal ? (a = THREE.ShaderLib.normalmap, l = THREE.UniformsUtils.clone(a.uniforms), l.tNormal.value = f.normalMap, e.mapNormalFactor && l.uNormalScale.value.set(e.mapNormalFactor, e.mapNormalFactor), f.map && (l.tDiffuse.value = f.map, l.enableDiffuse.value = !0), f.specularMap && (l.tSpecular.value = f.specularMap, l.enableSpecular.value = !0), f.lightMap && (l.tAO.value = f.lightMap, l.enableAO.value = !0), l.diffuse.value.setHex(f.color), l.specular.value.setHex(f.specular), l.ambient.value.setHex(f.ambient), l.shininess.value = f.shininess, void 0 !== f.opacity && (l.opacity.value = f.opacity), a = new THREE.ShaderMaterial({
				fragmentShader: a.fragmentShader,
				vertexShader: a.vertexShader,
				uniforms: l,
				lights: !0,
				fog: !0
			}), f.transparent && (a.transparent = !0)) : a = new THREE[a](f), void 0 !== e.DbgName && (a.name = e.DbgName), a
		}
	}, THREE.XHRLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.XHRLoader.prototype = {
		constructor: THREE.XHRLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = new XMLHttpRequest;
			void 0 !== t && s.addEventListener("load", function(n) {
				t(n.target.responseText), i.manager.itemEnd(e)
			}, !1), void 0 !== n && s.addEventListener("progress", function(e) {
				n(e)
			}, !1), void 0 !== r && s.addEventListener("error", function(e) {
				r(e)
			}, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), s.open("GET", e, !0), s.send(null), i.manager.itemStart(e)
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.ImageLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.ImageLoader.prototype = {
		constructor: THREE.ImageLoader,
		load: function(e, t, n, r) {
			var i = this,
				s = document.createElement("img");
			return void 0 !== t && s.addEventListener("load", function(n) {
				i.manager.itemEnd(e), t(this)
			}, !1), void 0 !== n && s.addEventListener("progress", function(e) {
				n(e)
			}, !1), void 0 !== r && s.addEventListener("error", function(e) {
				r(e)
			}, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), s.src = e, i.manager.itemStart(e), s
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.JSONLoader = function(e) {
		THREE.Loader.call(this, e), this.withCredentials = !1
	}, THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype), THREE.JSONLoader.prototype.load = function(e, t, n) {
		n = n && "string" == typeof n ? n : this.extractUrlBase(e), this.onLoadStart(), this.loadAjaxJSON(this, e, t, n)
	}, THREE.JSONLoader.prototype.loadAjaxJSON = function(e, t, n, r, i) {
		var s = new XMLHttpRequest,
			o = 0;
		s.onreadystatechange = function() {
			if (s.readyState === s.DONE)
				if (200 === s.status || 0 === s.status) {
					if (s.responseText) {
						var u = JSON.parse(s.responseText);
						if ("scene" === u.metadata.type) {
							console.error('THREE.JSONLoader: "' + t + '" seems to be a Scene. Use THREE.SceneLoader instead.');
							return
						}
						u = e.parse(u, r), n(u.geometry, u.materials)
					} else console.error('THREE.JSONLoader: "' + t + '" seems to be unreachable or the file is empty.');
					e.onLoadComplete()
				} else console.error("THREE.JSONLoader: Couldn't load \"" + t + '" (' + s.status + ")");
			else s.readyState === s.LOADING ? i && (0 === o && (o = s.getResponseHeader("Content-Length")), i({
				total: o,
				loaded: s.responseText.length
			})) : s.readyState === s.HEADERS_RECEIVED && void 0 !== i && (o = s.getResponseHeader("Content-Length"))
		}, s.open("GET", t, !0), s.withCredentials = this.withCredentials, s.send(null)
	}, THREE.JSONLoader.prototype.parse = function(e, t) {
		var n = new THREE.Geometry,
			r = void 0 !== e.scale ? 1 / e.scale : 1;
		return function(t) {
				var r, i, s, o, u, f, l, h, p, d, v, m, g, y = e.faces;
				f = e.vertices;
				var b = e.normals,
					w = e.colors,
					E = 0;
				if (void 0 !== e.uvs) {
					for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && E++;
					for (r = 0; r < E; r++) n.faceVertexUvs[r] = []
				}
				o = 0;
				for (u = f.length; o < u;) r = new THREE.Vector3, r.x = f[o++] * t, r.y = f[o++] * t, r.z = f[o++] * t, n.vertices.push(r);
				o = 0;
				for (u = y.length; o < u;)
					if (t = y[o++], p = t & 1, s = t & 2, r = t & 8, l = t & 16, d = t & 32, f = t & 64, t &= 128, p) {
						p = new THREE.Face3, p.a = y[o], p.b = y[o + 1], p.c = y[o + 3], v = new THREE.Face3, v.a = y[o + 1], v.b = y[o + 2], v.c = y[o + 3], o += 4, s && (s = y[o++], p.materialIndex = s, v.materialIndex = s), s = n.faces.length;
						if (r)
							for (r = 0; r < E; r++)
								for (m = e.uvs[r], n.faceVertexUvs[r][s] = [], n.faceVertexUvs[r][s + 1] = [], i = 0; 4 > i; i++) h = y[o++], g = m[2 * h], h = m[2 * h + 1], g = new THREE.Vector2(g, h), 2 !== i && n.faceVertexUvs[r][s].push(g), 0 !== i && n.faceVertexUvs[r][s + 1].push(g);
						l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]), v.normal.copy(p.normal));
						if (d)
							for (r = 0; 4 > r; r++) l = 3 * y[o++], d = new THREE.Vector3(b[l++], b[l++], b[l]), 2 !== r && p.vertexNormals.push(d), 0 !== r && v.vertexNormals.push(d);
						f && (f = y[o++], f = w[f], p.color.setHex(f), v.color.setHex(f));
						if (t)
							for (r = 0; 4 > r; r++) f = y[o++], f = w[f], 2 !== r && p.vertexColors.push(new THREE.Color(f)), 0 !== r && v.vertexColors.push(new THREE.Color(f));
						n.faces.push(p), n.faces.push(v)
					} else {
						p = new THREE.Face3, p.a = y[o++], p.b = y[o++], p.c = y[o++], s && (s = y[o++], p.materialIndex = s), s = n.faces.length;
						if (r)
							for (r = 0; r < E; r++)
								for (m = e.uvs[r], n.faceVertexUvs[r][s] = [], i = 0; 3 > i; i++) h = y[o++], g = m[2 * h], h = m[2 * h + 1], g = new THREE.Vector2(g, h), n.faceVertexUvs[r][s].push(g);
						l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]));
						if (d)
							for (r = 0; 3 > r; r++) l = 3 * y[o++], d = new THREE.Vector3(b[l++], b[l++], b[l]), p.vertexNormals.push(d);
						f && (f = y[o++], p.color.setHex(w[f]));
						if (t)
							for (r = 0; 3 > r; r++) f = y[o++], p.vertexColors.push(new THREE.Color(w[f]));
						n.faces.push(p)
					}
			}(r),
			function() {
				if (e.skinWeights)
					for (var t = 0, r = e.skinWeights.length; t < r; t += 2) n.skinWeights.push(new THREE.Vector4(e.skinWeights[t], e.skinWeights[t + 1], 0, 0));
				if (e.skinIndices)
					for (t = 0, r = e.skinIndices.length; t < r; t += 2) n.skinIndices.push(new THREE.Vector4(e.skinIndices[t], e.skinIndices[t + 1], 0, 0));
				n.bones = e.bones, n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match."), n.animation = e.animation, n.animations = e.animations
			}(),
			function(t) {
				if (void 0 !== e.morphTargets) {
					var r, i, s, o, u, f;
					r = 0;
					for (i = e.morphTargets.length; r < i; r++)
						for (n.morphTargets[r] = {}, n.morphTargets[r].name = e.morphTargets[r].name, n.morphTargets[r].vertices = [], u = n.morphTargets[r].vertices, f = e.morphTargets[r].vertices, s = 0, o = f.length; s < o; s += 3) {
							var l = new THREE.Vector3;
							l.x = f[s] * t, l.y = f[s + 1] * t, l.z = f[s + 2] * t, u.push(l)
						}
				}
				if (void 0 !== e.morphColors)
					for (r = 0, i = e.morphColors.length; r < i; r++)
						for (n.morphColors[r] = {}, n.morphColors[r].name = e.morphColors[r].name, n.morphColors[r].colors = [], o = n.morphColors[r].colors, u = e.morphColors[r].colors, t = 0, s = u.length; t < s; t += 3) f = new THREE.Color(16755200), f.setRGB(u[t], u[t + 1], u[t + 2]), o.push(f)
			}(r), n.computeCentroids(), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials ? {
				geometry: n
			} : (r = this.initMaterials(e.materials, t), this.needsTangents(r) && n.computeTangents(), {
				geometry: n,
				materials: r
			})
	}, THREE.LoadingManager = function(e, t, n) {
		var r = this,
			i = 0,
			s = 0;
		this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
			s++
		}, this.itemEnd = function(e) {
			i++, void 0 !== r.onProgress && r.onProgress(e, i, s), i === s && void 0 !== r.onLoad && r.onLoad()
		}
	}, THREE.DefaultLoadingManager = new THREE.LoadingManager, THREE.BufferGeometryLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.BufferGeometryLoader.prototype = {
		constructor: THREE.BufferGeometryLoader,
		load: function(e, t, n, r) {
			var i = this;
			n = new THREE.XHRLoader, n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = new THREE.BufferGeometry,
				n = e.attributes,
				r = e.offsets;
			e = e.boundingSphere;
			for (var i in n) {
				var s = n[i];
				t.attributes[i] = {
					itemSize: s.itemSize,
					array: new self[s.type](s.array)
				}
			}
			return void 0 !== r && (t.offsets = JSON.parse(JSON.stringify(r))), void 0 !== e && (t.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== e.center ? e.center : [0, 0, 0]), e.radius)), t
		}
	}, THREE.Geometry2Loader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.Geometry2Loader.prototype = {
		constructor: THREE.Geometry2Loader,
		load: function(e, t, n, r) {
			var i = this;
			n = new THREE.XHRLoader, n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = new THREE.Geometry2(e.vertices.length / 3),
				n = ["vertices", "normals", "uvs"],
				r = e.boundingSphere,
				i;
			for (i in n) {
				var s = n[i];
				t[s].set(e[s])
			}
			return void 0 !== r && (t.boundingSphere = new THREE.Sphere((new THREE.Vector3).fromArray(void 0 !== r.center ? r.center : [0, 0, 0]), r.radius)), t
		}
	}, THREE.MaterialLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.MaterialLoader.prototype = {
		constructor: THREE.MaterialLoader,
		load: function(e, t, n, r) {
			var i = this;
			n = new THREE.XHRLoader, n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = new THREE[e.type];
			void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.ambient && t.ambient.setHex(e.ambient), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.wireframe && (t.wireframe = e.wireframe);
			if (void 0 !== e.materials)
				for (var n = 0, r = e.materials.length; n < r; n++) t.materials.push(this.parse(e.materials[n]));
			return t
		}
	}, THREE.ObjectLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.ObjectLoader.prototype = {
		constructor: THREE.ObjectLoader,
		load: function(e, t, n, r) {
			var i = this;
			n = new THREE.XHRLoader(i.manager), n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
				t(i.parse(JSON.parse(e)))
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		parse: function(e) {
			var t = this.parseGeometries(e.geometries),
				n = this.parseMaterials(e.materials);
			return this.parseObject(e.object, t, n)
		},
		parseGeometries: function(e) {
			var t = {};
			if (void 0 !== e)
				for (var n = new THREE.JSONLoader, r = new THREE.Geometry2Loader, i = new THREE.BufferGeometryLoader, s = 0, o = e.length; s < o; s++) {
					var u, a = e[s];
					switch (a.type) {
						case "PlaneGeometry":
							u = new THREE.PlaneGeometry(a.width, a.height, a.widthSegments, a.heightSegments);
							break;
						case "BoxGeometry":
						case "CubeGeometry":
							u = new THREE.BoxGeometry(a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
							break;
						case "CircleGeometry":
							u = new THREE.CircleGeometry(a.radius, a.segments);
							break;
						case "CylinderGeometry":
							u = new THREE.CylinderGeometry(a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded);
							break;
						case "SphereGeometry":
							u = new THREE.SphereGeometry(a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
							break;
						case "IcosahedronGeometry":
							u = new THREE.IcosahedronGeometry(a.radius, a.detail);
							break;
						case "TorusGeometry":
							u = new THREE.TorusGeometry(a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
							break;
						case "TorusKnotGeometry":
							u = new THREE.TorusKnotGeometry(a.radius, a.tube, a.radialSegments, a.tubularSegments, a.p, a.q, a.heightScale);
							break;
						case "BufferGeometry":
							u = i.parse(a.data);
							break;
						case "Geometry2":
							u = r.parse(a.data);
							break;
						case "Geometry":
							u = n.parse(a.data).geometry
					}
					u.uuid = a.uuid, void 0 !== a.name && (u.name = a.name), t[a.uuid] = u
				}
			return t
		},
		parseMaterials: function(e) {
			var t = {};
			if (void 0 !== e)
				for (var n = new THREE.MaterialLoader, r = 0, i = e.length; r < i; r++) {
					var s = e[r],
						o = n.parse(s);
					o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), t[s.uuid] = o
				}
			return t
		},
		parseObject: function() {
			var e = new THREE.Matrix4;
			return function(t, n, r) {
				var i;
				switch (t.type) {
					case "Scene":
						i = new THREE.Scene;
						break;
					case "PerspectiveCamera":
						i = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
						break;
					case "OrthographicCamera":
						i = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
						break;
					case "AmbientLight":
						i = new THREE.AmbientLight(t.color);
						break;
					case "DirectionalLight":
						i = new THREE.DirectionalLight(t.color, t.intensity);
						break;
					case "PointLight":
						i = new THREE.PointLight(t.color, t.intensity, t.distance);
						break;
					case "SpotLight":
						i = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.exponent);
						break;
					case "HemisphereLight":
						i = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
						break;
					case "Mesh":
						i = n[t.geometry];
						var s = r[t.material];
						void 0 === i && console.error("THREE.ObjectLoader: Undefined geometry " + t.geometry), void 0 === s && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Mesh(i, s);
						break;
					case "Sprite":
						s = r[t.material], void 0 === s && console.error("THREE.ObjectLoader: Undefined material " + t.material), i = new THREE.Sprite(s);
						break;
					default:
						i = new THREE.Object3D
				}
				i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.userData && (i.userData = t.userData);
				if (void 0 !== t.children)
					for (var o in t.children) i.add(this.parseObject(t.children[o], n, r));
				return i
			}
		}()
	}, THREE.SceneLoader = function() {
		this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}, this.callbackSync = function() {}, this.callbackProgress = function() {}, this.geometryHandlers = {}, this.hierarchyHandlers = {}, this.addGeometryHandler("ascii", THREE.JSONLoader)
	}, THREE.SceneLoader.prototype = {
		constructor: THREE.SceneLoader,
		load: function(e, t, n, r) {
			var i = this;
			n = new THREE.XHRLoader(i.manager), n.setCrossOrigin(this.crossOrigin), n.load(e, function(n) {
				i.parse(JSON.parse(n), t, e)
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		},
		addGeometryHandler: function(e, t) {
			this.geometryHandlers[e] = {
				loaderClass: t
			}
		},
		addHierarchyHandler: function(e, t) {
			this.hierarchyHandlers[e] = {
				loaderClass: t
			}
		},
		parse: function(e, t, n) {
			function r(e, t) {
				return "relativeToHTML" == t ? e : p + e
			}

			function i() {
				s(T.scene, C.objects)
			}

			function s(e, t) {
				var n, i, o, u, f, l;
				for (l in t) {
					var c = T.objects[l],
						p = t[l];
					if (void 0 === c) {
						if (p.type && p.type in h.hierarchyHandlers) {
							if (void 0 === p.loading) {
								n = {
									type: 1,
									url: 1,
									material: 1,
									position: 1,
									rotation: 1,
									scale: 1,
									visible: 1,
									children: 1,
									userData: 1,
									skin: 1,
									morph: 1,
									mirroredLoop: 1,
									duration: 1
								};
								var g = {},
									y;
								for (y in p) y in n || (g[y] = p[y]);
								v = T.materials[p.material], p.loading = !0, n = h.hierarchyHandlers[p.type].loaderObject, n.options ? n.load(r(p.url, C.urlBaseType), a(l, e, v, p)) : n.load(r(p.url, C.urlBaseType), a(l, e, v, p), g)
							}
						} else if (void 0 !== p.geometry) {
							if (d = T.geometries[p.geometry]) {
								c = !1, v = T.materials[p.material], c = v instanceof THREE.ShaderMaterial, i = p.position, o = p.rotation, u = p.scale, n = p.matrix, f = p.quaternion, p.material || (v = new THREE.MeshFaceMaterial(T.face_materials[p.geometry])), v instanceof THREE.MeshFaceMaterial && 0 === v.materials.length && (v = new THREE.MeshFaceMaterial(T.face_materials[p.geometry]));
								if (v instanceof THREE.MeshFaceMaterial)
									for (g = 0; g < v.materials.length; g++) c = c || v.materials[g] instanceof THREE.ShaderMaterial;
								c && d.computeTangents(), p.skin ? c = new THREE.SkinnedMesh(d, v) : p.morph ? (c = new THREE.MorphAnimMesh(d, v), void 0 !== p.duration && (c.duration = p.duration), void 0 !== p.time && (c.time = p.time), void 0 !== p.mirroredLoop && (c.mirroredLoop = p.mirroredLoop), v.morphNormals && d.computeMorphNormals()) : c = new THREE.Mesh(d, v), c.name = l, n ? (c.matrixAutoUpdate = !1, c.matrix.set(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9], n[10], n[11], n[12], n[13], n[14], n[15])) : (c.position.fromArray(i), f ? c.quaternion.fromArray(f) : c.rotation.fromArray(o), c.scale.fromArray(u)), c.visible = p.visible, c.castShadow = p.castShadow, c.receiveShadow = p.receiveShadow, e.add(c), T.objects[l] = c
							}
						} else if ("AmbientLight" === p.type || "PointLight" === p.type || "DirectionalLight" === p.type || "SpotLight" === p.type || "HemisphereLight" === p.type || "AreaLight" === p.type) {
							g = p.color, n = p.intensity, i = p.distance, o = p.position, u = p.rotation;
							switch (p.type) {
								case "AmbientLight":
									b = new THREE.AmbientLight(g);
									break;
								case "PointLight":
									b = new THREE.PointLight(g, n, i), b.position.fromArray(o);
									break;
								case "DirectionalLight":
									b = new THREE.DirectionalLight(g, n), b.position.fromArray(p.direction);
									break;
								case "SpotLight":
									b = new THREE.SpotLight(g, n, i, 1), b.angle = p.angle, b.position.fromArray(o), b.target.set(o[0], o[1] - i, o[2]), b.target.applyEuler(new THREE.Euler(u[0], u[1], u[2], "XYZ"));
									break;
								case "HemisphereLight":
									b = new THREE.DirectionalLight(g, n, i), b.target.set(o[0], o[1] - i, o[2]), b.target.applyEuler(new THREE.Euler(u[0], u[1], u[2], "XYZ"));
									break;
								case "AreaLight":
									b = new THREE.AreaLight(g, n), b.position.fromArray(o), b.width = p.size, b.height = p.size_y
							}
							e.add(b), b.name = l, T.lights[l] = b, T.objects[l] = b
						} else "PerspectiveCamera" === p.type || "OrthographicCamera" === p.type ? (i = p.position, o = p.rotation, f = p.quaternion, "PerspectiveCamera" === p.type ? m = new THREE.PerspectiveCamera(p.fov, p.aspect, p.near, p.far) : "OrthographicCamera" === p.type && (m = new THREE.OrthographicCamera(p.left, p.right, p.top, p.bottom, p.near, p.far)), m.name = l, m.position.fromArray(i), void 0 !== f ? m.quaternion.fromArray(f) : void 0 !== o && m.rotation.fromArray(o), e.add(m), T.cameras[l] = m, T.objects[l] = m) : (i = p.position, o = p.rotation, u = p.scale, f = p.quaternion, c = new THREE.Object3D, c.name = l, c.position.fromArray(i), f ? c.quaternion.fromArray(f) : c.rotation.fromArray(o), c.scale.fromArray(u), c.visible = void 0 !== p.visible ? p.visible : !1, e.add(c), T.objects[l] = c, T.empties[l] = c);
						if (c) {
							if (void 0 !== p.userData)
								for (var w in p.userData) c.userData[w] = p.userData[w];
							if (void 0 !== p.groups)
								for (g = 0; g < p.groups.length; g++) n = p.groups[g], void 0 === T.groups[n] && (T.groups[n] = []), T.groups[n].push(l)
						}
					}
					void 0 !== c && void 0 !== p.children && s(c, p.children)
				}
			}

			function o(e, t, n, r, s) {
				var o = s.rotation,
					u = s.quaternion,
					a = s.scale;
				e.position.fromArray(s.position), u ? e.quaternion.fromArray(u) : e.rotation.fromArray(o), e.scale.fromArray(a), r && e.traverse(function(e) {
					e.material = r
				});
				var f = void 0 !== s.visible ? s.visible : !0;
				e.traverse(function(e) {
					e.visible = f
				}), n.add(e), e.name = t, T.objects[t] = e, i()
			}

			function u(e) {
				return function(t, n) {
					t.name = e, T.geometries[e] = t, T.face_materials[e] = n, i(), w -= 1, h.onLoadComplete(), l()
				}
			}

			function a(e, t, n, r) {
				return function(i) {
					o(i.content ? i.content : i.dae ? i.scene : i, e, t, n, r), w -= 1, h.onLoadComplete(), l()
				}
			}

			function f(e) {
				return function(t, n) {
					t.name = e, T.geometries[e] = t, T.face_materials[e] = n
				}
			}

			function l() {
				h.callbackProgress({
					totalModels: S,
					totalTextures: x,
					loadedModels: S - w,
					loadedTextures: x - E
				}, T), h.onLoadProgress();
				if (0 === w && 0 === E) {
					for (var e = 0; e < N.length; e++) {
						var n = N[e],
							r = T.objects[n.targetName];
						r ? n.object.target = r : (n.object.target = new THREE.Object3D, T.scene.add(n.object.target)), n.object.target.userData.targetInverse = n.object
					}
					t(T)
				}
			}

			function c(e, t) {
				t(e);
				if (void 0 !== e.children)
					for (var n in e.children) c(e.children[n], t)
			}
			var h = this,
				p = THREE.Loader.prototype.extractUrlBase(n),
				d, v, m, g, y, b, w, E, S, x, T, N = [],
				C = e,
				k;
			for (k in this.geometryHandlers) e = this.geometryHandlers[k].loaderClass, this.geometryHandlers[k].loaderObject = new e;
			for (k in this.hierarchyHandlers) e = this.hierarchyHandlers[k].loaderClass, this.hierarchyHandlers[k].loaderObject = new e;
			E = w = 0, T = {
				scene: new THREE.Scene,
				geometries: {},
				face_materials: {},
				materials: {},
				textures: {},
				objects: {},
				cameras: {},
				lights: {},
				fogs: {},
				empties: {},
				groups: {}
			}, C.transform && (k = C.transform.position, e = C.transform.rotation, n = C.transform.scale, k && T.scene.position.fromArray(k), e && T.scene.rotation.fromArray(e), n && T.scene.scale.fromArray(n), k || e || n) && (T.scene.updateMatrix(), T.scene.updateMatrixWorld()), k = function(e) {
				return function() {
					E -= e, l(), h.onLoadComplete()
				}
			};
			for (var L in C.fogs) e = C.fogs[L], "linear" === e.type ? g = new THREE.Fog(0, e.near, e.far) : "exp2" === e.type && (g = new THREE.FogExp2(0, e.density)), e = e.color, g.color.setRGB(e[0], e[1], e[2]), T.fogs[L] = g;
			for (var A in C.geometries) g = C.geometries[A], g.type in this.geometryHandlers && (w += 1, h.onLoadStart());
			for (var O in C.objects) c(C.objects[O], function(e) {
				e.type && e.type in h.hierarchyHandlers && (w += 1, h.onLoadStart())
			});
			S = w;
			for (A in C.geometries)
				if (g = C.geometries[A], "cube" === g.type) d = new THREE.BoxGeometry(g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments), d.name = A, T.geometries[A] = d;
				else if ("plane" === g.type) d = new THREE.PlaneGeometry(g.width, g.height, g.widthSegments, g.heightSegments), d.name = A, T.geometries[A] = d;
			else if ("sphere" === g.type) d = new THREE.SphereGeometry(g.radius, g.widthSegments, g.heightSegments), d.name = A, T.geometries[A] = d;
			else if ("cylinder" === g.type) d = new THREE.CylinderGeometry(g.topRad, g.botRad, g.height, g.radSegs, g.heightSegs), d.name = A, T.geometries[A] = d;
			else if ("torus" === g.type) d = new THREE.TorusGeometry(g.radius, g.tube, g.segmentsR, g.segmentsT), d.name = A, T.geometries[A] = d;
			else if ("icosahedron" === g.type) d = new THREE.IcosahedronGeometry(g.radius, g.subdivisions), d.name = A, T.geometries[A] = d;
			else if (g.type in this.geometryHandlers) {
				O = {};
				for (y in g) "type" !== y && "url" !== y && (O[y] = g[y]);
				this.geometryHandlers[g.type].loaderObject.load(r(g.url, C.urlBaseType), u(A), O)
			} else "embedded" === g.type && (O = C.embeds[g.id], O.metadata = C.metadata, O && (O = this.geometryHandlers.ascii.loaderObject.parse(O, ""), f(A)(O.geometry, O.materials)));
			for (var M in C.textures)
				if (A = C.textures[M], A.url instanceof Array)
					for (E += A.url.length, y = 0; y < A.url.length; y++) h.onLoadStart();
				else E += 1, h.onLoadStart();
			x = E;
			for (M in C.textures) {
				A = C.textures[M], void 0 !== A.mapping && void 0 !== THREE[A.mapping] && (A.mapping = new THREE[A.mapping]);
				if (A.url instanceof Array) {
					O = A.url.length, g = [];
					for (y = 0; y < O; y++) g[y] = r(A.url[y], C.urlBaseType);
					y = (y = /\.dds$/i.test(g[0])) ? THREE.ImageUtils.loadCompressedTextureCube(g, A.mapping, k(O)) : THREE.ImageUtils.loadTextureCube(g, A.mapping, k(O))
				} else y = /\.dds$/i.test(A.url), O = r(A.url, C.urlBaseType), g = k(1), y = y ? THREE.ImageUtils.loadCompressedTexture(O, A.mapping, g) : THREE.ImageUtils.loadTexture(O, A.mapping, g), void 0 !== THREE[A.minFilter] && (y.minFilter = THREE[A.minFilter]), void 0 !== THREE[A.magFilter] && (y.magFilter = THREE[A.magFilter]), A.anisotropy && (y.anisotropy = A.anisotropy), A.repeat && (y.repeat.set(A.repeat[0], A.repeat[1]), 1 !== A.repeat[0] && (y.wrapS = THREE.RepeatWrapping), 1 !== A.repeat[1] && (y.wrapT = THREE.RepeatWrapping)), A.offset && y.offset.set(A.offset[0], A.offset[1]), A.wrap && (O = {
					repeat: THREE.RepeatWrapping,
					mirror: THREE.MirroredRepeatWrapping
				}, void 0 !== O[A.wrap[0]] && (y.wrapS = O[A.wrap[0]]), void 0 !== O[A.wrap[1]] && (y.wrapT = O[A.wrap[1]]));
				T.textures[M] = y
			}
			var _, D;
			for (_ in C.materials) {
				M = C.materials[_];
				for (D in M.parameters) "envMap" === D || "map" === D || "lightMap" === D || "bumpMap" === D ? M.parameters[D] = T.textures[M.parameters[D]] : "shading" === D ? M.parameters[D] = "flat" === M.parameters[D] ? THREE.FlatShading : THREE.SmoothShading : "side" === D ? M.parameters[D] = "double" == M.parameters[D] ? THREE.DoubleSide : "back" == M.parameters[D] ? THREE.BackSide : THREE.FrontSide : "blending" === D ? M.parameters[D] = M.parameters[D] in THREE ? THREE[M.parameters[D]] : THREE.NormalBlending : "combine" === D ? M.parameters[D] = M.parameters[D] in THREE ? THREE[M.parameters[D]] : THREE.MultiplyOperation : "vertexColors" === D ? "face" == M.parameters[D] ? M.parameters[D] = THREE.FaceColors : M.parameters[D] && (M.parameters[D] = THREE.VertexColors) : "wrapRGB" === D && (k = M.parameters[D], M.parameters[D] = new THREE.Vector3(k[0], k[1], k[2]));
				void 0 !== M.parameters.opacity && 1 > M.parameters.opacity && (M.parameters.transparent = !0), M.parameters.normalMap ? (k = THREE.ShaderLib.normalmap, A = THREE.UniformsUtils.clone(k.uniforms), y = M.parameters.color, O = M.parameters.specular, g = M.parameters.ambient, L = M.parameters.shininess, A.tNormal.value = T.textures[M.parameters.normalMap], M.parameters.normalScale && A.uNormalScale.value.set(M.parameters.normalScale[0], M.parameters.normalScale[1]), M.parameters.map && (A.tDiffuse.value = M.parameters.map, A.enableDiffuse.value = !0), M.parameters.envMap && (A.tCube.value = M.parameters.envMap, A.enableReflection.value = !0, A.reflectivity.value = M.parameters.reflectivity), M.parameters.lightMap && (A.tAO.value = M.parameters.lightMap, A.enableAO.value = !0), M.parameters.specularMap && (A.tSpecular.value = T.textures[M.parameters.specularMap], A.enableSpecular.value = !0), M.parameters.displacementMap && (A.tDisplacement.value = T.textures[M.parameters.displacementMap], A.enableDisplacement.value = !0, A.uDisplacementBias.value = M.parameters.displacementBias, A.uDisplacementScale.value = M.parameters.displacementScale), A.diffuse.value.setHex(y), A.specular.value.setHex(O), A.ambient.value.setHex(g), A.shininess.value = L, M.parameters.opacity && (A.opacity.value = M.parameters.opacity), v = new THREE.ShaderMaterial({
					fragmentShader: k.fragmentShader,
					vertexShader: k.vertexShader,
					uniforms: A,
					lights: !0,
					fog: !0
				})) : v = new THREE[M.type](M.parameters), v.name = _, T.materials[_] = v
			}
			for (_ in C.materials)
				if (M = C.materials[_], M.parameters.materials) {
					D = [];
					for (y = 0; y < M.parameters.materials.length; y++) D.push(T.materials[M.parameters.materials[y]]);
					T.materials[_].materials = D
				} i(), T.cameras && C.defaults.camera && (T.currentCamera = T.cameras[C.defaults.camera]), T.fogs && C.defaults.fog && (T.scene.fog = T.fogs[C.defaults.fog]), h.callbackSync(T), l()
		}
	}, THREE.TextureLoader = function(e) {
		this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager
	}, THREE.TextureLoader.prototype = {
		constructor: THREE.TextureLoader,
		load: function(e, t, n, r) {
			n = new THREE.ImageLoader(this.manager), n.setCrossOrigin(this.crossOrigin), n.load(e, function(e) {
				e = new THREE.Texture(e), e.needsUpdate = !0, void 0 !== t && t(e)
			})
		},
		setCrossOrigin: function(e) {
			this.crossOrigin = e
		}
	}, THREE.Material = function() {
		this.id = THREE.MaterialIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.side = THREE.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = THREE.NormalBlending, this.blendSrc = THREE.SrcAlphaFactor, this.blendDst = THREE.OneMinusSrcAlphaFactor, this.blendEquation = THREE.AddEquation, this.depthWrite = this.depthTest = !0, this.polygonOffset = !1, this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.needsUpdate = this.visible = !0
	}, THREE.Material.prototype = {
		constructor: THREE.Material,
		setValues: function(e) {
			if (void 0 !== e)
				for (var t in e) {
					var n = e[t];
					if (void 0 === n) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
					else if (t in this) {
						var r = this[t];
						r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : this[t] = "overdraw" == t ? Number(n) : n
					}
				}
		},
		clone: function(e) {
			return void 0 === e && (e = new THREE.Material), e.name = this.name, e.side = this.side, e.opacity = this.opacity, e.transparent = this.transparent, e.blending = this.blending, e.blendSrc = this.blendSrc, e.blendDst = this.blendDst, e.blendEquation = this.blendEquation, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.alphaTest = this.alphaTest, e.overdraw = this.overdraw, e.visible = this.visible, e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Material.prototype), THREE.MaterialIdCount = 0, THREE.LineBasicMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.vertexColors = !1, this.fog = !0, this.setValues(e)
	}, THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineBasicMaterial.prototype.clone = function() {
		var e = new THREE.LineBasicMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.linecap = this.linecap, e.linejoin = this.linejoin, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.LineDashedMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.vertexColors = !1, this.fog = !0, this.setValues(e)
	}, THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype), THREE.LineDashedMaterial.prototype.clone = function() {
		var e = new THREE.LineDashedMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.linewidth = this.linewidth, e.scale = this.scale, e.dashSize = this.dashSize, e.gapSize = this.gapSize, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.MeshBasicMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.envMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshBasicMaterial.prototype.clone = function() {
		var e = new THREE.MeshBasicMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e
	}, THREE.MeshLambertMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.wrapAround = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.envMap = this.specularMap = this.lightMap = this.map = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshLambertMaterial.prototype.clone = function() {
		var e = new THREE.MeshLambertMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.MeshPhongMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.ambient = new THREE.Color(16777215), this.emissive = new THREE.Color(0), this.specular = new THREE.Color(1118481), this.shininess = 30, this.wrapAround = this.metal = !1, this.wrapRGB = new THREE.Vector3(1, 1, 1), this.bumpMap = this.lightMap = this.map = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new THREE.Vector2(1, 1), this.envMap = this.specularMap = null, this.combine = THREE.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = THREE.SmoothShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}, THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshPhongMaterial.prototype.clone = function() {
		var e = new THREE.MeshPhongMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.ambient.copy(this.ambient), e.emissive.copy(this.emissive), e.specular.copy(this.specular), e.shininess = this.shininess, e.metal = this.metal, e.wrapAround = this.wrapAround, e.wrapRGB.copy(this.wrapRGB), e.map = this.map, e.lightMap = this.lightMap, e.bumpMap = this.bumpMap, e.bumpScale = this.bumpScale, e.normalMap = this.normalMap, e.normalScale.copy(this.normalScale), e.specularMap = this.specularMap, e.envMap = this.envMap, e.combine = this.combine, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, e.fog = this.fog, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.wireframeLinecap = this.wireframeLinecap, e.wireframeLinejoin = this.wireframeLinejoin, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.MeshDepthMaterial = function(e) {
		THREE.Material.call(this), this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
	}, THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshDepthMaterial.prototype.clone = function() {
		var e = new THREE.MeshDepthMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
	}, THREE.MeshNormalMaterial = function(e) {
		THREE.Material.call(this, e), this.shading = THREE.FlatShading, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
	}, THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype), THREE.MeshNormalMaterial.prototype.clone = function() {
		var e = new THREE.MeshNormalMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e
	}, THREE.MeshFaceMaterial = function(e) {
		this.materials = e instanceof Array ? e : []
	}, THREE.MeshFaceMaterial.prototype.clone = function() {
		for (var e = new THREE.MeshFaceMaterial, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
		return e
	}, THREE.ParticleSystemMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.vertexColors = !1, this.fog = !0, this.setValues(e)
	}, THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ParticleSystemMaterial.prototype.clone = function() {
		var e = new THREE.ParticleSystemMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.size = this.size, e.sizeAttenuation = this.sizeAttenuation, e.vertexColors = this.vertexColors, e.fog = this.fog, e
	}, THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial, THREE.ShaderMaterial = function(e) {
		THREE.Material.call(this), this.vertexShader = this.fragmentShader = "void main() {}", this.uniforms = {}, this.defines = {}, this.attributes = null, this.shading = THREE.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.vertexColors = THREE.NoColors, this.morphNormals = this.morphTargets = this.skinning = !1, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		}, this.index0AttributeName = "position", this.setValues(e)
	}, THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype), THREE.ShaderMaterial.prototype.clone = function() {
		var e = new THREE.ShaderMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.fragmentShader = this.fragmentShader, e.vertexShader = this.vertexShader, e.uniforms = THREE.UniformsUtils.clone(this.uniforms), e.attributes = this.attributes, e.defines = this.defines, e.shading = this.shading, e.wireframe = this.wireframe, e.wireframeLinewidth = this.wireframeLinewidth, e.fog = this.fog, e.lights = this.lights, e.vertexColors = this.vertexColors, e.skinning = this.skinning, e.morphTargets = this.morphTargets, e.morphNormals = this.morphNormals, e
	}, THREE.SpriteMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
	}, THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteMaterial.prototype.clone = function() {
		var e = new THREE.SpriteMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.map = this.map, e.rotation = this.rotation, e.fog = this.fog, e
	}, THREE.SpriteCanvasMaterial = function(e) {
		THREE.Material.call(this), this.color = new THREE.Color(16777215), this.program = function(e, t) {}, this.setValues(e)
	}, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function() {
		var e = new THREE.SpriteCanvasMaterial;
		return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.program = this.program, e
	}, THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial, THREE.Texture = function(e, t, n, r, i, s, o, u, a) {
		this.id = THREE.TextureIdCount++, this.uuid = THREE.Math.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = void 0 !== t ? t : new THREE.UVMapping, this.wrapS = void 0 !== n ? n : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== r ? r : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== i ? i : THREE.LinearFilter, this.minFilter = void 0 !== s ? s : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== a ? a : 1, this.format = void 0 !== o ? o : THREE.RGBAFormat, this.type = void 0 !== u ? u : THREE.UnsignedByteType, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this._needsUpdate = !1, this.onUpdate = null
	}, THREE.Texture.prototype = {
		constructor: THREE.Texture,
		get needsUpdate() {
			return this._needsUpdate
		},
		set needsUpdate(e) {
			!0 === e && this.update(), this._needsUpdate = e
		},
		clone: function(e) {
			return void 0 === e && (e = new THREE.Texture), e.image = this.image, e.mipmaps = this.mipmaps.slice(0), e.mapping = this.mapping, e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.format = this.format, e.type = this.type, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.generateMipmaps = this.generateMipmaps, e.premultiplyAlpha = this.premultiplyAlpha, e.flipY = this.flipY, e.unpackAlignment = this.unpackAlignment, e
		},
		update: function() {
			this.dispatchEvent({
				type: "update"
			})
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype), THREE.TextureIdCount = 0, THREE.CompressedTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
		THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), this.image = {
			width: t,
			height: n
		}, this.mipmaps = e, this.generateMipmaps = !1
	}, THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype), THREE.CompressedTexture.prototype.clone = function() {
		var e = new THREE.CompressedTexture;
		return THREE.Texture.prototype.clone.call(this, e), e
	}, THREE.DataTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
		THREE.Texture.call(this, null, s, o, u, a, f, r, i, l), this.image = {
			data: e,
			width: t,
			height: n
		}
	}, THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype), THREE.DataTexture.prototype.clone = function() {
		var e = new THREE.DataTexture;
		return THREE.Texture.prototype.clone.call(this, e), e
	}, THREE.ParticleSystem = function(e, t) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.ParticleSystemMaterial({
			color: 16777215 * Math.random()
		}), this.frustumCulled = this.sortParticles = !1
	}, THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype), THREE.ParticleSystem.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.ParticleSystem(this.geometry, this.material)), e.sortParticles = this.sortParticles, THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Line = function(e, t, n) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.LineBasicMaterial({
			color: 16777215 * Math.random()
		}), this.type = void 0 !== n ? n : THREE.LineStrip
	}, THREE.LineStrip = 0, THREE.LinePieces = 1, THREE.Line.prototype = Object.create(THREE.Object3D.prototype), THREE.Line.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Line(this.geometry, this.material, this.type)), THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Mesh = function(e, t) {
		THREE.Object3D.call(this), this.geometry = void 0 !== e ? e : new THREE.Geometry, this.material = void 0 !== t ? t : new THREE.MeshBasicMaterial({
			color: 16777215 * Math.random()
		}), this.updateMorphTargets()
	}, THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype), THREE.Mesh.prototype.updateMorphTargets = function() {
		if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
			this.morphTargetBase = -1, this.morphTargetForcedOrder = [], this.morphTargetInfluences = [], this.morphTargetDictionary = {};
			for (var e = 0, t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
		}
	}, THREE.Mesh.prototype.getMorphTargetIndexByName = function(e) {
		return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
	}, THREE.Mesh.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Mesh(this.geometry, this.material)), THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Bone = function(e) {
		THREE.Object3D.call(this), this.skin = e, this.skinMatrix = new THREE.Matrix4
	}, THREE.Bone.prototype = Object.create(THREE.Object3D.prototype), THREE.Bone.prototype.update = function(e, t) {
		this.matrixAutoUpdate && (t |= this.updateMatrix());
		if (t || this.matrixWorldNeedsUpdate) e ? this.skinMatrix.multiplyMatrices(e, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0;
		var n, r = this.children.length;
		for (n = 0; n < r; n++) this.children[n].update(this.skinMatrix, t)
	}, THREE.SkinnedMesh = function(e, t, n) {
		THREE.Mesh.call(this, e, t), this.useVertexTexture = void 0 !== n ? n : !0, this.identityMatrix = new THREE.Matrix4, this.bones = [], this.boneMatrices = [];
		var r, i, s;
		if (this.geometry && void 0 !== this.geometry.bones) {
			for (e = 0; e < this.geometry.bones.length; e++) n = this.geometry.bones[e], r = n.pos, i = n.rotq, s = n.scl, t = this.addBone(), t.name = n.name, t.position.set(r[0], r[1], r[2]), t.quaternion.set(i[0], i[1], i[2], i[3]), void 0 !== s ? t.scale.set(s[0], s[1], s[2]) : t.scale.set(1, 1, 1);
			for (e = 0; e < this.bones.length; e++) n = this.geometry.bones[e], t = this.bones[e], -1 === n.parent ? this.add(t) : this.bones[n.parent].add(t);
			e = this.bones.length, this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = e = 256 < e ? 64 : 64 < e ? 32 : 16 < e ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * e), this.pose()
		}
	}, THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.SkinnedMesh.prototype.addBone = function(e) {
		return void 0 === e && (e = new THREE.Bone(this)), this.bones.push(e), e
	}, THREE.SkinnedMesh.prototype.updateMatrixWorld = function() {
		var e = new THREE.Matrix4;
		return function(t) {
			this.matrixAutoUpdate && this.updateMatrix();
			if (this.matrixWorldNeedsUpdate || t) this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;
			t = 0;
			for (var n = this.children.length; t < n; t++) {
				var r = this.children[t];
				r instanceof THREE.Bone ? r.update(this.identityMatrix, !1) : r.updateMatrixWorld(!0)
			}
			if (void 0 == this.boneInverses)
				for (this.boneInverses = [], t = 0, n = this.bones.length; t < n; t++) r = new THREE.Matrix4, r.getInverse(this.bones[t].skinMatrix), this.boneInverses.push(r);
			t = 0;
			for (n = this.bones.length; t < n; t++) e.multiplyMatrices(this.bones[t].skinMatrix, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t);
			this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
		}
	}(), THREE.SkinnedMesh.prototype.pose = function() {
		this.updateMatrixWorld(!0), this.normalizeSkinWeights()
	}, THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
		if (this.geometry instanceof THREE.Geometry)
			for (var e = 0; e < this.geometry.skinIndices.length; e++) {
				var t = this.geometry.skinWeights[e],
					n = 1 / t.lengthManhattan();
				Infinity !== n ? t.multiplyScalar(n) : t.set(1)
			}
	}, THREE.SkinnedMesh.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture)), THREE.Mesh.prototype.clone.call(this, e), e
	}, THREE.MorphAnimMesh = function(e, t) {
		THREE.Mesh.call(this, e, t), this.duration = 1e3, this.mirroredLoop = !1, this.currentKeyframe = this.lastKeyframe = this.time = 0, this.direction = 1, this.directionBackwards = !1, this.setFrameRange(0, this.geometry.morphTargets.length - 1)
	}, THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphAnimMesh.prototype.setFrameRange = function(e, t) {
		this.startKeyframe = e, this.endKeyframe = t, this.length = this.endKeyframe - this.startKeyframe + 1
	}, THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
		this.direction = 1, this.directionBackwards = !1
	}, THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
		this.direction = -1, this.directionBackwards = !0
	}, THREE.MorphAnimMesh.prototype.parseAnimations = function() {
		var e = this.geometry;
		e.animations || (e.animations = {});
		for (var t, n = e.animations, r = /([a-z]+)(\d+)/, i = 0, s = e.morphTargets.length; i < s; i++) {
			var o = e.morphTargets[i].name.match(r);
			if (o && 1 < o.length) {
				o = o[1], n[o] || (n[o] = {
					start: Infinity,
					end: -Infinity
				});
				var u = n[o];
				i < u.start && (u.start = i), i > u.end && (u.end = i), t || (t = o)
			}
		}
		e.firstAnimation = t
	}, THREE.MorphAnimMesh.prototype.setAnimationLabel = function(e, t, n) {
		this.geometry.animations || (this.geometry.animations = {}), this.geometry.animations[e] = {
			start: t,
			end: n
		}
	}, THREE.MorphAnimMesh.prototype.playAnimation = function(e, t) {
		var n = this.geometry.animations[e];
		n ? (this.setFrameRange(n.start, n.end), this.duration = (n.end - n.start) / t * 1e3, this.time = 0) : console.warn("animation[" + e + "] undefined")
	}, THREE.MorphAnimMesh.prototype.updateAnimation = function(e) {
		var t = this.duration / this.length;
		this.time += this.direction * e;
		if (this.mirroredLoop) {
			if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
		} else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
		e = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / t), 0, this.length - 1), e !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[e] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = e), t = this.time % t / t, this.directionBackwards && (t = 1 - t), this.morphTargetInfluences[this.currentKeyframe] = t, this.morphTargetInfluences[this.lastKeyframe] = 1 - t
	}, THREE.MorphAnimMesh.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.MorphAnimMesh(this.geometry, this.material)), e.duration = this.duration, e.mirroredLoop = this.mirroredLoop, e.time = this.time, e.lastKeyframe = this.lastKeyframe, e.currentKeyframe = this.currentKeyframe, e.direction = this.direction, e.directionBackwards = this.directionBackwards, THREE.Mesh.prototype.clone.call(this, e), e
	}, THREE.LOD = function() {
		THREE.Object3D.call(this), this.objects = []
	}, THREE.LOD.prototype = Object.create(THREE.Object3D.prototype), THREE.LOD.prototype.addLevel = function(e, t) {
		void 0 === t && (t = 0), t = Math.abs(t);
		for (var n = 0; n < this.objects.length && !(t < this.objects[n].distance); n++);
		this.objects.splice(n, 0, {
			distance: t,
			object: e
		}), this.add(e)
	}, THREE.LOD.prototype.getObjectForDistance = function(e) {
		for (var t = 1, n = this.objects.length; t < n && !(e < this.objects[t].distance); t++);
		return this.objects[t - 1].object
	}, THREE.LOD.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3;
		return function(n) {
			if (1 < this.objects.length) {
				e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), n = e.distanceTo(t), this.objects[0].object.visible = !0;
				for (var r = 1, i = this.objects.length; r < i; r++) {
					if (!(n >= this.objects[r].distance)) break;
					this.objects[r - 1].object.visible = !1, this.objects[r].object.visible = !0
				}
				for (; r < i; r++) this.objects[r].object.visible = !1
			}
		}
	}(), THREE.LOD.prototype.clone = function(e) {
		void 0 === e && (e = new THREE.LOD), THREE.Object3D.prototype.clone.call(this, e);
		for (var t = 0, n = this.objects.length; t < n; t++) {
			var r = this.objects[t].object.clone();
			r.visible = 0 === t, e.addLevel(r, this.objects[t].distance)
		}
		return e
	}, THREE.Sprite = function() {
		var e = new THREE.Geometry2(3);
		return e.vertices.set([-0.5, -0.5, 0, .5, -0.5, 0, .5, .5, 0]),
			function(t) {
				THREE.Object3D.call(this), this.geometry = e, this.material = void 0 !== t ? t : new THREE.SpriteMaterial
			}
	}(), THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype), THREE.Sprite.prototype.updateMatrix = function() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}, THREE.Sprite.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Sprite(this.material)), THREE.Object3D.prototype.clone.call(this, e), e
	}, THREE.Particle = THREE.Sprite, THREE.Scene = function() {
		THREE.Object3D.call(this), this.overrideMaterial = this.fog = null, this.autoUpdate = !0, this.matrixAutoUpdate = !1, this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = []
	}, THREE.Scene.prototype = Object.create(THREE.Object3D.prototype), THREE.Scene.prototype.__addObject = function(e) {
		if (e instanceof THREE.Light) - 1 === this.__lights.indexOf(e) && this.__lights.push(e), e.target && void 0 === e.target.parent && this.add(e.target);
		else if (!(e instanceof THREE.Camera || e instanceof THREE.Bone)) {
			this.__objectsAdded.push(e);
			var t = this.__objectsRemoved.indexOf(e); - 1 !== t && this.__objectsRemoved.splice(t, 1)
		}
		this.dispatchEvent({
			type: "objectAdded",
			object: e
		}), e.dispatchEvent({
			type: "addedToScene",
			scene: this
		});
		for (t = 0; t < e.children.length; t++) this.__addObject(e.children[t])
	}, THREE.Scene.prototype.__removeObject = function(e) {
		if (e instanceof THREE.Light) {
			var t = this.__lights.indexOf(e); - 1 !== t && this.__lights.splice(t, 1);
			if (e.shadowCascadeArray)
				for (t = 0; t < e.shadowCascadeArray.length; t++) this.__removeObject(e.shadowCascadeArray[t])
		} else e instanceof THREE.Camera || (this.__objectsRemoved.push(e), t = this.__objectsAdded.indexOf(e), -1 !== t && this.__objectsAdded.splice(t, 1));
		this.dispatchEvent({
			type: "objectRemoved",
			object: e
		}), e.dispatchEvent({
			type: "removedFromScene",
			scene: this
		});
		for (t = 0; t < e.children.length; t++) this.__removeObject(e.children[t])
	}, THREE.Scene.prototype.clone = function(e) {
		return void 0 === e && (e = new THREE.Scene), THREE.Object3D.prototype.clone.call(this, e), null !== this.fog && (e.fog = this.fog.clone()), null !== this.overrideMaterial && (e.overrideMaterial = this.overrideMaterial.clone()), e.autoUpdate = this.autoUpdate, e.matrixAutoUpdate = this.matrixAutoUpdate, e
	}, THREE.Fog = function(e, t, n) {
		this.name = "", this.color = new THREE.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
	}, THREE.Fog.prototype.clone = function() {
		return new THREE.Fog(this.color.getHex(), this.near, this.far)
	}, THREE.FogExp2 = function(e, t) {
		this.name = "", this.color = new THREE.Color(e), this.density = void 0 !== t ? t : 25e-5
	}, THREE.FogExp2.prototype.clone = function() {
		return new THREE.FogExp2(this.color.getHex(), this.density)
	}, THREE.CanvasRenderer = function(e) {
		function t(e, t, n) {
			for (var r = 0, i = S.length; r < i; r++) {
				var s = S[r];
				it.copy(s.color);
				if (s instanceof THREE.DirectionalLight) {
					var o = St.setFromMatrixPosition(s.matrixWorld).normalize(),
						u = t.dot(o);
					0 >= u || (u *= s.intensity, n.add(it.multiplyScalar(u)))
				} else s instanceof THREE.PointLight && (o = St.setFromMatrixPosition(s.matrixWorld), u = t.dot(St.subVectors(o, e).normalize()), 0 >= u || (u *= 0 == s.distance ? 1 : 1 - Math.min(e.distanceTo(o) / s.distance, 1), 0 != u && (u *= s.intensity, n.add(it.multiplyScalar(u)))))
			}
		}

		function n(e, t, n, r) {
			h(t), p(n), d(r), v(e.getStyle()), A.stroke(), yt.expandByScalar(2 * t)
		}

		function r(e) {
			m(e.getStyle()), A.fill()
		}

		function i(e) {
			s(e.target)
		}

		function s(e) {
			var t = e.wrapS === THREE.RepeatWrapping,
				n = e.wrapT === THREE.RepeatWrapping,
				r = e.image,
				i = document.createElement("canvas");
			i.width = r.width, i.height = r.height;
			var s = i.getContext("2d");
			s.setTransform(1, 0, 0, -1, 0, r.height), s.drawImage(r, 0, 0), st[e.id] = A.createPattern(i, !0 === t && !0 === n ? "repeat" : !0 === t && !1 === n ? "repeat-x" : !1 === t && !0 === n ? "repeat-y" : "no-repeat")
		}

		function o(e, t, n, r, o, u, a, f, l, c, h, p, d) {
			if (!(d instanceof THREE.DataTexture)) {
				!1 === d.hasEventListener("update", i) && (void 0 !== d.image && 0 < d.image.width && s(d), d.addEventListener("update", i));
				var v = st[d.id];
				if (void 0 !== v) {
					m(v);
					var v = d.offset.x / d.repeat.x,
						g = d.offset.y / d.repeat.y,
						y = d.image.width * d.repeat.x;
					d = d.image.height * d.repeat.y, a = (a + v) * y, f = (f + g) * d, n -= e, r -= t, o -= e, u -= t, l = (l + v) * y - a, c = (c + g) * d - f, h = (h + v) * y - a, p = (p + g) * d - f, d = l * p - h * c, 0 !== d && (v = 1 / d, d = (p * n - c * o) * v, c = (p * r - c * u) * v, n = (l * o - h * n) * v, r = (l * u - h * r) * v, e = e - d * a - n * f, t = t - c * a - r * f, A.save(), A.transform(d, c, n, r, e, t), A.fill(), A.restore())
				} else m("rgba(0,0,0,1)"), A.fill()
			}
		}

		function u(e, t, n, r, i, s, o, u, a, f, l, c, h) {
			var p, d;
			p = h.width - 1, d = h.height - 1, o *= p, u *= d, n -= e, r -= t, i -= e, s -= t, a = a * p - o, f = f * d - u, l = l * p - o, c = c * d - u, d = 1 / (a * c - l * f), p = (c * n - f * i) * d, f = (c * r - f * s) * d, n = (a * i - l * n) * d, r = (a * s - l * r) * d, e = e - p * o - n * u, t = t - f * o - r * u, A.save(), A.transform(p, f, n, r, e, t), A.clip(), A.drawImage(h, 0, 0), A.restore()
		}

		function a(e, t, n, r) {
			return Lt[0] = 255 * e.r | 0, Lt[1] = 255 * e.g | 0, Lt[2] = 255 * e.b | 0, Lt[4] = 255 * t.r | 0, Lt[5] = 255 * t.g | 0, Lt[6] = 255 * t.b | 0, Lt[8] = 255 * n.r | 0, Lt[9] = 255 * n.g | 0, Lt[10] = 255 * n.b | 0, Lt[12] = 255 * r.r | 0, Lt[13] = 255 * r.g | 0, Lt[14] = 255 * r.b | 0, Ct.putImageData(kt, 0, 0), Ot.drawImage(Nt, 0, 0), At
		}

		function f(e, t, n) {
			var r = t.x - e.x,
				i = t.y - e.y,
				s = r * r + i * i;
			0 !== s && (n /= Math.sqrt(s), r *= n, i *= n, t.x += r, t.y += i, e.x -= r, e.y -= i)
		}

		function l(e) {
			_ !== e && (_ = A.globalAlpha = e)
		}

		function c(e) {
			D !== e && (e === THREE.NormalBlending ? A.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? A.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending && (A.globalCompositeOperation = "darker"), D = e)
		}

		function h(e) {
			B !== e && (B = A.lineWidth = e)
		}

		function p(e) {
			j !== e && (j = A.lineCap = e)
		}

		function d(e) {
			F !== e && (F = A.lineJoin = e)
		}

		function v(e) {
			P !== e && (P = A.strokeStyle = e)
		}

		function m(e) {
			H !== e && (H = A.fillStyle = e)
		}

		function g(e, t) {
			if (I !== e || q !== t) A.setLineDash([e, t]), I = e, q = t
		}
		console.log("THREE.CanvasRenderer", THREE.REVISION);
		var y = THREE.Math.smoothstep;
		e = e || {};
		var b = this,
			w, E, S, x = new THREE.Projector,
			T = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
			N = T.width,
			C = T.height,
			k = Math.floor(N / 2),
			L = Math.floor(C / 2),
			A = T.getContext("2d", {
				alpha: !0 === e.alpha
			}),
			O = new THREE.Color(0),
			M = 0,
			_ = 1,
			D = 0,
			P = null,
			H = null,
			B = null,
			j = null,
			F = null,
			I = null,
			q = 0,
			R, U, z, W;
		new THREE.RenderableVertex, new THREE.RenderableVertex;
		var X, V, $, J, K, Q, G = new THREE.Color,
			Y = new THREE.Color,
			Z = new THREE.Color,
			et = new THREE.Color,
			tt = new THREE.Color,
			nt = new THREE.Color,
			rt = new THREE.Color,
			it = new THREE.Color,
			st = {},
			ot, ut, at, ft, lt, ct, ht, pt, dt, vt, mt = new THREE.Box2,
			gt = new THREE.Box2,
			yt = new THREE.Box2,
			bt = new THREE.Color,
			wt = new THREE.Color,
			Et = new THREE.Color,
			St = new THREE.Vector3,
			xt = new THREE.Vector3,
			Tt = new THREE.Matrix3,
			Nt, Ct, kt, Lt, At, Ot, Mt = 16;
		Nt = document.createElement("canvas"), Nt.width = Nt.height = 2, Ct = Nt.getContext("2d"), Ct.fillStyle = "rgba(0,0,0,1)", Ct.fillRect(0, 0, 2, 2), kt = Ct.getImageData(0, 0, 2, 2), Lt = kt.data, At = document.createElement("canvas"), At.width = At.height = Mt, Ot = At.getContext("2d"), Ot.translate(-Mt / 2, -Mt / 2), Ot.scale(Mt, Mt), Mt--, void 0 === A.setLineDash && (A.setLineDash = void 0 !== A.mozDash ? function(e) {
			A.mozDash = null !== e[0] ? e : null
		} : function() {}), this.domElement = T, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.sortElements = this.sortObjects = this.autoClear = !0, this.info = {
			render: {
				vertices: 0,
				faces: 0
			}
		}, this.supportsVertexTextures = function() {}, this.setFaceCulling = function() {}, this.setSize = function(e, t, n) {
			N = e * this.devicePixelRatio, C = t * this.devicePixelRatio, k = Math.floor(N / 2), L = Math.floor(C / 2), T.width = N, T.height = C, 1 !== this.devicePixelRatio && !1 !== n && (T.style.width = e + "px", T.style.height = t + "px"), mt.min.set(-k, -L), mt.max.set(k, L), gt.min.set(-k, -L), gt.max.set(k, L), _ = 1, D = 0, F = j = B = H = P = null
		}, this.setClearColor = function(e, t) {
			O.set(e), M = void 0 !== t ? t : 1, gt.min.set(-k, -L), gt.max.set(k, L)
		}, this.setClearColorHex = function(e, t) {
			console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
		}, this.getMaxAnisotropy = function() {
			return 0
		}, this.clear = function() {
			A.setTransform(1, 0, 0, -1, k, L), !1 === gt.empty() && (gt.intersect(mt), gt.expandByScalar(2), 1 > M && A.clearRect(gt.min.x | 0, gt.min.y | 0, gt.max.x - gt.min.x | 0, gt.max.y - gt.min.y | 0), 0 < M && (c(THREE.NormalBlending), l(1), m("rgba(" + Math.floor(255 * O.r) + "," + Math.floor(255 * O.g) + "," + Math.floor(255 * O.b) + "," + M + ")"), A.fillRect(gt.min.x | 0, gt.min.y | 0, gt.max.x - gt.min.x | 0, gt.max.y - gt.min.y | 0)), gt.makeEmpty())
		}, this.clearColor = function() {}, this.clearDepth = function() {}, this.clearStencil = function() {}, this.render = function(e, T) {
			if (0 == T instanceof THREE.Camera) console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
			else {
				!0 === this.autoClear && this.clear(), A.setTransform(1, 0, 0, -1, k, L), b.info.render.vertices = 0, b.info.render.faces = 0, w = x.projectScene(e, T, this.sortObjects, this.sortElements), E = w.elements, S = w.lights, R = T, Tt.getNormalMatrix(T.matrixWorldInverse), bt.setRGB(0, 0, 0), wt.setRGB(0, 0, 0), Et.setRGB(0, 0, 0);
				for (var N = 0, C = S.length; N < C; N++) {
					var O = S[N],
						M = O.color;
					O instanceof THREE.AmbientLight ? bt.add(M) : O instanceof THREE.DirectionalLight ? wt.add(M) : O instanceof THREE.PointLight && Et.add(M)
				}
				N = 0;
				for (C = E.length; N < C; N++) {
					var _ = E[N],
						D = _.material;
					if (void 0 !== D && !1 !== D.visible) {
						yt.makeEmpty();
						if (_ instanceof THREE.RenderableSprite) {
							U = _, U.x *= k, U.y *= L, O = U, M = D, l(M.opacity), c(M.blending);
							var P = _.scale.x * k,
								_ = _.scale.y * L,
								D = .5 * Math.sqrt(P * P + _ * _);
							yt.min.set(O.x - D, O.y - D), yt.max.set(O.x + D, O.y + D);
							if (M instanceof THREE.SpriteMaterial || M instanceof THREE.ParticleSystemMaterial) {
								var H = M.map;
								if (null !== H) {
									!1 === H.hasEventListener("update", i) && (void 0 !== H.image && 0 < H.image.width && s(H), H.addEventListener("update", i)), D = st[H.id], void 0 !== D ? m(D) : m("rgba( 0, 0, 0, 1 )");
									var B = H.image,
										D = B.width * H.offset.x,
										j = B.height * H.offset.y,
										F = B.width * H.repeat.x,
										H = B.height * H.repeat.y,
										B = P / F,
										I = _ / H;
									A.save(), A.translate(O.x, O.y), 0 !== M.rotation && A.rotate(M.rotation), A.translate(-P / 2, -_ / 2), A.scale(B, I), A.translate(-D, -j), A.fillRect(D, j, F, H)
								} else m(M.color.getStyle()), A.save(), A.translate(O.x, O.y), 0 !== M.rotation && A.rotate(M.rotation), A.scale(P, -_), A.fillRect(-0.5, -0.5, 1, 1);
								A.restore()
							} else M instanceof THREE.SpriteCanvasMaterial && (v(M.color.getStyle()), m(M.color.getStyle()), A.save(), A.translate(O.x, O.y), 0 !== M.rotation && A.rotate(M.rotation), A.scale(P, _), M.program(A), A.restore())
						} else if (_ instanceof THREE.RenderableLine) {
							if (U = _.v1, z = _.v2, U.positionScreen.x *= k, U.positionScreen.y *= L, z.positionScreen.x *= k, z.positionScreen.y *= L, yt.setFromPoints([U.positionScreen, z.positionScreen]), !0 === mt.isIntersectionBox(yt))
								if (O = U, M = z, P = _, _ = D, l(_.opacity), c(_.blending), A.beginPath(), A.moveTo(O.positionScreen.x, O.positionScreen.y), A.lineTo(M.positionScreen.x, M.positionScreen.y), _ instanceof THREE.LineBasicMaterial) {
									h(_.linewidth), p(_.linecap), d(_.linejoin);
									if (_.vertexColors !== THREE.VertexColors) v(_.color.getStyle());
									else if (D = P.vertexColors[0].getStyle(), P = P.vertexColors[1].getStyle(), D === P) v(D);
									else {
										try {
											var q = A.createLinearGradient(O.positionScreen.x, O.positionScreen.y, M.positionScreen.x, M.positionScreen.y);
											q.addColorStop(0, D), q.addColorStop(1, P)
										} catch (it) {
											q = D
										}
										v(q)
									}
									A.stroke(), yt.expandByScalar(2 * _.linewidth)
								} else _ instanceof THREE.LineDashedMaterial && (h(_.linewidth), p(_.linecap), d(_.linejoin), v(_.color.getStyle()), g(_.dashSize, _.gapSize), A.stroke(), yt.expandByScalar(2 * _.linewidth), g(null, null))
						} else if (_ instanceof THREE.RenderableFace) {
							U = _.v1, z = _.v2, W = _.v3;
							if (-1 > U.positionScreen.z || 1 < U.positionScreen.z) continue;
							if (-1 > z.positionScreen.z || 1 < z.positionScreen.z) continue;
							if (-1 > W.positionScreen.z || 1 < W.positionScreen.z) continue;
							U.positionScreen.x *= k, U.positionScreen.y *= L, z.positionScreen.x *= k, z.positionScreen.y *= L, W.positionScreen.x *= k, W.positionScreen.y *= L, 0 < D.overdraw && (f(U.positionScreen, z.positionScreen, D.overdraw), f(z.positionScreen, W.positionScreen, D.overdraw), f(W.positionScreen, U.positionScreen, D.overdraw)), yt.setFromPoints([U.positionScreen, z.positionScreen, W.positionScreen]);
							if (!0 === mt.isIntersectionBox(yt)) {
								O = U, M = z, P = W, b.info.render.vertices += 3, b.info.render.faces++, l(D.opacity), c(D.blending), X = O.positionScreen.x, V = O.positionScreen.y, $ = M.positionScreen.x, J = M.positionScreen.y, K = P.positionScreen.x, Q = P.positionScreen.y;
								var j = X,
									F = V,
									H = $,
									B = J,
									I = K,
									St = Q;
								A.beginPath(), A.moveTo(j, F), A.lineTo(H, B), A.lineTo(I, St), A.closePath(), (D instanceof THREE.MeshLambertMaterial || D instanceof THREE.MeshPhongMaterial) && null === D.map ? (nt.copy(D.color), rt.copy(D.emissive), D.vertexColors === THREE.FaceColors && nt.multiply(_.color), !1 === D.wireframe && D.shading === THREE.SmoothShading && 3 === _.vertexNormalsLength ? (Y.copy(bt), Z.copy(bt), et.copy(bt), t(_.v1.positionWorld, _.vertexNormalsModel[0], Y), t(_.v2.positionWorld, _.vertexNormalsModel[1], Z), t(_.v3.positionWorld, _.vertexNormalsModel[2], et), Y.multiply(nt).add(rt), Z.multiply(nt).add(rt), et.multiply(nt).add(rt), tt.addColors(Z, et).multiplyScalar(.5), at = a(Y, Z, et, tt), u(X, V, $, J, K, Q, 0, 0, 1, 0, 0, 1, at)) : (G.copy(bt), t(_.centroidModel, _.normalModel, G), G.multiply(nt).add(rt), !0 === D.wireframe ? n(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : r(G))) : D instanceof THREE.MeshBasicMaterial || D instanceof THREE.MeshLambertMaterial || D instanceof THREE.MeshPhongMaterial ? null !== D.map ? D.map.mapping instanceof THREE.UVMapping && (ft = _.uvs[0], o(X, V, $, J, K, Q, ft[0].x, ft[0].y, ft[1].x, ft[1].y, ft[2].x, ft[2].y, D.map)) : null !== D.envMap ? D.envMap.mapping instanceof THREE.SphericalReflectionMapping && (xt.copy(_.vertexNormalsModel[0]).applyMatrix3(Tt), lt = .5 * xt.x + .5, ct = .5 * xt.y + .5, xt.copy(_.vertexNormalsModel[1]).applyMatrix3(Tt), ht = .5 * xt.x + .5, pt = .5 * xt.y + .5, xt.copy(_.vertexNormalsModel[2]).applyMatrix3(Tt), dt = .5 * xt.x + .5, vt = .5 * xt.y + .5, o(X, V, $, J, K, Q, lt, ct, ht, pt, dt, vt, D.envMap)) : (G.copy(D.color), D.vertexColors === THREE.FaceColors && G.multiply(_.color), !0 === D.wireframe ? n(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : r(G)) : D instanceof THREE.MeshDepthMaterial ? (ot = R.near, ut = R.far, Y.r = Y.g = Y.b = 1 - y(O.positionScreen.z * O.positionScreen.w, ot, ut), Z.r = Z.g = Z.b = 1 - y(M.positionScreen.z * M.positionScreen.w, ot, ut), et.r = et.g = et.b = 1 - y(P.positionScreen.z * P.positionScreen.w, ot, ut), tt.addColors(Z, et).multiplyScalar(.5), at = a(Y, Z, et, tt), u(X, V, $, J, K, Q, 0, 0, 1, 0, 0, 1, at)) : D instanceof THREE.MeshNormalMaterial && (D.shading === THREE.FlatShading ? (xt.copy(_.normalModel).applyMatrix3(Tt), G.setRGB(xt.x, xt.y, xt.z).multiplyScalar(.5).addScalar(.5), !0 === D.wireframe ? n(G, D.wireframeLinewidth, D.wireframeLinecap, D.wireframeLinejoin) : r(G)) : D.shading === THREE.SmoothShading && (xt.copy(_.vertexNormalsModel[0]).applyMatrix3(Tt), Y.setRGB(xt.x, xt.y, xt.z).multiplyScalar(.5).addScalar(.5), xt.copy(_.vertexNormalsModel[1]).applyMatrix3(Tt), Z.setRGB(xt.x, xt.y, xt.z).multiplyScalar(.5).addScalar(.5), xt.copy(_.vertexNormalsModel[2]).applyMatrix3(Tt), et.setRGB(xt.x, xt.y, xt.z).multiplyScalar(.5).addScalar(.5), tt.addColors(Z, et).multiplyScalar(.5), at = a(Y, Z, et, tt), u(X, V, $, J, K, Q, 0, 0, 1, 0, 0, 1, at)))
							}
						}
						gt.union(yt)
					}
				}
				A.setTransform(1, 0, 0, 1, 0, 0)
			}
		}
	}, THREE.ShaderChunk = {
		fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
		fog_fragment: "#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
		envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
		envmap_fragment: "#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
		envmap_pars_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",
		worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
		envmap_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",
		map_particle_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
		map_particle_fragment: "#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",
		map_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",
		map_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
		map_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
		map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",
		lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
		lightmap_pars_vertex: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
		lightmap_fragment: "#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",
		lightmap_vertex: "#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",
		bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
		normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
		specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
		specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
		lights_lambert_pars_vertex: "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
		lights_lambert_vertex: "vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
		lights_phong_pars_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",
		lights_phong_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
		lights_phong_pars_fragment: "uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
		lights_phong_fragment: "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
		color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
		color_fragment: "#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",
		color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
		color_vertex: "#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",
		skinning_pars_vertex: "#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
		skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
		skinning_vertex: "#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif",
		morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
		morphtarget_vertex: "#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
		default_vertex: "vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",
		morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
		skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix 	+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",
		defaultnormal_vertex: "vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
		shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",
		shadowmap_fragment: "#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
		shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",
		shadowmap_vertex: "#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",
		alphatest_fragment: "#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",
		linear_to_gamma_fragment: "#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"
	}, THREE.UniformsUtils = {
		merge: function(e) {
			var t, n, r, i = {};
			for (t = 0; t < e.length; t++)
				for (n in r = this.clone(e[t]), r) i[n] = r[n];
			return i
		},
		clone: function(e) {
			var t, n, r, i = {};
			for (t in e)
				for (n in i[t] = {}, e[t]) r = e[t][n], i[t][n] = r instanceof THREE.Color || r instanceof THREE.Vector2 || r instanceof THREE.Vector3 || r instanceof THREE.Vector4 || r instanceof THREE.Matrix4 || r instanceof THREE.Texture ? r.clone() : r instanceof Array ? r.slice() : r;
			return i
		}
	}, THREE.UniformsLib = {
		common: {
			diffuse: {
				type: "c",
				value: new THREE.Color(15658734)
			},
			opacity: {
				type: "f",
				value: 1
			},
			map: {
				type: "t",
				value: null
			},
			offsetRepeat: {
				type: "v4",
				value: new THREE.Vector4(0, 0, 1, 1)
			},
			lightMap: {
				type: "t",
				value: null
			},
			specularMap: {
				type: "t",
				value: null
			},
			envMap: {
				type: "t",
				value: null
			},
			flipEnvMap: {
				type: "f",
				value: -1
			},
			useRefract: {
				type: "i",
				value: 0
			},
			reflectivity: {
				type: "f",
				value: 1
			},
			refractionRatio: {
				type: "f",
				value: .98
			},
			combine: {
				type: "i",
				value: 0
			},
			morphTargetInfluences: {
				type: "f",
				value: 0
			}
		},
		bump: {
			bumpMap: {
				type: "t",
				value: null
			},
			bumpScale: {
				type: "f",
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				type: "t",
				value: null
			},
			normalScale: {
				type: "v2",
				value: new THREE.Vector2(1, 1)
			}
		},
		fog: {
			fogDensity: {
				type: "f",
				value: 25e-5
			},
			fogNear: {
				type: "f",
				value: 1
			},
			fogFar: {
				type: "f",
				value: 2e3
			},
			fogColor: {
				type: "c",
				value: new THREE.Color(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				type: "fv",
				value: []
			},
			directionalLightDirection: {
				type: "fv",
				value: []
			},
			directionalLightColor: {
				type: "fv",
				value: []
			},
			hemisphereLightDirection: {
				type: "fv",
				value: []
			},
			hemisphereLightSkyColor: {
				type: "fv",
				value: []
			},
			hemisphereLightGroundColor: {
				type: "fv",
				value: []
			},
			pointLightColor: {
				type: "fv",
				value: []
			},
			pointLightPosition: {
				type: "fv",
				value: []
			},
			pointLightDistance: {
				type: "fv1",
				value: []
			},
			spotLightColor: {
				type: "fv",
				value: []
			},
			spotLightPosition: {
				type: "fv",
				value: []
			},
			spotLightDirection: {
				type: "fv",
				value: []
			},
			spotLightDistance: {
				type: "fv1",
				value: []
			},
			spotLightAngleCos: {
				type: "fv1",
				value: []
			},
			spotLightExponent: {
				type: "fv1",
				value: []
			}
		},
		particle: {
			psColor: {
				type: "c",
				value: new THREE.Color(15658734)
			},
			opacity: {
				type: "f",
				value: 1
			},
			size: {
				type: "f",
				value: 1
			},
			scale: {
				type: "f",
				value: 1
			},
			map: {
				type: "t",
				value: null
			},
			fogDensity: {
				type: "f",
				value: 25e-5
			},
			fogNear: {
				type: "f",
				value: 1
			},
			fogFar: {
				type: "f",
				value: 2e3
			},
			fogColor: {
				type: "c",
				value: new THREE.Color(16777215)
			}
		},
		shadowmap: {
			shadowMap: {
				type: "tv",
				value: []
			},
			shadowMapSize: {
				type: "v2v",
				value: []
			},
			shadowBias: {
				type: "fv1",
				value: []
			},
			shadowDarkness: {
				type: "fv1",
				value: []
			},
			shadowMatrix: {
				type: "m4v",
				value: []
			}
		}
	}, THREE.ShaderLib = {
		basic: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
			vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		lambert: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				emissive: {
					type: "c",
					value: new THREE.Color(0)
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		phong: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				emissive: {
					type: "c",
					value: new THREE.Color(0)
				},
				specular: {
					type: "c",
					value: new THREE.Color(1118481)
				},
				shininess: {
					type: "f",
					value: 30
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		particle_basic: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
			vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
			fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, "void main() {\ngl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		dashed: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
				scale: {
					type: "f",
					value: 1
				},
				dashSize: {
					type: "f",
					value: 1
				},
				totalSize: {
					type: "f",
					value: 2
				}
			}]),
			vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
			fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
		},
		depth: {
			uniforms: {
				mNear: {
					type: "f",
					value: 1
				},
				mFar: {
					type: "f",
					value: 2e3
				},
				opacity: {
					type: "f",
					value: 1
				}
			},
			vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"
		},
		normal: {
			uniforms: {
				opacity: {
					type: "f",
					value: 1
				}
			},
			vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
			fragmentShader: "uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"
		},
		normalmap: {
			uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
				enableAO: {
					type: "i",
					value: 0
				},
				enableDiffuse: {
					type: "i",
					value: 0
				},
				enableSpecular: {
					type: "i",
					value: 0
				},
				enableReflection: {
					type: "i",
					value: 0
				},
				enableDisplacement: {
					type: "i",
					value: 0
				},
				tDisplacement: {
					type: "t",
					value: null
				},
				tDiffuse: {
					type: "t",
					value: null
				},
				tCube: {
					type: "t",
					value: null
				},
				tNormal: {
					type: "t",
					value: null
				},
				tSpecular: {
					type: "t",
					value: null
				},
				tAO: {
					type: "t",
					value: null
				},
				uNormalScale: {
					type: "v2",
					value: new THREE.Vector2(1, 1)
				},
				uDisplacementBias: {
					type: "f",
					value: 0
				},
				uDisplacementScale: {
					type: "f",
					value: 1
				},
				diffuse: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				specular: {
					type: "c",
					value: new THREE.Color(1118481)
				},
				ambient: {
					type: "c",
					value: new THREE.Color(16777215)
				},
				shininess: {
					type: "f",
					value: 30
				},
				opacity: {
					type: "f",
					value: 1
				},
				useRefract: {
					type: "i",
					value: 0
				},
				refractionRatio: {
					type: "f",
					value: .98
				},
				reflectivity: {
					type: "f",
					value: .5
				},
				uOffset: {
					type: "v2",
					value: new THREE.Vector2(0, 0)
				},
				uRepeat: {
					type: "v2",
					value: new THREE.Vector2(1, 1)
				},
				wrapRGB: {
					type: "v3",
					value: new THREE.Vector3(1, 1, 1)
				}
			}]),
			fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
			vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned 	  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned 	  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")
		},
		cube: {
			uniforms: {
				tCube: {
					type: "t",
					value: null
				},
				tFlip: {
					type: "f",
					value: -1
				}
			},
			vertexShader: "varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"
		},
		depthRGBA: {
			uniforms: {},
			vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
			fragmentShader: "vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"
		}
	}, THREE.WebGLRenderer = function(e) {
		function t(e, t) {
			var n = e.vertices.length,
				r = t.material;
			if (r.attributes) {
				void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
				for (var i in r.attributes) {
					var s = r.attributes[i];
					if (!s.__webglInitialized || s.createUniqueBuffers) {
						s.__webglInitialized = !0;
						var o = 1;
						"v2" === s.type ? o = 2 : "v3" === s.type ? o = 3 : "v4" === s.type ? o = 4 : "c" === s.type && (o = 3), s.size = o, s.array = new Float32Array(n * o), s.buffer = Tt.createBuffer(), s.buffer.belongsToAttribute = i, s.needsUpdate = !0
					}
					e.__webglCustomAttributesList.push(s)
				}
			}
		}

		function n(e, t) {
			var n = t.geometry,
				o = e.faces3,
				u = 3 * o.length,
				a = 1 * o.length,
				f = 3 * o.length,
				o = r(t, e),
				l = s(o),
				c = i(o),
				h = o.vertexColors ? o.vertexColors : !1;
			e.__vertexArray = new Float32Array(3 * u), c && (e.__normalArray = new Float32Array(3 * u)), n.hasTangents && (e.__tangentArray = new Float32Array(4 * u)), h && (e.__colorArray = new Float32Array(3 * u)), l && (0 < n.faceVertexUvs.length && (e.__uvArray = new Float32Array(2 * u)), 1 < n.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * u))), t.geometry.skinWeights.length && t.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * u), e.__skinWeightArray = new Float32Array(4 * u)), e.__faceArray = new Uint16Array(3 * a), e.__lineArray = new Uint16Array(2 * f);
			if (e.numMorphTargets)
				for (e.__morphTargetsArrays = [], n = 0, l = e.numMorphTargets; n < l; n++) e.__morphTargetsArrays.push(new Float32Array(3 * u));
			if (e.numMorphNormals)
				for (e.__morphNormalsArrays = [], n = 0, l = e.numMorphNormals; n < l; n++) e.__morphNormalsArrays.push(new Float32Array(3 * u));
			e.__webglFaceCount = 3 * a, e.__webglLineCount = 2 * f;
			if (o.attributes) {
				void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []);
				for (var p in o.attributes) {
					var a = o.attributes[p],
						f = {},
						d;
					for (d in a) f[d] = a[d];
					if (!f.__webglInitialized || f.createUniqueBuffers) f.__webglInitialized = !0, n = 1, "v2" === f.type ? n = 2 : "v3" === f.type ? n = 3 : "v4" === f.type ? n = 4 : "c" === f.type && (n = 3), f.size = n, f.array = new Float32Array(u * n), f.buffer = Tt.createBuffer(), f.buffer.belongsToAttribute = p, a.needsUpdate = !0, f.__original = a;
					e.__webglCustomAttributesList.push(f)
				}
			}
			e.__inittedArrays = !0
		}

		function r(e, t) {
			return e.material instanceof THREE.MeshFaceMaterial ? e.material.materials[t.materialIndex] : e.material
		}

		function i(e) {
			return e instanceof THREE.MeshBasicMaterial && !e.envMap || e instanceof THREE.MeshDepthMaterial ? !1 : e && void 0 !== e.shading && e.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading
		}

		function s(e) {
			return e.map || e.lightMap || e.bumpMap || e.normalMap || e.specularMap || e instanceof THREE.ShaderMaterial ? !0 : !1
		}

		function o(e, t, n, r) {
			var i, s, o, a;
			for (s in t) o = t[s], i = n[s], 0 <= o && (i ? (a = i.itemSize, Tt.bindBuffer(Tt.ARRAY_BUFFER, i.buffer), u(o), Tt.vertexAttribPointer(o, a, Tt.FLOAT, !1, 0, r * a * 4)) : e.defaultAttributeValues && (2 === e.defaultAttributeValues[s].length ? Tt.vertexAttrib2fv(o, e.defaultAttributeValues[s]) : 3 === e.defaultAttributeValues[s].length && Tt.vertexAttrib3fv(o, e.defaultAttributeValues[s])))
		}

		function u(e) {
			0 === mt[e] && (Tt.enableVertexAttribArray(e), mt[e] = 1)
		}

		function a() {
			for (var e in mt) 1 === mt[e] && (Tt.disableVertexAttribArray(e), mt[e] = 0)
		}

		function f(e, t) {
			return e.z !== t.z ? t.z - e.z : e.id - t.id
		}

		function l(e, t) {
			return t[0] - e[0]
		}

		function c(e, t, n) {
			if (e.length)
				for (var r = 0, i = e.length; r < i; r++) Q = V = null, J = K = Z = Y = st = it = et = -1, St = !0, e[r].render(t, n, dt, vt), Q = V = null, J = K = Z = Y = st = it = et = -1, St = !0
		}

		function h(e, t, n, r, i, s, o, u) {
			var a, f, l, c;
			t ? (f = e.length - 1, c = t = -1) : (f = 0, t = e.length, c = 1);
			for (var h = f; h !== t; h += c)
				if (a = e[h], a.render) {
					f = a.object, l = a.buffer;
					if (u) a = u;
					else {
						a = a[n];
						if (!a) continue;
						o && z.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst), z.setDepthTest(a.depthTest), z.setDepthWrite(a.depthWrite), C(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
					}
					z.setMaterialFaces(a), l instanceof THREE.BufferGeometry ? z.renderBufferDirect(r, i, s, a, l, f) : z.renderBuffer(r, i, s, a, l, f)
				}
		}

		function p(e, t, n, r, i, s, o) {
			for (var u, a, f = 0, l = e.length; f < l; f++)
				if (u = e[f], a = u.object, a.visible) {
					if (o) u = o;
					else {
						u = u[t];
						if (!u) continue;
						s && z.setBlending(u.blending, u.blendEquation, u.blendSrc, u.blendDst), z.setDepthTest(u.depthTest), z.setDepthWrite(u.depthWrite), C(u.polygonOffset, u.polygonOffsetFactor, u.polygonOffsetUnits)
					}
					z.renderImmediateObject(n, r, i, u, a)
				}
		}

		function d(e, r) {
			var i, s, o;
			if (void 0 === e.__webglInit && (e.__webglInit = !0, e._modelViewMatrix = new THREE.Matrix4, e._normalMatrix = new THREE.Matrix3, void 0 !== e.geometry && void 0 === e.geometry.__webglInit && (e.geometry.__webglInit = !0, e.geometry.addEventListener("dispose", Rt)), s = e.geometry, void 0 !== s))
				if (s instanceof THREE.BufferGeometry) {
					var u, a;
					for (o in s.attributes) a = "index" === o ? Tt.ELEMENT_ARRAY_BUFFER : Tt.ARRAY_BUFFER, u = s.attributes[o], u.buffer = Tt.createBuffer(), Tt.bindBuffer(a, u.buffer), Tt.bufferData(a, u.array, Tt.STATIC_DRAW)
				} else if (e instanceof THREE.Mesh) {
				for (i in o = e.material, void 0 === s.geometryGroups && s.makeGroups(o instanceof THREE.MeshFaceMaterial), s.geometryGroups)
					if (o = s.geometryGroups[i], !o.__webglVertexBuffer) {
						u = o, u.__webglVertexBuffer = Tt.createBuffer(), u.__webglNormalBuffer = Tt.createBuffer(), u.__webglTangentBuffer = Tt.createBuffer(), u.__webglColorBuffer = Tt.createBuffer(), u.__webglUVBuffer = Tt.createBuffer(), u.__webglUV2Buffer = Tt.createBuffer(), u.__webglSkinIndicesBuffer = Tt.createBuffer(), u.__webglSkinWeightsBuffer = Tt.createBuffer(), u.__webglFaceBuffer = Tt.createBuffer(), u.__webglLineBuffer = Tt.createBuffer();
						var f = a = void 0;
						if (u.numMorphTargets)
							for (u.__webglMorphTargetsBuffers = [], a = 0, f = u.numMorphTargets; a < f; a++) u.__webglMorphTargetsBuffers.push(Tt.createBuffer());
						if (u.numMorphNormals)
							for (u.__webglMorphNormalsBuffers = [], a = 0, f = u.numMorphNormals; a < f; a++) u.__webglMorphNormalsBuffers.push(Tt.createBuffer());
						z.info.memory.geometries++, n(o, e), s.verticesNeedUpdate = !0, s.morphTargetsNeedUpdate = !0, s.elementsNeedUpdate = !0, s.uvsNeedUpdate = !0, s.normalsNeedUpdate = !0, s.tangentsNeedUpdate = !0, s.colorsNeedUpdate = !0
					}
			} else e instanceof THREE.Line ? s.__webglVertexBuffer || (o = s, o.__webglVertexBuffer = Tt.createBuffer(), o.__webglColorBuffer = Tt.createBuffer(), o.__webglLineDistanceBuffer = Tt.createBuffer(), z.info.memory.geometries++, o = s, u = o.vertices.length, o.__vertexArray = new Float32Array(3 * u), o.__colorArray = new Float32Array(3 * u), o.__lineDistanceArray = new Float32Array(1 * u), o.__webglLineCount = u, t(o, e), s.verticesNeedUpdate = !0, s.colorsNeedUpdate = !0, s.lineDistancesNeedUpdate = !0) : e instanceof THREE.ParticleSystem && !s.__webglVertexBuffer && (o = s, o.__webglVertexBuffer = Tt.createBuffer(), o.__webglColorBuffer = Tt.createBuffer(), z.info.memory.geometries++, o = s, u = o.vertices.length, o.__vertexArray = new Float32Array(3 * u), o.__colorArray = new Float32Array(3 * u), o.__sortArray = [], o.__webglParticleCount = u, t(o, e), s.verticesNeedUpdate = !0, s.colorsNeedUpdate = !0);
			if (void 0 === e.__webglActive) {
				if (e instanceof THREE.Mesh) {
					if (s = e.geometry, s instanceof THREE.BufferGeometry) v(r.__webglObjects, s, e);
					else if (s instanceof THREE.Geometry)
						for (i in s.geometryGroups) o = s.geometryGroups[i], v(r.__webglObjects, o, e)
				} else e instanceof THREE.Line || e instanceof THREE.ParticleSystem ? (s = e.geometry, v(r.__webglObjects, s, e)) : e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback ? r.__webglObjectsImmediate.push({
					id: null,
					object: e,
					opaque: null,
					transparent: null,
					z: 0
				}) : e instanceof THREE.Sprite ? r.__webglSprites.push(e) : e instanceof THREE.LensFlare && r.__webglFlares.push(e);
				e.__webglActive = !0
			}
		}

		function v(e, t, n) {
			e.push({
				id: null,
				buffer: t,
				object: n,
				opaque: null,
				transparent: null,
				z: 0
			})
		}

		function m(e) {
			for (var t in e.attributes)
				if (e.attributes[t].needsUpdate) return !0;
			return !1
		}

		function g(e) {
			for (var t in e.attributes) e.attributes[t].needsUpdate = !1
		}

		function y(e, t) {
			e instanceof THREE.Mesh || e instanceof THREE.ParticleSystem || e instanceof THREE.Line ? b(t.__webglObjects, e) : e instanceof THREE.Sprite ? w(t.__webglSprites, e) : e instanceof THREE.LensFlare ? w(t.__webglFlares, e) : (e instanceof THREE.ImmediateRenderObject || e.immediateRenderCallback) && b(t.__webglObjectsImmediate, e), delete e.__webglActive
		}

		function b(e, t) {
			for (var n = e.length - 1; 0 <= n; n--) e[n].object === t && e.splice(n, 1)
		}

		function w(e, t) {
			for (var n = e.length - 1; 0 <= n; n--) e[n] === t && e.splice(n, 1)
		}

		function E(e, t, n, r, i) {
			G = 0, r.needsUpdate && (r.program && Vt(r), z.initMaterial(r, t, n, i), r.needsUpdate = !1), r.morphTargets && !i.__webglMorphTargetInfluences && (i.__webglMorphTargetInfluences = new Float32Array(z.maxMorphTargets));
			var s = !1,
				o = r.program,
				u = o.uniforms,
				a = r.uniforms;
			o !== V && (Tt.useProgram(o), V = o, s = !0), r.id !== J && (J = r.id, s = !0);
			if (s || e !== Q) Tt.uniformMatrix4fv(u.projectionMatrix, !1, e.projectionMatrix.elements), e !== Q && (Q = e);
			if (r.skinning)
				if (Pt && i.useVertexTexture) {
					if (null !== u.boneTexture) {
						var f = S();
						Tt.uniform1i(u.boneTexture, f), z.setTexture(i.boneTexture, f)
					}
					null !== u.boneTextureWidth && Tt.uniform1i(u.boneTextureWidth, i.boneTextureWidth), null !== u.boneTextureHeight && Tt.uniform1i(u.boneTextureHeight, i.boneTextureHeight)
				} else null !== u.boneGlobalMatrices && Tt.uniformMatrix4fv(u.boneGlobalMatrices, !1, i.boneMatrices);
			if (s) {
				n && r.fog && (a.fogColor.value = n.color, n instanceof THREE.Fog ? (a.fogNear.value = n.near, a.fogFar.value = n.far) : n instanceof THREE.FogExp2 && (a.fogDensity.value = n.density));
				if (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r.lights) {
					if (St) {
						var l, c = f = 0,
							h = 0,
							p, d, v, m = xt,
							g = m.directional.colors,
							y = m.directional.positions,
							b = m.point.colors,
							w = m.point.positions,
							E = m.point.distances,
							N = m.spot.colors,
							C = m.spot.positions,
							k = m.spot.distances,
							L = m.spot.directions,
							O = m.spot.anglesCos,
							M = m.spot.exponents,
							P = m.hemi.skyColors,
							H = m.hemi.groundColors,
							B = m.hemi.positions,
							j = 0,
							F = 0,
							I = 0,
							q = 0,
							R = 0,
							U = 0,
							W = 0,
							X = 0,
							$ = l = 0;
						n = v = $ = 0;
						for (s = t.length; n < s; n++)
							if (l = t[n], !l.onlyShadow)
								if (p = l.color, d = l.intensity, v = l.distance, l instanceof THREE.AmbientLight) l.visible && (z.gammaInput ? (f += p.r * p.r, c += p.g * p.g, h += p.b * p.b) : (f += p.r, c += p.g, h += p.b));
								else if (l instanceof THREE.DirectionalLight) {
							if (R += 1, l.visible && (Et.setFromMatrixPosition(l.matrixWorld), wt.setFromMatrixPosition(l.target.matrixWorld), Et.sub(wt), Et.normalize(), 0 !== Et.x || 0 !== Et.y || 0 !== Et.z)) l = 3 * j, y[l] = Et.x, y[l + 1] = Et.y, y[l + 2] = Et.z, z.gammaInput ? x(g, l, p, d * d) : T(g, l, p, d), j += 1
						} else l instanceof THREE.PointLight ? (U += 1, l.visible && ($ = 3 * F, z.gammaInput ? x(b, $, p, d * d) : T(b, $, p, d), wt.setFromMatrixPosition(l.matrixWorld), w[$] = wt.x, w[$ + 1] = wt.y, w[$ + 2] = wt.z, E[F] = v, F += 1)) : l instanceof THREE.SpotLight ? (W += 1, l.visible && ($ = 3 * I, z.gammaInput ? x(N, $, p, d * d) : T(N, $, p, d), wt.setFromMatrixPosition(l.matrixWorld), C[$] = wt.x, C[$ + 1] = wt.y, C[$ + 2] = wt.z, k[I] = v, Et.copy(wt), wt.setFromMatrixPosition(l.target.matrixWorld), Et.sub(wt), Et.normalize(), L[$] = Et.x, L[$ + 1] = Et.y, L[$ + 2] = Et.z, O[I] = Math.cos(l.angle), M[I] = l.exponent, I += 1)) : l instanceof THREE.HemisphereLight && (X += 1, l.visible && (Et.setFromMatrixPosition(l.matrixWorld), Et.normalize(), 0 !== Et.x || 0 !== Et.y || 0 !== Et.z)) && (v = 3 * q, B[v] = Et.x, B[v + 1] = Et.y, B[v + 2] = Et.z, p = l.color, l = l.groundColor, z.gammaInput ? (d *= d, x(P, v, p, d), x(H, v, l, d)) : (T(P, v, p, d), T(H, v, l, d)), q += 1);
						n = 3 * j;
						for (s = Math.max(g.length, 3 * R); n < s; n++) g[n] = 0;
						n = 3 * F;
						for (s = Math.max(b.length, 3 * U); n < s; n++) b[n] = 0;
						n = 3 * I;
						for (s = Math.max(N.length, 3 * W); n < s; n++) N[n] = 0;
						n = 3 * q;
						for (s = Math.max(P.length, 3 * X); n < s; n++) P[n] = 0;
						n = 3 * q;
						for (s = Math.max(H.length, 3 * X); n < s; n++) H[n] = 0;
						m.directional.length = j, m.point.length = F, m.spot.length = I, m.hemi.length = q, m.ambient[0] = f, m.ambient[1] = c, m.ambient[2] = h, St = !1
					}
					n = xt, a.ambientLightColor.value = n.ambient, a.directionalLightColor.value = n.directional.colors, a.directionalLightDirection.value = n.directional.positions, a.pointLightColor.value = n.point.colors, a.pointLightPosition.value = n.point.positions, a.pointLightDistance.value = n.point.distances, a.spotLightColor.value = n.spot.colors, a.spotLightPosition.value = n.spot.positions, a.spotLightDistance.value = n.spot.distances, a.spotLightDirection.value = n.spot.directions, a.spotLightAngleCos.value = n.spot.anglesCos, a.spotLightExponent.value = n.spot.exponents, a.hemisphereLightSkyColor.value = n.hemi.skyColors, a.hemisphereLightGroundColor.value = n.hemi.groundColors, a.hemisphereLightDirection.value = n.hemi.positions
				}
				if (r instanceof THREE.MeshBasicMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.MeshPhongMaterial) {
					a.opacity.value = r.opacity, z.gammaInput ? a.diffuse.value.copyGammaToLinear(r.color) : a.diffuse.value = r.color, a.map.value = r.map, a.lightMap.value = r.lightMap, a.specularMap.value = r.specularMap, r.bumpMap && (a.bumpMap.value = r.bumpMap, a.bumpScale.value = r.bumpScale), r.normalMap && (a.normalMap.value = r.normalMap, a.normalScale.value.copy(r.normalScale));
					var K;
					r.map ? K = r.map : r.specularMap ? K = r.specularMap : r.normalMap ? K = r.normalMap : r.bumpMap && (K = r.bumpMap), void 0 !== K && (n = K.offset, K = K.repeat, a.offsetRepeat.value.set(n.x, n.y, K.x, K.y)), a.envMap.value = r.envMap, a.flipEnvMap.value = r.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1, a.reflectivity.value = r.reflectivity, a.refractionRatio.value = r.refractionRatio, a.combine.value = r.combine, a.useRefract.value = r.envMap && r.envMap.mapping instanceof THREE.CubeRefractionMapping
				}
				r instanceof THREE.LineBasicMaterial ? (a.diffuse.value = r.color, a.opacity.value = r.opacity) : r instanceof THREE.LineDashedMaterial ? (a.diffuse.value = r.color, a.opacity.value = r.opacity, a.dashSize.value = r.dashSize, a.totalSize.value = r.dashSize + r.gapSize, a.scale.value = r.scale) : r instanceof THREE.ParticleSystemMaterial ? (a.psColor.value = r.color, a.opacity.value = r.opacity, a.size.value = r.size, a.scale.value = D.height / 2, a.map.value = r.map) : r instanceof THREE.MeshPhongMaterial ? (a.shininess.value = r.shininess, z.gammaInput ? (a.ambient.value.copyGammaToLinear(r.ambient), a.emissive.value.copyGammaToLinear(r.emissive), a.specular.value.copyGammaToLinear(r.specular)) : (a.ambient.value = r.ambient, a.emissive.value = r.emissive, a.specular.value = r.specular), r.wrapAround && a.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshLambertMaterial ? (z.gammaInput ? (a.ambient.value.copyGammaToLinear(r.ambient), a.emissive.value.copyGammaToLinear(r.emissive)) : (a.ambient.value = r.ambient, a.emissive.value = r.emissive), r.wrapAround && a.wrapRGB.value.copy(r.wrapRGB)) : r instanceof THREE.MeshDepthMaterial ? (a.mNear.value = e.near, a.mFar.value = e.far, a.opacity.value = r.opacity) : r instanceof THREE.MeshNormalMaterial && (a.opacity.value = r.opacity);
				if (i.receiveShadow && !r._shadowPass && a.shadowMatrix)
					for (n = K = 0, s = t.length; n < s; n++) f = t[n], f.castShadow && (f instanceof THREE.SpotLight || f instanceof THREE.DirectionalLight && !f.shadowCascade) && (a.shadowMap.value[K] = f.shadowMap, a.shadowMapSize.value[K] = f.shadowMapSize, a.shadowMatrix.value[K] = f.shadowMatrix, a.shadowDarkness.value[K] = f.shadowDarkness, a.shadowBias.value[K] = f.shadowBias, K++);
				t = r.uniformsList, a = 0;
				for (K = t.length; a < K; a++)
					if (s = o.uniforms[t[a][1]])
						if (n = t[a][0], c = n.type, f = n.value, "i" === c) Tt.uniform1i(s, f);
						else if ("f" === c) Tt.uniform1f(s, f);
				else if ("v2" === c) Tt.uniform2f(s, f.x, f.y);
				else if ("v3" === c) Tt.uniform3f(s, f.x, f.y, f.z);
				else if ("v4" === c) Tt.uniform4f(s, f.x, f.y, f.z, f.w);
				else if ("c" === c) Tt.uniform3f(s, f.r, f.g, f.b);
				else if ("iv1" === c) Tt.uniform1iv(s, f);
				else if ("iv" === c) Tt.uniform3iv(s, f);
				else if ("fv1" === c) Tt.uniform1fv(s, f);
				else if ("fv" === c) Tt.uniform3fv(s, f);
				else if ("v2v" === c) {
					void 0 === n._array && (n._array = new Float32Array(2 * f.length)), c = 0;
					for (h = f.length; c < h; c++) m = 2 * c, n._array[m] = f[c].x, n._array[m + 1] = f[c].y;
					Tt.uniform2fv(s, n._array)
				} else if ("v3v" === c) {
					void 0 === n._array && (n._array = new Float32Array(3 * f.length)), c = 0;
					for (h = f.length; c < h; c++) m = 3 * c, n._array[m] = f[c].x, n._array[m + 1] = f[c].y, n._array[m + 2] = f[c].z;
					Tt.uniform3fv(s, n._array)
				} else if ("v4v" === c) {
					void 0 === n._array && (n._array = new Float32Array(4 * f.length)), c = 0;
					for (h = f.length; c < h; c++) m = 4 * c, n._array[m] = f[c].x, n._array[m + 1] = f[c].y, n._array[m + 2] = f[c].z, n._array[m + 3] = f[c].w;
					Tt.uniform4fv(s, n._array)
				} else if ("m4" === c) void 0 === n._array && (n._array = new Float32Array(16)), f.flattenToArray(n._array), Tt.uniformMatrix4fv(s, !1, n._array);
				else if ("m4v" === c) {
					void 0 === n._array && (n._array = new Float32Array(16 * f.length)), c = 0;
					for (h = f.length; c < h; c++) f[c].flattenToArrayOffset(n._array, 16 * c);
					Tt.uniformMatrix4fv(s, !1, n._array)
				} else if ("t" === c) {
					if (m = f, f = S(), Tt.uniform1i(s, f), m)
						if (m.image instanceof Array && 6 === m.image.length) {
							if (n = m, s = f, 6 === n.image.length)
								if (n.needsUpdate) {
									n.image.__webglTextureCube || (n.addEventListener("dispose", Ut), n.image.__webglTextureCube = Tt.createTexture(), z.info.memory.textures++), Tt.activeTexture(Tt.TEXTURE0 + s), Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, n.image.__webglTextureCube), Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, n.flipY), s = n instanceof THREE.CompressedTexture, f = [];
									for (c = 0; 6 > c; c++) z.autoScaleCubemaps && !s ? (h = f, m = c, g = n.image[c], b = Mt, g.width <= b && g.height <= b || (w = Math.max(g.width, g.height), y = Math.floor(g.width * b / w), b = Math.floor(g.height * b / w), w = document.createElement("canvas"), w.width = y, w.height = b, w.getContext("2d").drawImage(g, 0, 0, g.width, g.height, 0, 0, y, b), g = w), h[m] = g) : f[c] = n.image[c];
									c = f[0], h = THREE.Math.isPowerOfTwo(c.width) && THREE.Math.isPowerOfTwo(c.height), m = _(n.format), g = _(n.type), A(Tt.TEXTURE_CUBE_MAP, n, h);
									for (c = 0; 6 > c; c++)
										if (s)
											for (b = f[c].mipmaps, w = 0, E = b.length; w < E; w++) y = b[w], n.format !== THREE.RGBAFormat ? Tt.compressedTexImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + c, w, m, y.width, y.height, 0, y.data) : Tt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + c, w, m, y.width, y.height, 0, m, g, y.data);
										else Tt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + c, 0, m, m, g, f[c]);
									n.generateMipmaps && h && Tt.generateMipmap(Tt.TEXTURE_CUBE_MAP), n.needsUpdate = !1, n.onUpdate && n.onUpdate()
								} else Tt.activeTexture(Tt.TEXTURE0 + s), Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, n.image.__webglTextureCube)
						} else m instanceof THREE.WebGLRenderTargetCube ? (n = m, Tt.activeTexture(Tt.TEXTURE0 + f), Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, n.__webglTexture)) : z.setTexture(m, f)
				} else if ("tv" === c) {
					void 0 === n._array && (n._array = []), c = 0;
					for (h = n.value.length; c < h; c++) n._array[c] = S();
					Tt.uniform1iv(s, n._array), c = 0;
					for (h = n.value.length; c < h; c++) m = n.value[c], f = n._array[c], m && z.setTexture(m, f)
				} else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + c);
				(r instanceof THREE.ShaderMaterial || r instanceof THREE.MeshPhongMaterial || r.envMap) && null !== u.cameraPosition && (wt.setFromMatrixPosition(e.matrixWorld), Tt.uniform3f(u.cameraPosition, wt.x, wt.y, wt.z)), (r instanceof THREE.MeshPhongMaterial || r instanceof THREE.MeshLambertMaterial || r instanceof THREE.ShaderMaterial || r.skinning) && null !== u.viewMatrix && Tt.uniformMatrix4fv(u.viewMatrix, !1, e.matrixWorldInverse.elements)
			}
			return Tt.uniformMatrix4fv(u.modelViewMatrix, !1, i._modelViewMatrix.elements), u.normalMatrix && Tt.uniformMatrix3fv(u.normalMatrix, !1, i._normalMatrix.elements), null !== u.modelMatrix && Tt.uniformMatrix4fv(u.modelMatrix, !1, i.matrixWorld.elements), o
		}

		function S() {
			var e = G;
			return e >= At && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + At), G += 1, e
		}

		function x(e, t, n, r) {
			e[t] = n.r * n.r * r, e[t + 1] = n.g * n.g * r, e[t + 2] = n.b * n.b * r
		}

		function T(e, t, n, r) {
			e[t] = n.r * r, e[t + 1] = n.g * r, e[t + 2] = n.b * r
		}

		function N(e) {
			e !== ft && (Tt.lineWidth(e), ft = e)
		}

		function C(e, t, n) {
			ot !== e && (e ? Tt.enable(Tt.POLYGON_OFFSET_FILL) : Tt.disable(Tt.POLYGON_OFFSET_FILL), ot = e), !e || ut === t && at === n || (Tt.polygonOffset(t, n), ut = t, at = n)
		}

		function k(e) {
			e = e.split("\n");
			for (var t = 0, n = e.length; t < n; t++) e[t] = t + 1 + ": " + e[t];
			return e.join("\n")
		}

		function L(e, t) {
			var n;
			return "fragment" === e ? n = Tt.createShader(Tt.FRAGMENT_SHADER) : "vertex" === e && (n = Tt.createShader(Tt.VERTEX_SHADER)), Tt.shaderSource(n, t), Tt.compileShader(n), Tt.getShaderParameter(n, Tt.COMPILE_STATUS) ? n : (console.error(Tt.getShaderInfoLog(n)), console.error(k(t)), null)
		}

		function A(e, t, n) {
			n ? (Tt.texParameteri(e, Tt.TEXTURE_WRAP_S, _(t.wrapS)), Tt.texParameteri(e, Tt.TEXTURE_WRAP_T, _(t.wrapT)), Tt.texParameteri(e, Tt.TEXTURE_MAG_FILTER, _(t.magFilter)), Tt.texParameteri(e, Tt.TEXTURE_MIN_FILTER, _(t.minFilter))) : (Tt.texParameteri(e, Tt.TEXTURE_WRAP_S, Tt.CLAMP_TO_EDGE), Tt.texParameteri(e, Tt.TEXTURE_WRAP_T, Tt.CLAMP_TO_EDGE), Tt.texParameteri(e, Tt.TEXTURE_MAG_FILTER, M(t.magFilter)), Tt.texParameteri(e, Tt.TEXTURE_MIN_FILTER, M(t.minFilter))), kt && t.type !== THREE.FloatType && (1 < t.anisotropy || t.__oldAnisotropy) && (Tt.texParameterf(e, kt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, _t)), t.__oldAnisotropy = t.anisotropy)
		}

		function O(e, t) {
			Tt.bindRenderbuffer(Tt.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (Tt.renderbufferStorage(Tt.RENDERBUFFER, Tt.DEPTH_COMPONENT16, t.width, t.height), Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (Tt.renderbufferStorage(Tt.RENDERBUFFER, Tt.DEPTH_STENCIL, t.width, t.height), Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.RENDERBUFFER, e)) : Tt.renderbufferStorage(Tt.RENDERBUFFER, Tt.RGBA4, t.width, t.height)
		}

		function M(e) {
			return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? Tt.NEAREST : Tt.LINEAR
		}

		function _(e) {
			if (e === THREE.RepeatWrapping) return Tt.REPEAT;
			if (e === THREE.ClampToEdgeWrapping) return Tt.CLAMP_TO_EDGE;
			if (e === THREE.MirroredRepeatWrapping) return Tt.MIRRORED_REPEAT;
			if (e === THREE.NearestFilter) return Tt.NEAREST;
			if (e === THREE.NearestMipMapNearestFilter) return Tt.NEAREST_MIPMAP_NEAREST;
			if (e === THREE.NearestMipMapLinearFilter) return Tt.NEAREST_MIPMAP_LINEAR;
			if (e === THREE.LinearFilter) return Tt.LINEAR;
			if (e === THREE.LinearMipMapNearestFilter) return Tt.LINEAR_MIPMAP_NEAREST;
			if (e === THREE.LinearMipMapLinearFilter) return Tt.LINEAR_MIPMAP_LINEAR;
			if (e === THREE.UnsignedByteType) return Tt.UNSIGNED_BYTE;
			if (e === THREE.UnsignedShort4444Type) return Tt.UNSIGNED_SHORT_4_4_4_4;
			if (e === THREE.UnsignedShort5551Type) return Tt.UNSIGNED_SHORT_5_5_5_1;
			if (e === THREE.UnsignedShort565Type) return Tt.UNSIGNED_SHORT_5_6_5;
			if (e === THREE.ByteType) return Tt.BYTE;
			if (e === THREE.ShortType) return Tt.SHORT;
			if (e === THREE.UnsignedShortType) return Tt.UNSIGNED_SHORT;
			if (e === THREE.IntType) return Tt.INT;
			if (e === THREE.UnsignedIntType) return Tt.UNSIGNED_INT;
			if (e === THREE.FloatType) return Tt.FLOAT;
			if (e === THREE.AlphaFormat) return Tt.ALPHA;
			if (e === THREE.RGBFormat) return Tt.RGB;
			if (e === THREE.RGBAFormat) return Tt.RGBA;
			if (e === THREE.LuminanceFormat) return Tt.LUMINANCE;
			if (e === THREE.LuminanceAlphaFormat) return Tt.LUMINANCE_ALPHA;
			if (e === THREE.AddEquation) return Tt.FUNC_ADD;
			if (e === THREE.SubtractEquation) return Tt.FUNC_SUBTRACT;
			if (e === THREE.ReverseSubtractEquation) return Tt.FUNC_REVERSE_SUBTRACT;
			if (e === THREE.ZeroFactor) return Tt.ZERO;
			if (e === THREE.OneFactor) return Tt.ONE;
			if (e === THREE.SrcColorFactor) return Tt.SRC_COLOR;
			if (e === THREE.OneMinusSrcColorFactor) return Tt.ONE_MINUS_SRC_COLOR;
			if (e === THREE.SrcAlphaFactor) return Tt.SRC_ALPHA;
			if (e === THREE.OneMinusSrcAlphaFactor) return Tt.ONE_MINUS_SRC_ALPHA;
			if (e === THREE.DstAlphaFactor) return Tt.DST_ALPHA;
			if (e === THREE.OneMinusDstAlphaFactor) return Tt.ONE_MINUS_DST_ALPHA;
			if (e === THREE.DstColorFactor) return Tt.DST_COLOR;
			if (e === THREE.OneMinusDstColorFactor) return Tt.ONE_MINUS_DST_COLOR;
			if (e === THREE.SrcAlphaSaturateFactor) return Tt.SRC_ALPHA_SATURATE;
			if (void 0 !== Lt) {
				if (e === THREE.RGB_S3TC_DXT1_Format) return Lt.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (e === THREE.RGBA_S3TC_DXT1_Format) return Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (e === THREE.RGBA_S3TC_DXT3_Format) return Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (e === THREE.RGBA_S3TC_DXT5_Format) return Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT
			}
			return 0
		}
		console.log("THREE.WebGLRenderer", THREE.REVISION), e = e || {};
		var D = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
			P = void 0 !== e.context ? e.context : null,
			H = void 0 !== e.precision ? e.precision : "highp",
			B = void 0 !== e.alpha ? e.alpha : !1,
			j = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
			F = void 0 !== e.antialias ? e.antialias : !1,
			I = void 0 !== e.stencil ? e.stencil : !0,
			q = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
			R = new THREE.Color(0),
			U = 0;
		this.domElement = D, this.context = null, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1, this.shadowMapAutoUpdate = !0, this.shadowMapType = THREE.PCFShadowMap, this.shadowMapCullFace = THREE.CullFaceFront, this.shadowMapCascade = this.shadowMapDebug = !1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0, this.renderPluginsPre = [], this.renderPluginsPost = [], this.info = {
			memory: {
				programs: 0,
				geometries: 0,
				textures: 0
			},
			render: {
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
			}
		};
		var z = this,
			W = [],
			X = 0,
			V = null,
			$ = null,
			J = -1,
			K = null,
			Q = null,
			G = 0,
			Y = -1,
			Z = -1,
			et = -1,
			tt = -1,
			nt = -1,
			rt = -1,
			it = -1,
			st = -1,
			ot = null,
			ut = null,
			at = null,
			ft = null,
			lt = 0,
			ct = 0,
			ht = D.width,
			pt = D.height,
			dt = 0,
			vt = 0,
			mt = new Uint8Array(16),
			gt = new THREE.Frustum,
			yt = new THREE.Matrix4,
			bt = new THREE.Matrix4,
			wt = new THREE.Vector3,
			Et = new THREE.Vector3,
			St = !0,
			xt = {
				ambient: [0, 0, 0],
				directional: {
					length: 0,
					colors: [],
					positions: []
				},
				point: {
					length: 0,
					colors: [],
					positions: [],
					distances: []
				},
				spot: {
					length: 0,
					colors: [],
					positions: [],
					distances: [],
					directions: [],
					anglesCos: [],
					exponents: []
				},
				hemi: {
					length: 0,
					skyColors: [],
					groundColors: [],
					positions: []
				}
			},
			Tt, Nt, Ct, kt, Lt;
		(function() {
			try {
				var e = {
					alpha: B,
					premultipliedAlpha: j,
					antialias: F,
					stencil: I,
					preserveDrawingBuffer: q
				};
				Tt = P || D.getContext("webgl", e) || D.getContext("experimental-webgl", e);
				if (null === Tt) throw "Error creating WebGL context."
			} catch (t) {
				console.error(t)
			}
			Nt = Tt.getExtension("OES_texture_float"), Tt.getExtension("OES_texture_float_linear"), Ct = Tt.getExtension("OES_standard_derivatives"), kt = Tt.getExtension("EXT_texture_filter_anisotropic") || Tt.getExtension("MOZ_EXT_texture_filter_anisotropic") || Tt.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), Lt = Tt.getExtension("WEBGL_compressed_texture_s3tc") || Tt.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || Tt.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"), Nt || console.log("THREE.WebGLRenderer: Float textures not supported."), Ct || console.log("THREE.WebGLRenderer: Standard derivatives not supported."), kt || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported."), Lt || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported."), void 0 === Tt.getShaderPrecisionFormat && (Tt.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		})(), Tt.clearColor(0, 0, 0, 1), Tt.clearDepth(1), Tt.clearStencil(0), Tt.enable(Tt.DEPTH_TEST), Tt.depthFunc(Tt.LEQUAL), Tt.frontFace(Tt.CCW), Tt.cullFace(Tt.BACK), Tt.enable(Tt.CULL_FACE), Tt.enable(Tt.BLEND), Tt.blendEquation(Tt.FUNC_ADD), Tt.blendFunc(Tt.SRC_ALPHA, Tt.ONE_MINUS_SRC_ALPHA), Tt.viewport(lt, ct, ht, pt), Tt.clearColor(R.r, R.g, R.b, U), this.context = Tt;
		var At = Tt.getParameter(Tt.MAX_TEXTURE_IMAGE_UNITS),
			Ot = Tt.getParameter(Tt.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		Tt.getParameter(Tt.MAX_TEXTURE_SIZE);
		var Mt = Tt.getParameter(Tt.MAX_CUBE_MAP_TEXTURE_SIZE),
			_t = kt ? Tt.getParameter(kt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
			Dt = 0 < Ot,
			Pt = Dt && Nt;
		Lt && Tt.getParameter(Tt.COMPRESSED_TEXTURE_FORMATS);
		var Ht = Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.HIGH_FLOAT),
			Bt = Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.MEDIUM_FLOAT);
		Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.LOW_FLOAT);
		var jt = Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.HIGH_FLOAT),
			Ft = Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.MEDIUM_FLOAT);
		Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.LOW_FLOAT), Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.HIGH_INT), Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.MEDIUM_INT), Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.LOW_INT), Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.HIGH_INT), Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.MEDIUM_INT), Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.LOW_INT);
		var It = 0 < Ht.precision && 0 < jt.precision,
			qt = 0 < Bt.precision && 0 < Ft.precision;
		"highp" !== H || It || (qt ? (H = "mediump", console.warn("WebGLRenderer: highp not supported, using mediump")) : (H = "lowp", console.warn("WebGLRenderer: highp and mediump not supported, using lowp"))), "mediump" !== H || qt || (H = "lowp", console.warn("WebGLRenderer: mediump not supported, using lowp")), this.getContext = function() {
			return Tt
		}, this.supportsVertexTextures = function() {
			return Dt
		}, this.supportsFloatTextures = function() {
			return Nt
		}, this.supportsStandardDerivatives = function() {
			return Ct
		}, this.supportsCompressedTextureS3TC = function() {
			return Lt
		}, this.getMaxAnisotropy = function() {
			return _t
		}, this.getPrecision = function() {
			return H
		}, this.setSize = function(e, t, n) {
			D.width = e * this.devicePixelRatio, D.height = t * this.devicePixelRatio, 1 !== this.devicePixelRatio && !1 !== n && (D.style.width = e + "px", D.style.height = t + "px"), this.setViewport(0, 0, e, t)
		}, this.setViewport = function(e, t, n, r) {
			lt = e * this.devicePixelRatio, ct = t * this.devicePixelRatio, ht = n * this.devicePixelRatio, pt = r * this.devicePixelRatio, Tt.viewport(lt, ct, ht, pt)
		}, this.setScissor = function(e, t, n, r) {
			Tt.scissor(e * this.devicePixelRatio, t * this.devicePixelRatio, n * this.devicePixelRatio, r * this.devicePixelRatio)
		}, this.enableScissorTest = function(e) {
			e ? Tt.enable(Tt.SCISSOR_TEST) : Tt.disable(Tt.SCISSOR_TEST)
		}, this.setClearColor = function(e, t) {
			R.set(e), U = void 0 !== t ? t : 1, Tt.clearColor(R.r, R.g, R.b, U)
		}, this.setClearColorHex = function(e, t) {
			console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, t)
		}, this.getClearColor = function() {
			return R
		}, this.getClearAlpha = function() {
			return U
		}, this.clear = function(e, t, n) {
			var r = 0;
			if (void 0 === e || e) r |= Tt.COLOR_BUFFER_BIT;
			if (void 0 === t || t) r |= Tt.DEPTH_BUFFER_BIT;
			if (void 0 === n || n) r |= Tt.STENCIL_BUFFER_BIT;
			Tt.clear(r)
		}, this.clearColor = function() {
			Tt.clear(Tt.COLOR_BUFFER_BIT)
		}, this.clearDepth = function() {
			Tt.clear(Tt.DEPTH_BUFFER_BIT)
		}, this.clearStencil = function() {
			Tt.clear(Tt.STENCIL_BUFFER_BIT)
		}, this.clearTarget = function(e, t, n, r) {
			this.setRenderTarget(e), this.clear(t, n, r)
		}, this.addPostPlugin = function(e) {
			e.init(this), this.renderPluginsPost.push(e)
		}, this.addPrePlugin = function(e) {
			e.init(this), this.renderPluginsPre.push(e)
		}, this.updateShadowMap = function(e, t) {
			V = null, J = K = st = it = et = -1, St = !0, Z = Y = -1, this.shadowMapPlugin.update(e, t)
		};
		var Rt = function(e) {
				e = e.target, e.removeEventListener("dispose", Rt), e.__webglInit = void 0;
				if (e instanceof THREE.BufferGeometry) {
					var t = e.attributes,
						n;
					for (n in t) void 0 !== t[n].buffer && Tt.deleteBuffer(t[n].buffer);
					z.info.memory.geometries--
				} else if (void 0 !== e.geometryGroups)
					for (t in e.geometryGroups) {
						n = e.geometryGroups[t];
						if (void 0 !== n.numMorphTargets)
							for (var r = 0, i = n.numMorphTargets; r < i; r++) Tt.deleteBuffer(n.__webglMorphTargetsBuffers[r]);
						if (void 0 !== n.numMorphNormals)
							for (r = 0, i = n.numMorphNormals; r < i; r++) Tt.deleteBuffer(n.__webglMorphNormalsBuffers[r]);
						Xt(n)
					} else Xt(e)
			},
			Ut = function(e) {
				e = e.target, e.removeEventListener("dispose", Ut), e.image && e.image.__webglTextureCube ? Tt.deleteTexture(e.image.__webglTextureCube) : e.__webglInit && (e.__webglInit = !1, Tt.deleteTexture(e.__webglTexture)), z.info.memory.textures--
			},
			zt = function(e) {
				e = e.target, e.removeEventListener("dispose", zt);
				if (e && e.__webglTexture)
					if (Tt.deleteTexture(e.__webglTexture), e instanceof THREE.WebGLRenderTargetCube)
						for (var t = 0; 6 > t; t++) Tt.deleteFramebuffer(e.__webglFramebuffer[t]), Tt.deleteRenderbuffer(e.__webglRenderbuffer[t]);
					else Tt.deleteFramebuffer(e.__webglFramebuffer), Tt.deleteRenderbuffer(e.__webglRenderbuffer);
				z.info.memory.textures--
			},
			Wt = function(e) {
				e = e.target, e.removeEventListener("dispose", Wt), Vt(e)
			},
			Xt = function(e) {
				void 0 !== e.__webglVertexBuffer && Tt.deleteBuffer(e.__webglVertexBuffer), void 0 !== e.__webglNormalBuffer && Tt.deleteBuffer(e.__webglNormalBuffer), void 0 !== e.__webglTangentBuffer && Tt.deleteBuffer(e.__webglTangentBuffer), void 0 !== e.__webglColorBuffer && Tt.deleteBuffer(e.__webglColorBuffer), void 0 !== e.__webglUVBuffer && Tt.deleteBuffer(e.__webglUVBuffer), void 0 !== e.__webglUV2Buffer && Tt.deleteBuffer(e.__webglUV2Buffer), void 0 !== e.__webglSkinIndicesBuffer && Tt.deleteBuffer(e.__webglSkinIndicesBuffer), void 0 !== e.__webglSkinWeightsBuffer && Tt.deleteBuffer(e.__webglSkinWeightsBuffer), void 0 !== e.__webglFaceBuffer && Tt.deleteBuffer(e.__webglFaceBuffer), void 0 !== e.__webglLineBuffer && Tt.deleteBuffer(e.__webglLineBuffer), void 0 !== e.__webglLineDistanceBuffer && Tt.deleteBuffer(e.__webglLineDistanceBuffer);
				if (void 0 !== e.__webglCustomAttributesList)
					for (var t in e.__webglCustomAttributesList) Tt.deleteBuffer(e.__webglCustomAttributesList[t].buffer);
				z.info.memory.geometries--
			},
			Vt = function(e) {
				var t = e.program;
				if (void 0 !== t) {
					e.program = void 0;
					var n, r, i = !1;
					e = 0;
					for (n = W.length; e < n; e++)
						if (r = W[e], r.program === t) {
							r.usedTimes--, 0 === r.usedTimes && (i = !0);
							break
						} if (!0 === i) {
						i = [], e = 0;
						for (n = W.length; e < n; e++) r = W[e], r.program !== t && i.push(r);
						W = i, Tt.deleteProgram(t), z.info.memory.programs--
					}
				}
			};
		this.renderBufferImmediate = function(e, t, n) {
			e.hasPositions && !e.__webglVertexBuffer && (e.__webglVertexBuffer = Tt.createBuffer()), e.hasNormals && !e.__webglNormalBuffer && (e.__webglNormalBuffer = Tt.createBuffer()), e.hasUvs && !e.__webglUvBuffer && (e.__webglUvBuffer = Tt.createBuffer()), e.hasColors && !e.__webglColorBuffer && (e.__webglColorBuffer = Tt.createBuffer()), e.hasPositions && (Tt.bindBuffer(Tt.ARRAY_BUFFER, e.__webglVertexBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, e.positionArray, Tt.DYNAMIC_DRAW), Tt.enableVertexAttribArray(t.attributes.position), Tt.vertexAttribPointer(t.attributes.position, 3, Tt.FLOAT, !1, 0, 0));
			if (e.hasNormals) {
				Tt.bindBuffer(Tt.ARRAY_BUFFER, e.__webglNormalBuffer);
				if (n.shading === THREE.FlatShading) {
					var r, i, s, o, u, a, f, l, c, h, p, d = 3 * e.count;
					for (p = 0; p < d; p += 9) h = e.normalArray, r = h[p], i = h[p + 1], s = h[p + 2], o = h[p + 3], a = h[p + 4], l = h[p + 5], u = h[p + 6], f = h[p + 7], c = h[p + 8], r = (r + o + u) / 3, i = (i + a + f) / 3, s = (s + l + c) / 3, h[p] = r, h[p + 1] = i, h[p + 2] = s, h[p + 3] = r, h[p + 4] = i, h[p + 5] = s, h[p + 6] = r, h[p + 7] = i, h[p + 8] = s
				}
				Tt.bufferData(Tt.ARRAY_BUFFER, e.normalArray, Tt.DYNAMIC_DRAW), Tt.enableVertexAttribArray(t.attributes.normal), Tt.vertexAttribPointer(t.attributes.normal, 3, Tt.FLOAT, !1, 0, 0)
			}
			e.hasUvs && n.map && (Tt.bindBuffer(Tt.ARRAY_BUFFER, e.__webglUvBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, e.uvArray, Tt.DYNAMIC_DRAW), Tt.enableVertexAttribArray(t.attributes.uv), Tt.vertexAttribPointer(t.attributes.uv, 2, Tt.FLOAT, !1, 0, 0)), e.hasColors && n.vertexColors !== THREE.NoColors && (Tt.bindBuffer(Tt.ARRAY_BUFFER, e.__webglColorBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, e.colorArray, Tt.DYNAMIC_DRAW), Tt.enableVertexAttribArray(t.attributes.color), Tt.vertexAttribPointer(t.attributes.color, 3, Tt.FLOAT, !1, 0, 0)), Tt.drawArrays(Tt.TRIANGLES, 0, e.count), e.count = 0
		}, this.renderBufferDirect = function(e, t, n, r, i, s) {
			if (!1 !== r.visible) {
				var f, l, c, h;
				f = E(e, t, n, r, s), e = f.attributes, t = i.attributes, n = !1, f = 16777215 * i.id + 2 * f.id + (r.wireframe ? 1 : 0), f !== K && (K = f, n = !0), n && a();
				if (s instanceof THREE.Mesh)
					if (s = t.index) {
						i = i.offsets, 1 < i.length && (n = !0);
						for (var p = 0, d = i.length; p < d; p++) {
							var v = i[p].index;
							if (n) {
								for (l in e) c = e[l], f = t[l], 0 <= c && (f ? (h = f.itemSize, Tt.bindBuffer(Tt.ARRAY_BUFFER, f.buffer), u(c), Tt.vertexAttribPointer(c, h, Tt.FLOAT, !1, 0, v * h * 4)) : r.defaultAttributeValues && (2 === r.defaultAttributeValues[l].length ? Tt.vertexAttrib2fv(c, r.defaultAttributeValues[l]) : 3 === r.defaultAttributeValues[l].length && Tt.vertexAttrib3fv(c, r.defaultAttributeValues[l])));
								Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, s.buffer)
							}
							Tt.drawElements(Tt.TRIANGLES, i[p].count, Tt.UNSIGNED_SHORT, 2 * i[p].start), z.info.render.calls++, z.info.render.vertices += i[p].count, z.info.render.faces += i[p].count / 3
						}
					} else {
						if (n)
							for (l in e) "index" !== l && (c = e[l], f = t[l], 0 <= c && (f ? (h = f.itemSize, Tt.bindBuffer(Tt.ARRAY_BUFFER, f.buffer), u(c), Tt.vertexAttribPointer(c, h, Tt.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && r.defaultAttributeValues[l] && (2 === r.defaultAttributeValues[l].length ? Tt.vertexAttrib2fv(c, r.defaultAttributeValues[l]) : 3 === r.defaultAttributeValues[l].length && Tt.vertexAttrib3fv(c, r.defaultAttributeValues[l]))));
						r = i.attributes.position, Tt.drawArrays(Tt.TRIANGLES, 0, r.array.length / 3), z.info.render.calls++, z.info.render.vertices += r.array.length / 3, z.info.render.faces += r.array.length / 3 / 3
					}
				else if (s instanceof THREE.ParticleSystem) {
					if (n)
						for (l in e) c = e[l], f = t[l], 0 <= c && (f ? (h = f.itemSize, Tt.bindBuffer(Tt.ARRAY_BUFFER, f.buffer), u(c), Tt.vertexAttribPointer(c, h, Tt.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && r.defaultAttributeValues[l] && (2 === r.defaultAttributeValues[l].length ? Tt.vertexAttrib2fv(c, r.defaultAttributeValues[l]) : 3 === r.defaultAttributeValues[l].length && Tt.vertexAttrib3fv(c, r.defaultAttributeValues[l])));
					r = t.position, Tt.drawArrays(Tt.POINTS, 0, r.array.length / 3), z.info.render.calls++, z.info.render.points += r.array.length / 3
				} else if (s instanceof THREE.Line)
					if (l = s.type === THREE.LineStrip ? Tt.LINE_STRIP : Tt.LINES, N(r.linewidth), s = t.index)
						for (i = i.offsets, 1 < i.length && (n = !0), p = 0, d = i.length; p < d; p++) v = i[p].index, n && (o(r, e, t, v), Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, s.buffer)), Tt.drawElements(Tt.LINES, i[p].count, Tt.UNSIGNED_SHORT, 2 * i[p].start), z.info.render.calls++, z.info.render.vertices += i[p].count;
					else n && o(r, e, t, 0), r = t.position, Tt.drawArrays(l, 0, r.array.length / 3), z.info.render.calls++, z.info.render.points += r.array.length
			}
		}, this.renderBuffer = function(e, t, n, r, i, s) {
			if (!1 !== r.visible) {
				var o, f;
				n = E(e, t, n, r, s), e = n.attributes, t = !1, n = 16777215 * i.id + 2 * n.id + (r.wireframe ? 1 : 0), n !== K && (K = n, t = !0), t && a();
				if (!r.morphTargets && 0 <= e.position) t && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglVertexBuffer), u(e.position), Tt.vertexAttribPointer(e.position, 3, Tt.FLOAT, !1, 0, 0));
				else if (s.morphTargetBase) {
					n = r.program.attributes, -1 !== s.morphTargetBase && 0 <= n.position ? (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[s.morphTargetBase]), u(n.position), Tt.vertexAttribPointer(n.position, 3, Tt.FLOAT, !1, 0, 0)) : 0 <= n.position && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglVertexBuffer), u(n.position), Tt.vertexAttribPointer(n.position, 3, Tt.FLOAT, !1, 0, 0));
					if (s.morphTargetForcedOrder.length) {
						var c = 0;
						f = s.morphTargetForcedOrder;
						for (o = s.morphTargetInfluences; c < r.numSupportedMorphTargets && c < f.length;) 0 <= n["morphTarget" + c] && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[f[c]]), u(n["morphTarget" + c]), Tt.vertexAttribPointer(n["morphTarget" + c], 3, Tt.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + c] && r.morphNormals && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[f[c]]), u(n["morphNormal" + c]), Tt.vertexAttribPointer(n["morphNormal" + c], 3, Tt.FLOAT, !1, 0, 0)), s.__webglMorphTargetInfluences[c] = o[f[c]], c++
					} else {
						f = [], o = s.morphTargetInfluences;
						var h, p = o.length;
						for (h = 0; h < p; h++) c = o[h], 0 < c && f.push([c, h]);
						f.length > r.numSupportedMorphTargets ? (f.sort(l), f.length = r.numSupportedMorphTargets) : f.length > r.numSupportedMorphNormals ? f.sort(l) : 0 === f.length && f.push([0, 0]);
						for (c = 0; c < r.numSupportedMorphTargets;) f[c] ? (h = f[c][1], 0 <= n["morphTarget" + c] && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglMorphTargetsBuffers[h]), u(n["morphTarget" + c]), Tt.vertexAttribPointer(n["morphTarget" + c], 3, Tt.FLOAT, !1, 0, 0)), 0 <= n["morphNormal" + c] && r.morphNormals && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglMorphNormalsBuffers[h]), u(n["morphNormal" + c]), Tt.vertexAttribPointer(n["morphNormal" + c], 3, Tt.FLOAT, !1, 0, 0)), s.__webglMorphTargetInfluences[c] = o[h]) : s.__webglMorphTargetInfluences[c] = 0, c++
					}
					null !== r.program.uniforms.morphTargetInfluences && Tt.uniform1fv(r.program.uniforms.morphTargetInfluences, s.__webglMorphTargetInfluences)
				}
				if (t) {
					if (i.__webglCustomAttributesList)
						for (o = 0, f = i.__webglCustomAttributesList.length; o < f; o++) n = i.__webglCustomAttributesList[o], 0 <= e[n.buffer.belongsToAttribute] && (Tt.bindBuffer(Tt.ARRAY_BUFFER, n.buffer), u(e[n.buffer.belongsToAttribute]), Tt.vertexAttribPointer(e[n.buffer.belongsToAttribute], n.size, Tt.FLOAT, !1, 0, 0));
					0 <= e.color && (0 < s.geometry.colors.length || 0 < s.geometry.faces.length ? (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglColorBuffer), u(e.color), Tt.vertexAttribPointer(e.color, 3, Tt.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Tt.vertexAttrib3fv(e.color, r.defaultAttributeValues.color)), 0 <= e.normal && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglNormalBuffer), u(e.normal), Tt.vertexAttribPointer(e.normal, 3, Tt.FLOAT, !1, 0, 0)), 0 <= e.tangent && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglTangentBuffer), u(e.tangent), Tt.vertexAttribPointer(e.tangent, 4, Tt.FLOAT, !1, 0, 0)), 0 <= e.uv && (s.geometry.faceVertexUvs[0] ? (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglUVBuffer), u(e.uv), Tt.vertexAttribPointer(e.uv, 2, Tt.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Tt.vertexAttrib2fv(e.uv, r.defaultAttributeValues.uv)), 0 <= e.uv2 && (s.geometry.faceVertexUvs[1] ? (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglUV2Buffer), u(e.uv2), Tt.vertexAttribPointer(e.uv2, 2, Tt.FLOAT, !1, 0, 0)) : r.defaultAttributeValues && Tt.vertexAttrib2fv(e.uv2, r.defaultAttributeValues.uv2)), r.skinning && 0 <= e.skinIndex && 0 <= e.skinWeight && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglSkinIndicesBuffer), u(e.skinIndex), Tt.vertexAttribPointer(e.skinIndex, 4, Tt.FLOAT, !1, 0, 0), Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglSkinWeightsBuffer), u(e.skinWeight), Tt.vertexAttribPointer(e.skinWeight, 4, Tt.FLOAT, !1, 0, 0)), 0 <= e.lineDistance && (Tt.bindBuffer(Tt.ARRAY_BUFFER, i.__webglLineDistanceBuffer), u(e.lineDistance), Tt.vertexAttribPointer(e.lineDistance, 1, Tt.FLOAT, !1, 0, 0))
				}
				s instanceof THREE.Mesh ? (r.wireframe ? (N(r.wireframeLinewidth), t && Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, i.__webglLineBuffer), Tt.drawElements(Tt.LINES, i.__webglLineCount, Tt.UNSIGNED_SHORT, 0)) : (t && Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, i.__webglFaceBuffer), Tt.drawElements(Tt.TRIANGLES, i.__webglFaceCount, Tt.UNSIGNED_SHORT, 0)), z.info.render.calls++, z.info.render.vertices += i.__webglFaceCount, z.info.render.faces += i.__webglFaceCount / 3) : s instanceof THREE.Line ? (s = s.type === THREE.LineStrip ? Tt.LINE_STRIP : Tt.LINES, N(r.linewidth), Tt.drawArrays(s, 0, i.__webglLineCount), z.info.render.calls++) : s instanceof THREE.ParticleSystem && (Tt.drawArrays(Tt.POINTS, 0, i.__webglParticleCount), z.info.render.calls++, z.info.render.points += i.__webglParticleCount)
			}
		}, this.render = function(e, t, n, r) {
			if (0 == t instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
			else {
				var i, s, o, u, a = e.__lights,
					l = e.fog;
				J = -1, St = !0, !0 === e.autoUpdate && e.updateMatrixWorld(), void 0 === t.parent && t.updateMatrixWorld(), t.matrixWorldInverse.getInverse(t.matrixWorld), yt.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), gt.setFromMatrix(yt), this.autoUpdateObjects && this.initWebGLObjects(e), c(this.renderPluginsPre, e, t), z.info.render.calls = 0, z.info.render.vertices = 0, z.info.render.faces = 0, z.info.render.points = 0, this.setRenderTarget(n), (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), u = e.__webglObjects, r = 0;
				for (i = u.length; r < i; r++)
					if (s = u[r], o = s.object, s.id = r, s.render = !1, o.visible && (!(o instanceof THREE.Mesh || o instanceof THREE.ParticleSystem) || !o.frustumCulled || gt.intersectsObject(o))) {
						var d = o;
						d._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, d.matrixWorld), d._normalMatrix.getNormalMatrix(d._modelViewMatrix);
						var d = s,
							v = d.object,
							m = d.buffer,
							g = v.geometry,
							v = v.material;
						v instanceof THREE.MeshFaceMaterial ? (v = v.materials[g instanceof THREE.BufferGeometry ? 0 : m.materialIndex], v.transparent ? (d.transparent = v, d.opaque = null) : (d.opaque = v, d.transparent = null)) : v && (v.transparent ? (d.transparent = v, d.opaque = null) : (d.opaque = v, d.transparent = null)), s.render = !0, !0 === this.sortObjects && (null !== o.renderDepth ? s.z = o.renderDepth : (wt.setFromMatrixPosition(o.matrixWorld), wt.applyProjection(yt), s.z = wt.z))
					} this.sortObjects && u.sort(f), u = e.__webglObjectsImmediate, r = 0;
				for (i = u.length; r < i; r++) s = u[r], o = s.object, o.visible && (o._modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, o.matrixWorld), o._normalMatrix.getNormalMatrix(o._modelViewMatrix), o = s.object.material, o.transparent ? (s.transparent = o, s.opaque = null) : (s.opaque = o, s.transparent = null));
				e.overrideMaterial ? (r = e.overrideMaterial, this.setBlending(r.blending, r.blendEquation, r.blendSrc, r.blendDst), this.setDepthTest(r.depthTest), this.setDepthWrite(r.depthWrite), C(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits), h(e.__webglObjects, !1, "", t, a, l, !0, r), p(e.__webglObjectsImmediate, "", t, a, l, !1, r)) : (r = null, this.setBlending(THREE.NoBlending), h(e.__webglObjects, !0, "opaque", t, a, l, !1, r), p(e.__webglObjectsImmediate, "opaque", t, a, l, !1, r), h(e.__webglObjects, !1, "transparent", t, a, l, !0, r), p(e.__webglObjectsImmediate, "transparent", t, a, l, !0, r)), c(this.renderPluginsPost, e, t), n && n.generateMipmaps && n.minFilter !== THREE.NearestFilter && n.minFilter !== THREE.LinearFilter && (n instanceof THREE.WebGLRenderTargetCube ? (Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, n.__webglTexture), Tt.generateMipmap(Tt.TEXTURE_CUBE_MAP), Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, null)) : (Tt.bindTexture(Tt.TEXTURE_2D, n.__webglTexture), Tt.generateMipmap(Tt.TEXTURE_2D), Tt.bindTexture(Tt.TEXTURE_2D, null))), this.setDepthTest(!0), this.setDepthWrite(!0)
			}
		}, this.renderImmediateObject = function(e, t, n, r, i) {
			var s = E(e, t, n, r, i);
			K = -1, z.setMaterialFaces(r), i.immediateRenderCallback ? i.immediateRenderCallback(s, Tt, gt) : i.render(function(e) {
				z.renderBufferImmediate(e, s, r)
			})
		}, this.initWebGLObjects = function(e) {
			e.__webglObjects || (e.__webglObjects = [], e.__webglObjectsImmediate = [], e.__webglSprites = [], e.__webglFlares = []);
			for (; e.__objectsAdded.length;) d(e.__objectsAdded[0], e), e.__objectsAdded.splice(0, 1);
			for (; e.__objectsRemoved.length;) y(e.__objectsRemoved[0], e), e.__objectsRemoved.splice(0, 1);
			for (var t = 0, o = e.__webglObjects.length; t < o; t++) {
				var u = e.__webglObjects[t].object;
				void 0 === u.__webglInit && (void 0 !== u.__webglActive && y(u, e), d(u, e));
				var a = u,
					f = a.geometry,
					c = void 0,
					h = void 0,
					p = void 0;
				if (f instanceof THREE.BufferGeometry) {
					var v = Tt.DYNAMIC_DRAW,
						b = f.attributes,
						w = void 0,
						E = void 0;
					for (w in b) E = b[w], E.needsUpdate && ("index" === w ? (Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, E.buffer), Tt.bufferData(Tt.ELEMENT_ARRAY_BUFFER, E.array, v)) : (Tt.bindBuffer(Tt.ARRAY_BUFFER, E.buffer), Tt.bufferData(Tt.ARRAY_BUFFER, E.array, v)), E.needsUpdate = !1)
				} else if (a instanceof THREE.Mesh) {
					for (var S = 0, x = f.geometryGroupsList.length; S < x; S++)
						if (c = f.geometryGroupsList[S], p = r(a, c), f.buffersNeedUpdate && n(c, a), h = p.attributes && m(p), f.verticesNeedUpdate || f.morphTargetsNeedUpdate || f.elementsNeedUpdate || f.uvsNeedUpdate || f.normalsNeedUpdate || f.colorsNeedUpdate || f.tangentsNeedUpdate || h) {
							var T = c,
								N = a,
								C = Tt.DYNAMIC_DRAW,
								k = !f.dynamic,
								L = p;
							if (T.__inittedArrays) {
								var A = i(L),
									O = L.vertexColors ? L.vertexColors : !1,
									M = s(L),
									_ = A === THREE.SmoothShading,
									D = void 0,
									P = void 0,
									H = void 0,
									B = void 0,
									j = void 0,
									F = void 0,
									I = void 0,
									q = void 0,
									R = void 0,
									U = void 0,
									z = void 0,
									W = void 0,
									X = void 0,
									V = void 0,
									$ = void 0,
									J = void 0,
									K = void 0,
									Q = void 0,
									G = void 0,
									Y = void 0,
									Z = void 0,
									et = void 0,
									tt = void 0,
									nt = void 0,
									rt = void 0,
									it = void 0,
									st = void 0,
									ot = void 0,
									ut = void 0,
									at = void 0,
									ft = void 0,
									lt = void 0,
									ct = void 0,
									ht = void 0,
									pt = void 0,
									dt = void 0,
									vt = void 0,
									mt = void 0,
									gt = void 0,
									Et = void 0,
									St = 0,
									xt = 0,
									Nt = 0,
									Ct = 0,
									kt = 0,
									Lt = 0,
									At = 0,
									Ot = 0,
									Mt = 0,
									_t = 0,
									Dt = 0,
									Pt = 0,
									Ht = void 0,
									Bt = T.__vertexArray,
									jt = T.__uvArray,
									Ft = T.__uv2Array,
									It = T.__normalArray,
									qt = T.__tangentArray,
									Rt = T.__colorArray,
									Ut = T.__skinIndexArray,
									zt = T.__skinWeightArray,
									Wt = T.__morphTargetsArrays,
									Xt = T.__morphNormalsArrays,
									Vt = T.__webglCustomAttributesList,
									$t = void 0,
									Jt = T.__faceArray,
									Kt = T.__lineArray,
									Qt = N.geometry,
									Gt = Qt.elementsNeedUpdate,
									Yt = Qt.uvsNeedUpdate,
									Zt = Qt.normalsNeedUpdate,
									en = Qt.tangentsNeedUpdate,
									tn = Qt.colorsNeedUpdate,
									nn = Qt.morphTargetsNeedUpdate,
									rn = Qt.vertices,
									sn = T.faces3,
									on = Qt.faces,
									un = Qt.faceVertexUvs[0],
									an = Qt.faceVertexUvs[1],
									fn = Qt.skinIndices,
									ln = Qt.skinWeights,
									cn = Qt.morphTargets,
									hn = Qt.morphNormals;
								if (Qt.verticesNeedUpdate) {
									D = 0;
									for (P = sn.length; D < P; D++) B = on[sn[D]], W = rn[B.a], X = rn[B.b], V = rn[B.c], Bt[xt] = W.x, Bt[xt + 1] = W.y, Bt[xt + 2] = W.z, Bt[xt + 3] = X.x, Bt[xt + 4] = X.y, Bt[xt + 5] = X.z, Bt[xt + 6] = V.x, Bt[xt + 7] = V.y, Bt[xt + 8] = V.z, xt += 9;
									Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglVertexBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, Bt, C)
								}
								if (nn)
									for (pt = 0, dt = cn.length; pt < dt; pt++) {
										D = Dt = 0;
										for (P = sn.length; D < P; D++) gt = sn[D], B = on[gt], W = cn[pt].vertices[B.a], X = cn[pt].vertices[B.b], V = cn[pt].vertices[B.c], vt = Wt[pt], vt[Dt] = W.x, vt[Dt + 1] = W.y, vt[Dt + 2] = W.z, vt[Dt + 3] = X.x, vt[Dt + 4] = X.y, vt[Dt + 5] = X.z, vt[Dt + 6] = V.x, vt[Dt + 7] = V.y, vt[Dt + 8] = V.z, L.morphNormals && (_ ? (Et = hn[pt].vertexNormals[gt], Q = Et.a, G = Et.b, Y = Et.c) : Y = G = Q = hn[pt].faceNormals[gt], mt = Xt[pt], mt[Dt] = Q.x, mt[Dt + 1] = Q.y, mt[Dt + 2] = Q.z, mt[Dt + 3] = G.x, mt[Dt + 4] = G.y, mt[Dt + 5] = G.z, mt[Dt + 6] = Y.x, mt[Dt + 7] = Y.y, mt[Dt + 8] = Y.z), Dt += 9;
										Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglMorphTargetsBuffers[pt]), Tt.bufferData(Tt.ARRAY_BUFFER, Wt[pt], C), L.morphNormals && (Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglMorphNormalsBuffers[pt]), Tt.bufferData(Tt.ARRAY_BUFFER, Xt[pt], C))
									}
								if (ln.length) {
									D = 0;
									for (P = sn.length; D < P; D++) B = on[sn[D]], nt = ln[B.a], rt = ln[B.b], it = ln[B.c], zt[_t] = nt.x, zt[_t + 1] = nt.y, zt[_t + 2] = nt.z, zt[_t + 3] = nt.w, zt[_t + 4] = rt.x, zt[_t + 5] = rt.y, zt[_t + 6] = rt.z, zt[_t + 7] = rt.w, zt[_t + 8] = it.x, zt[_t + 9] = it.y, zt[_t + 10] = it.z, zt[_t + 11] = it.w, st = fn[B.a], ot = fn[B.b], ut = fn[B.c], Ut[_t] = st.x, Ut[_t + 1] = st.y, Ut[_t + 2] = st.z, Ut[_t + 3] = st.w, Ut[_t + 4] = ot.x, Ut[_t + 5] = ot.y, Ut[_t + 6] = ot.z, Ut[_t + 7] = ot.w, Ut[_t + 8] = ut.x, Ut[_t + 9] = ut.y, Ut[_t + 10] = ut.z, Ut[_t + 11] = ut.w, _t += 12;
									0 < _t && (Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglSkinIndicesBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, Ut, C), Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglSkinWeightsBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, zt, C))
								}
								if (tn && O) {
									D = 0;
									for (P = sn.length; D < P; D++) B = on[sn[D]], I = B.vertexColors, q = B.color, 3 === I.length && O === THREE.VertexColors ? (Z = I[0], et = I[1], tt = I[2]) : tt = et = Z = q, Rt[Mt] = Z.r, Rt[Mt + 1] = Z.g, Rt[Mt + 2] = Z.b, Rt[Mt + 3] = et.r, Rt[Mt + 4] = et.g, Rt[Mt + 5] = et.b, Rt[Mt + 6] = tt.r, Rt[Mt + 7] = tt.g, Rt[Mt + 8] = tt.b, Mt += 9;
									0 < Mt && (Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglColorBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, Rt, C))
								}
								if (en && Qt.hasTangents) {
									D = 0;
									for (P = sn.length; D < P; D++) B = on[sn[D]], R = B.vertexTangents, $ = R[0], J = R[1], K = R[2], qt[At] = $.x, qt[At + 1] = $.y, qt[At + 2] = $.z, qt[At + 3] = $.w, qt[At + 4] = J.x, qt[At + 5] = J.y, qt[At + 6] = J.z, qt[At + 7] = J.w, qt[At + 8] = K.x, qt[At + 9] = K.y, qt[At + 10] = K.z, qt[At + 11] = K.w, At += 12;
									Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglTangentBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, qt, C)
								}
								if (Zt && A) {
									D = 0;
									for (P = sn.length; D < P; D++)
										if (B = on[sn[D]], j = B.vertexNormals, F = B.normal, 3 === j.length && _)
											for (at = 0; 3 > at; at++) lt = j[at], It[Lt] = lt.x, It[Lt + 1] = lt.y, It[Lt + 2] = lt.z, Lt += 3;
										else
											for (at = 0; 3 > at; at++) It[Lt] = F.x, It[Lt + 1] = F.y, It[Lt + 2] = F.z, Lt += 3;
									Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglNormalBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, It, C)
								}
								if (Yt && un && M) {
									D = 0;
									for (P = sn.length; D < P; D++)
										if (H = sn[D], U = un[H], void 0 !== U)
											for (at = 0; 3 > at; at++) ct = U[at], jt[Nt] = ct.x, jt[Nt + 1] = ct.y, Nt += 2;
									0 < Nt && (Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglUVBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, jt, C))
								}
								if (Yt && an && M) {
									D = 0;
									for (P = sn.length; D < P; D++)
										if (H = sn[D], z = an[H], void 0 !== z)
											for (at = 0; 3 > at; at++) ht = z[at], Ft[Ct] = ht.x, Ft[Ct + 1] = ht.y, Ct += 2;
									0 < Ct && (Tt.bindBuffer(Tt.ARRAY_BUFFER, T.__webglUV2Buffer), Tt.bufferData(Tt.ARRAY_BUFFER, Ft, C))
								}
								if (Gt) {
									D = 0;
									for (P = sn.length; D < P; D++) Jt[kt] = St, Jt[kt + 1] = St + 1, Jt[kt + 2] = St + 2, kt += 3, Kt[Ot] = St, Kt[Ot + 1] = St + 1, Kt[Ot + 2] = St, Kt[Ot + 3] = St + 2, Kt[Ot + 4] = St + 1, Kt[Ot + 5] = St + 2, Ot += 6, St += 3;
									Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, T.__webglFaceBuffer), Tt.bufferData(Tt.ELEMENT_ARRAY_BUFFER, Jt, C), Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, T.__webglLineBuffer), Tt.bufferData(Tt.ELEMENT_ARRAY_BUFFER, Kt, C)
								}
								if (Vt)
									for (at = 0, ft = Vt.length; at < ft; at++)
										if ($t = Vt[at], $t.__original.needsUpdate) {
											Pt = 0;
											if (1 === $t.size) {
												if (void 0 === $t.boundTo || "vertices" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) B = on[sn[D]], $t.array[Pt] = $t.value[B.a], $t.array[Pt + 1] = $t.value[B.b], $t.array[Pt + 2] = $t.value[B.c], Pt += 3;
												else if ("faces" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) Ht = $t.value[sn[D]], $t.array[Pt] = Ht, $t.array[Pt + 1] = Ht, $t.array[Pt + 2] = Ht, Pt += 3
											} else if (2 === $t.size) {
												if (void 0 === $t.boundTo || "vertices" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) B = on[sn[D]], W = $t.value[B.a], X = $t.value[B.b], V = $t.value[B.c], $t.array[Pt] = W.x, $t.array[Pt + 1] = W.y, $t.array[Pt + 2] = X.x, $t.array[Pt + 3] = X.y, $t.array[Pt + 4] = V.x, $t.array[Pt + 5] = V.y, Pt += 6;
												else if ("faces" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) V = X = W = Ht = $t.value[sn[D]], $t.array[Pt] = W.x, $t.array[Pt + 1] = W.y, $t.array[Pt + 2] = X.x, $t.array[Pt + 3] = X.y, $t.array[Pt + 4] = V.x, $t.array[Pt + 5] = V.y, Pt += 6
											} else if (3 === $t.size) {
												var pn;
												pn = "c" === $t.type ? ["r", "g", "b"] : ["x", "y", "z"];
												if (void 0 === $t.boundTo || "vertices" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) B = on[sn[D]], W = $t.value[B.a], X = $t.value[B.b], V = $t.value[B.c], $t.array[Pt] = W[pn[0]], $t.array[Pt + 1] = W[pn[1]], $t.array[Pt + 2] = W[pn[2]], $t.array[Pt + 3] = X[pn[0]], $t.array[Pt + 4] = X[pn[1]], $t.array[Pt + 5] = X[pn[2]], $t.array[Pt + 6] = V[pn[0]], $t.array[Pt + 7] = V[pn[1]], $t.array[Pt + 8] = V[pn[2]], Pt += 9;
												else if ("faces" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) V = X = W = Ht = $t.value[sn[D]], $t.array[Pt] = W[pn[0]], $t.array[Pt + 1] = W[pn[1]], $t.array[Pt + 2] = W[pn[2]], $t.array[Pt + 3] = X[pn[0]], $t.array[Pt + 4] = X[pn[1]], $t.array[Pt + 5] = X[pn[2]], $t.array[Pt + 6] = V[pn[0]], $t.array[Pt + 7] = V[pn[1]], $t.array[Pt + 8] = V[pn[2]], Pt += 9;
												else if ("faceVertices" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) Ht = $t.value[sn[D]], W = Ht[0], X = Ht[1], V = Ht[2], $t.array[Pt] = W[pn[0]], $t.array[Pt + 1] = W[pn[1]], $t.array[Pt + 2] = W[pn[2]], $t.array[Pt + 3] = X[pn[0]], $t.array[Pt + 4] = X[pn[1]], $t.array[Pt + 5] = X[pn[2]], $t.array[Pt + 6] = V[pn[0]], $t.array[Pt + 7] = V[pn[1]], $t.array[Pt + 8] = V[pn[2]], Pt += 9
											} else if (4 === $t.size)
												if (void 0 === $t.boundTo || "vertices" === $t.boundTo)
													for (D = 0, P = sn.length; D < P; D++) B = on[sn[D]], W = $t.value[B.a], X = $t.value[B.b], V = $t.value[B.c], $t.array[Pt] = W.x, $t.array[Pt + 1] = W.y, $t.array[Pt + 2] = W.z, $t.array[Pt + 3] = W.w, $t.array[Pt + 4] = X.x, $t.array[Pt + 5] = X.y, $t.array[Pt + 6] = X.z, $t.array[Pt + 7] = X.w, $t.array[Pt + 8] = V.x, $t.array[Pt + 9] = V.y, $t.array[Pt + 10] = V.z, $t.array[Pt + 11] = V.w, Pt += 12;
												else if ("faces" === $t.boundTo)
												for (D = 0, P = sn.length; D < P; D++) V = X = W = Ht = $t.value[sn[D]], $t.array[Pt] = W.x, $t.array[Pt + 1] = W.y, $t.array[Pt + 2] = W.z, $t.array[Pt + 3] = W.w, $t.array[Pt + 4] = X.x, $t.array[Pt + 5] = X.y, $t.array[Pt + 6] = X.z, $t.array[Pt + 7] = X.w, $t.array[Pt + 8] = V.x, $t.array[Pt + 9] = V.y, $t.array[Pt + 10] = V.z, $t.array[Pt + 11] = V.w, Pt += 12;
											else if ("faceVertices" === $t.boundTo)
												for (D = 0, P = sn.length; D < P; D++) Ht = $t.value[sn[D]], W = Ht[0], X = Ht[1], V = Ht[2], $t.array[Pt] = W.x, $t.array[Pt + 1] = W.y, $t.array[Pt + 2] = W.z, $t.array[Pt + 3] = W.w, $t.array[Pt + 4] = X.x, $t.array[Pt + 5] = X.y, $t.array[Pt + 6] = X.z, $t.array[Pt + 7] = X.w, $t.array[Pt + 8] = V.x, $t.array[Pt + 9] = V.y, $t.array[Pt + 10] = V.z, $t.array[Pt + 11] = V.w, Pt += 12;
											Tt.bindBuffer(Tt.ARRAY_BUFFER, $t.buffer), Tt.bufferData(Tt.ARRAY_BUFFER, $t.array, C)
										} k && (delete T.__inittedArrays, delete T.__colorArray, delete T.__normalArray, delete T.__tangentArray, delete T.__uvArray, delete T.__uv2Array, delete T.__faceArray, delete T.__vertexArray, delete T.__lineArray, delete T.__skinIndexArray, delete T.__skinWeightArray)
							}
						} f.verticesNeedUpdate = !1, f.morphTargetsNeedUpdate = !1, f.elementsNeedUpdate = !1, f.uvsNeedUpdate = !1, f.normalsNeedUpdate = !1, f.colorsNeedUpdate = !1, f.tangentsNeedUpdate = !1, f.buffersNeedUpdate = !1, p.attributes && g(p)
				} else if (a instanceof THREE.Line) {
					p = r(a, f), h = p.attributes && m(p);
					if (f.verticesNeedUpdate || f.colorsNeedUpdate || f.lineDistancesNeedUpdate || h) {
						var dn = f,
							vn = Tt.DYNAMIC_DRAW,
							mn = void 0,
							gn = void 0,
							yn = void 0,
							bn = void 0,
							wn = void 0,
							En = void 0,
							Sn = dn.vertices,
							xn = dn.colors,
							Tn = dn.lineDistances,
							Nn = Sn.length,
							Cn = xn.length,
							kn = Tn.length,
							Ln = dn.__vertexArray,
							An = dn.__colorArray,
							On = dn.__lineDistanceArray,
							Mn = dn.colorsNeedUpdate,
							_n = dn.lineDistancesNeedUpdate,
							Dn = dn.__webglCustomAttributesList,
							Pn = void 0,
							Hn = void 0,
							Bn = void 0,
							jn = void 0,
							Fn = void 0,
							In = void 0;
						if (dn.verticesNeedUpdate) {
							for (mn = 0; mn < Nn; mn++) bn = Sn[mn], wn = 3 * mn, Ln[wn] = bn.x, Ln[wn + 1] = bn.y, Ln[wn + 2] = bn.z;
							Tt.bindBuffer(Tt.ARRAY_BUFFER, dn.__webglVertexBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, Ln, vn)
						}
						if (Mn) {
							for (gn = 0; gn < Cn; gn++) En = xn[gn], wn = 3 * gn, An[wn] = En.r, An[wn + 1] = En.g, An[wn + 2] = En.b;
							Tt.bindBuffer(Tt.ARRAY_BUFFER, dn.__webglColorBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, An, vn)
						}
						if (_n) {
							for (yn = 0; yn < kn; yn++) On[yn] = Tn[yn];
							Tt.bindBuffer(Tt.ARRAY_BUFFER, dn.__webglLineDistanceBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, On, vn)
						}
						if (Dn)
							for (Pn = 0, Hn = Dn.length; Pn < Hn; Pn++)
								if (In = Dn[Pn], In.needsUpdate && (void 0 === In.boundTo || "vertices" === In.boundTo)) {
									wn = 0, jn = In.value.length;
									if (1 === In.size)
										for (Bn = 0; Bn < jn; Bn++) In.array[Bn] = In.value[Bn];
									else if (2 === In.size)
										for (Bn = 0; Bn < jn; Bn++) Fn = In.value[Bn], In.array[wn] = Fn.x, In.array[wn + 1] = Fn.y, wn += 2;
									else if (3 === In.size)
										if ("c" === In.type)
											for (Bn = 0; Bn < jn; Bn++) Fn = In.value[Bn], In.array[wn] = Fn.r, In.array[wn + 1] = Fn.g, In.array[wn + 2] = Fn.b, wn += 3;
										else
											for (Bn = 0; Bn < jn; Bn++) Fn = In.value[Bn], In.array[wn] = Fn.x, In.array[wn + 1] = Fn.y, In.array[wn + 2] = Fn.z, wn += 3;
									else if (4 === In.size)
										for (Bn = 0; Bn < jn; Bn++) Fn = In.value[Bn], In.array[wn] = Fn.x, In.array[wn + 1] = Fn.y, In.array[wn + 2] = Fn.z, In.array[wn + 3] = Fn.w, wn += 4;
									Tt.bindBuffer(Tt.ARRAY_BUFFER, In.buffer), Tt.bufferData(Tt.ARRAY_BUFFER, In.array, vn)
								}
					}
					f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, f.lineDistancesNeedUpdate = !1, p.attributes && g(p)
				} else if (a instanceof THREE.ParticleSystem) {
					p = r(a, f), h = p.attributes && m(p);
					if (f.verticesNeedUpdate || f.colorsNeedUpdate || a.sortParticles || h) {
						var qn = f,
							Rn = Tt.DYNAMIC_DRAW,
							Un = a,
							zn = void 0,
							Wn = void 0,
							Xn = void 0,
							Vn = void 0,
							$n = void 0,
							Jn = void 0,
							Kn = qn.vertices,
							Qn = Kn.length,
							Gn = qn.colors,
							Yn = Gn.length,
							Zn = qn.__vertexArray,
							er = qn.__colorArray,
							tr = qn.__sortArray,
							nr = qn.verticesNeedUpdate,
							rr = qn.colorsNeedUpdate,
							ir = qn.__webglCustomAttributesList,
							sr = void 0,
							or = void 0,
							ur = void 0,
							ar = void 0,
							fr = void 0,
							lr = void 0;
						if (Un.sortParticles) {
							bt.copy(yt), bt.multiply(Un.matrixWorld);
							for (zn = 0; zn < Qn; zn++) Xn = Kn[zn], wt.copy(Xn), wt.applyProjection(bt), tr[zn] = [wt.z, zn];
							tr.sort(l);
							for (zn = 0; zn < Qn; zn++) Xn = Kn[tr[zn][1]], Vn = 3 * zn, Zn[Vn] = Xn.x, Zn[Vn + 1] = Xn.y, Zn[Vn + 2] = Xn.z;
							for (Wn = 0; Wn < Yn; Wn++) Vn = 3 * Wn, Jn = Gn[tr[Wn][1]], er[Vn] = Jn.r, er[Vn + 1] = Jn.g, er[Vn + 2] = Jn.b;
							if (ir)
								for (sr = 0, or = ir.length; sr < or; sr++)
									if (lr = ir[sr], void 0 === lr.boundTo || "vertices" === lr.boundTo)
										if (Vn = 0, ar = lr.value.length, 1 === lr.size)
											for (ur = 0; ur < ar; ur++) $n = tr[ur][1], lr.array[ur] = lr.value[$n];
										else if (2 === lr.size)
								for (ur = 0; ur < ar; ur++) $n = tr[ur][1], fr = lr.value[$n], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, Vn += 2;
							else if (3 === lr.size)
								if ("c" === lr.type)
									for (ur = 0; ur < ar; ur++) $n = tr[ur][1], fr = lr.value[$n], lr.array[Vn] = fr.r, lr.array[Vn + 1] = fr.g, lr.array[Vn + 2] = fr.b, Vn += 3;
								else
									for (ur = 0; ur < ar; ur++) $n = tr[ur][1], fr = lr.value[$n], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, lr.array[Vn + 2] = fr.z, Vn += 3;
							else if (4 === lr.size)
								for (ur = 0; ur < ar; ur++) $n = tr[ur][1], fr = lr.value[$n], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, lr.array[Vn + 2] = fr.z, lr.array[Vn + 3] = fr.w, Vn += 4
						} else {
							if (nr)
								for (zn = 0; zn < Qn; zn++) Xn = Kn[zn], Vn = 3 * zn, Zn[Vn] = Xn.x, Zn[Vn + 1] = Xn.y, Zn[Vn + 2] = Xn.z;
							if (rr)
								for (Wn = 0; Wn < Yn; Wn++) Jn = Gn[Wn], Vn = 3 * Wn, er[Vn] = Jn.r, er[Vn + 1] = Jn.g, er[Vn + 2] = Jn.b;
							if (ir)
								for (sr = 0, or = ir.length; sr < or; sr++)
									if (lr = ir[sr], lr.needsUpdate && (void 0 === lr.boundTo || "vertices" === lr.boundTo))
										if (ar = lr.value.length, Vn = 0, 1 === lr.size)
											for (ur = 0; ur < ar; ur++) lr.array[ur] = lr.value[ur];
										else if (2 === lr.size)
								for (ur = 0; ur < ar; ur++) fr = lr.value[ur], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, Vn += 2;
							else if (3 === lr.size)
								if ("c" === lr.type)
									for (ur = 0; ur < ar; ur++) fr = lr.value[ur], lr.array[Vn] = fr.r, lr.array[Vn + 1] = fr.g, lr.array[Vn + 2] = fr.b, Vn += 3;
								else
									for (ur = 0; ur < ar; ur++) fr = lr.value[ur], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, lr.array[Vn + 2] = fr.z, Vn += 3;
							else if (4 === lr.size)
								for (ur = 0; ur < ar; ur++) fr = lr.value[ur], lr.array[Vn] = fr.x, lr.array[Vn + 1] = fr.y, lr.array[Vn + 2] = fr.z, lr.array[Vn + 3] = fr.w, Vn += 4
						}
						if (nr || Un.sortParticles) Tt.bindBuffer(Tt.ARRAY_BUFFER, qn.__webglVertexBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, Zn, Rn);
						if (rr || Un.sortParticles) Tt.bindBuffer(Tt.ARRAY_BUFFER, qn.__webglColorBuffer), Tt.bufferData(Tt.ARRAY_BUFFER, er, Rn);
						if (ir)
							for (sr = 0, or = ir.length; sr < or; sr++)
								if (lr = ir[sr], lr.needsUpdate || Un.sortParticles) Tt.bindBuffer(Tt.ARRAY_BUFFER, lr.buffer), Tt.bufferData(Tt.ARRAY_BUFFER, lr.array, Rn)
					}
					f.verticesNeedUpdate = !1, f.colorsNeedUpdate = !1, p.attributes && g(p)
				}
			}
		}, this.initMaterial = function(e, t, n, r) {
			var i, s, o, u;
			e.addEventListener("dispose", Wt);
			var a, f, l, c, h;
			e instanceof THREE.MeshDepthMaterial ? h = "depth" : e instanceof THREE.MeshNormalMaterial ? h = "normal" : e instanceof THREE.MeshBasicMaterial ? h = "basic" : e instanceof THREE.MeshLambertMaterial ? h = "lambert" : e instanceof THREE.MeshPhongMaterial ? h = "phong" : e instanceof THREE.LineBasicMaterial ? h = "basic" : e instanceof THREE.LineDashedMaterial ? h = "dashed" : e instanceof THREE.ParticleSystemMaterial && (h = "particle_basic");
			if (h) {
				var p = THREE.ShaderLib[h];
				e.uniforms = THREE.UniformsUtils.clone(p.uniforms), e.vertexShader = p.vertexShader, e.fragmentShader = p.fragmentShader
			}
			var d = i = 0,
				v = 0,
				m = p = 0;
			for (s = t.length; m < s; m++) o = t[m], o.onlyShadow || !1 === o.visible || (o instanceof THREE.DirectionalLight && i++, o instanceof THREE.PointLight && d++, o instanceof THREE.SpotLight && v++, o instanceof THREE.HemisphereLight && p++);
			s = d, o = v, u = p, v = p = 0;
			for (d = t.length; v < d; v++) m = t[v], m.castShadow && (m instanceof THREE.SpotLight && p++, m instanceof THREE.DirectionalLight && !m.shadowCascade && p++);
			c = p, Pt && r && r.useVertexTexture ? l = 1024 : (t = Tt.getParameter(Tt.MAX_VERTEX_UNIFORM_VECTORS), t = Math.floor((t - 20) / 4), void 0 !== r && r instanceof THREE.SkinnedMesh && (t = Math.min(r.bones.length, t), t < r.bones.length && console.warn("WebGLRenderer: too many bones - " + r.bones.length + ", this GPU supports just " + t + " (try OpenGL instead of ANGLE)")), l = t);
			e: {
				v = e.fragmentShader,
				d = e.vertexShader,
				p = e.uniforms,
				t = e.attributes,
				m = e.defines,
				n = {
					map: !!e.map,
					envMap: !!e.envMap,
					lightMap: !!e.lightMap,
					bumpMap: !!e.bumpMap,
					normalMap: !!e.normalMap,
					specularMap: !!e.specularMap,
					vertexColors: e.vertexColors,
					fog: n,
					useFog: e.fog,
					fogExp: n instanceof THREE.FogExp2,
					sizeAttenuation: e.sizeAttenuation,
					skinning: e.skinning,
					maxBones: l,
					useVertexTexture: Pt && r && r.useVertexTexture,
					morphTargets: e.morphTargets,
					morphNormals: e.morphNormals,
					maxMorphTargets: this.maxMorphTargets,
					maxMorphNormals: this.maxMorphNormals,
					maxDirLights: i,
					maxPointLights: s,
					maxSpotLights: o,
					maxHemiLights: u,
					maxShadows: c,
					shadowMapEnabled: this.shadowMapEnabled && r.receiveShadow && 0 < c,
					shadowMapType: this.shadowMapType,
					shadowMapDebug: this.shadowMapDebug,
					shadowMapCascade: this.shadowMapCascade,
					alphaTest: e.alphaTest,
					metal: e.metal,
					wrapAround: e.wrapAround,
					doubleSided: e.side === THREE.DoubleSide,
					flipSided: e.side === THREE.BackSide
				},
				r = e.index0AttributeName;
				var g, y, b;i = [],
				h ? i.push(h) : (i.push(v), i.push(d));
				for (y in m) i.push(y),
				i.push(m[y]);
				for (g in n) i.push(g),
				i.push(n[g]);h = i.join(),
				g = 0;
				for (y = W.length; g < y; g++)
					if (i = W[g], i.code === h) {
						i.usedTimes++, f = i.program;
						break e
					} g = "SHADOWMAP_TYPE_BASIC",
				n.shadowMapType === THREE.PCFShadowMap ? g = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === THREE.PCFSoftShadowMap && (g = "SHADOWMAP_TYPE_PCF_SOFT"),
				y = [];
				for (b in m) i = m[b],
				!1 !== i && (i = "#define " + b + " " + i, y.push(i));i = y.join("\n"),
				b = Tt.createProgram(),
				y = ["precision " + H + " float;", "precision " + H + " int;", i, Dt ? "#define VERTEX_TEXTURES" : "", z.gammaInput ? "#define GAMMA_INPUT" : "", z.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals ? "#define USE_MORPHNORMALS" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + g : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n"),
				g = ["precision " + H + " float;", "precision " + H + " int;", n.bumpMap || n.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", i, "#define MAX_DIR_LIGHTS " + n.maxDirLights, "#define MAX_POINT_LIGHTS " + n.maxPointLights, "#define MAX_SPOT_LIGHTS " + n.maxSpotLights, "#define MAX_HEMI_LIGHTS " + n.maxHemiLights, "#define MAX_SHADOWS " + n.maxShadows, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", z.gammaInput ? "#define GAMMA_INPUT" : "", z.gammaOutput ? "#define GAMMA_OUTPUT" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.metal ? "#define METAL" : "", n.wrapAround ? "#define WRAP_AROUND" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + g : "", n.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", n.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"),
				y = L("vertex", y + d),
				g = L("fragment", g + v),
				Tt.attachShader(b, y),
				Tt.attachShader(b, g),
				void 0 !== r && Tt.bindAttribLocation(b, 0, r),
				Tt.linkProgram(b),
				!1 === Tt.getProgramParameter(b, Tt.LINK_STATUS) && (console.error("Could not initialise shader"), console.error("gl.VALIDATE_STATUS", Tt.getProgramParameter(b, Tt.VALIDATE_STATUS)), console.error("gl.getError()", Tt.getError())),
				"" !== Tt.getProgramInfoLog(b) && console.error("gl.getProgramInfoLog()", Tt.getProgramInfoLog(b)),
				Tt.deleteShader(g),
				Tt.deleteShader(y),
				b.uniforms = {},
				b.attributes = {};
				var w;g = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" "),
				n.useVertexTexture ? (g.push("boneTexture"), g.push("boneTextureWidth"), g.push("boneTextureHeight")) : g.push("boneGlobalMatrices");
				for (w in p) g.push(w);w = g,
				g = 0;
				for (y = w.length; g < y; g++) p = w[g],
				b.uniforms[p] = Tt.getUniformLocation(b, p);g = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
				for (w = 0; w < n.maxMorphTargets; w++) g.push("morphTarget" + w);
				for (w = 0; w < n.maxMorphNormals; w++) g.push("morphNormal" + w);
				for (f in t) g.push(f);f = g,
				w = 0;
				for (t = f.length; w < t; w++) g = f[w],
				b.attributes[g] = Tt.getAttribLocation(b, g);b.id = X++,
				W.push({
					program: b,
					code: h,
					usedTimes: 1
				}),
				z.info.memory.programs = W.length,
				f = b
			}
			e.program = f, w = e.program.attributes;
			if (e.morphTargets)
				for (e.numSupportedMorphTargets = 0, t = "morphTarget", f = 0; f < this.maxMorphTargets; f++) b = t + f, 0 <= w[b] && e.numSupportedMorphTargets++;
			if (e.morphNormals)
				for (e.numSupportedMorphNormals = 0, t = "morphNormal", f = 0; f < this.maxMorphNormals; f++) b = t + f, 0 <= w[b] && e.numSupportedMorphNormals++;
			e.uniformsList = [];
			for (a in e.uniforms) e.uniformsList.push([e.uniforms[a], a])
		}, this.setFaceCulling = function(e, t) {
			e === THREE.CullFaceNone ? Tt.disable(Tt.CULL_FACE) : (t === THREE.FrontFaceDirectionCW ? Tt.frontFace(Tt.CW) : Tt.frontFace(Tt.CCW), e === THREE.CullFaceBack ? Tt.cullFace(Tt.BACK) : e === THREE.CullFaceFront ? Tt.cullFace(Tt.FRONT) : Tt.cullFace(Tt.FRONT_AND_BACK), Tt.enable(Tt.CULL_FACE))
		}, this.setMaterialFaces = function(e) {
			var t = e.side === THREE.DoubleSide;
			e = e.side === THREE.BackSide, Y !== t && (t ? Tt.disable(Tt.CULL_FACE) : Tt.enable(Tt.CULL_FACE), Y = t), Z !== e && (e ? Tt.frontFace(Tt.CW) : Tt.frontFace(Tt.CCW), Z = e)
		}, this.setDepthTest = function(e) {
			it !== e && (e ? Tt.enable(Tt.DEPTH_TEST) : Tt.disable(Tt.DEPTH_TEST), it = e)
		}, this.setDepthWrite = function(e) {
			st !== e && (Tt.depthMask(e), st = e)
		}, this.setBlending = function(e, t, n, r) {
			e !== et && (e === THREE.NoBlending ? Tt.disable(Tt.BLEND) : e === THREE.AdditiveBlending ? (Tt.enable(Tt.BLEND), Tt.blendEquation(Tt.FUNC_ADD), Tt.blendFunc(Tt.SRC_ALPHA, Tt.ONE)) : e === THREE.SubtractiveBlending ? (Tt.enable(Tt.BLEND), Tt.blendEquation(Tt.FUNC_ADD), Tt.blendFunc(Tt.ZERO, Tt.ONE_MINUS_SRC_COLOR)) : e === THREE.MultiplyBlending ? (Tt.enable(Tt.BLEND), Tt.blendEquation(Tt.FUNC_ADD), Tt.blendFunc(Tt.ZERO, Tt.SRC_COLOR)) : e === THREE.CustomBlending ? Tt.enable(Tt.BLEND) : (Tt.enable(Tt.BLEND), Tt.blendEquationSeparate(Tt.FUNC_ADD, Tt.FUNC_ADD), Tt.blendFuncSeparate(Tt.SRC_ALPHA, Tt.ONE_MINUS_SRC_ALPHA, Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA)), et = e);
			if (e === THREE.CustomBlending) {
				if (t !== tt && (Tt.blendEquation(_(t)), tt = t), n !== nt || r !== rt) Tt.blendFunc(_(n), _(r)), nt = n, rt = r
			} else rt = nt = tt = null
		}, this.setTexture = function(e, t) {
			if (e.needsUpdate) {
				e.__webglInit || (e.__webglInit = !0, e.addEventListener("dispose", Ut), e.__webglTexture = Tt.createTexture(), z.info.memory.textures++), Tt.activeTexture(Tt.TEXTURE0 + t), Tt.bindTexture(Tt.TEXTURE_2D, e.__webglTexture), Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, e.flipY), Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, e.unpackAlignment);
				var n = e.image,
					r = THREE.Math.isPowerOfTwo(n.width) && THREE.Math.isPowerOfTwo(n.height),
					i = _(e.format),
					s = _(e.type);
				A(Tt.TEXTURE_2D, e, r);
				var o = e.mipmaps;
				if (e instanceof THREE.DataTexture)
					if (0 < o.length && r) {
						for (var u = 0, a = o.length; u < a; u++) n = o[u], Tt.texImage2D(Tt.TEXTURE_2D, u, i, n.width, n.height, 0, i, s, n.data);
						e.generateMipmaps = !1
					} else Tt.texImage2D(Tt.TEXTURE_2D, 0, i, n.width, n.height, 0, i, s, n.data);
				else if (e instanceof THREE.CompressedTexture)
					for (u = 0, a = o.length; u < a; u++) n = o[u], e.format !== THREE.RGBAFormat ? Tt.compressedTexImage2D(Tt.TEXTURE_2D, u, i, n.width, n.height, 0, n.data) : Tt.texImage2D(Tt.TEXTURE_2D, u, i, n.width, n.height, 0, i, s, n.data);
				else if (0 < o.length && r) {
					u = 0;
					for (a = o.length; u < a; u++) n = o[u], Tt.texImage2D(Tt.TEXTURE_2D, u, i, i, s, n);
					e.generateMipmaps = !1
				} else Tt.texImage2D(Tt.TEXTURE_2D, 0, i, i, s, e.image);
				e.generateMipmaps && r && Tt.generateMipmap(Tt.TEXTURE_2D), e.needsUpdate = !1, e.onUpdate && e.onUpdate()
			} else Tt.activeTexture(Tt.TEXTURE0 + t), Tt.bindTexture(Tt.TEXTURE_2D, e.__webglTexture)
		}, this.setRenderTarget = function(e) {
			var t = e instanceof THREE.WebGLRenderTargetCube;
			if (e && !e.__webglFramebuffer) {
				void 0 === e.depthBuffer && (e.depthBuffer = !0), void 0 === e.stencilBuffer && (e.stencilBuffer = !0), e.addEventListener("dispose", zt), e.__webglTexture = Tt.createTexture(), z.info.memory.textures++;
				var n = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height),
					r = _(e.format),
					i = _(e.type);
				if (t) {
					e.__webglFramebuffer = [], e.__webglRenderbuffer = [], Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, e.__webglTexture), A(Tt.TEXTURE_CUBE_MAP, e, n);
					for (var s = 0; 6 > s; s++) {
						e.__webglFramebuffer[s] = Tt.createFramebuffer(), e.__webglRenderbuffer[s] = Tt.createRenderbuffer(), Tt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, r, e.width, e.height, 0, r, i, null);
						var o = e,
							u = Tt.TEXTURE_CUBE_MAP_POSITIVE_X + s;
						Tt.bindFramebuffer(Tt.FRAMEBUFFER, e.__webglFramebuffer[s]), Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, u, o.__webglTexture, 0), O(e.__webglRenderbuffer[s], e)
					}
					n && Tt.generateMipmap(Tt.TEXTURE_CUBE_MAP)
				} else e.__webglFramebuffer = Tt.createFramebuffer(), e.__webglRenderbuffer = e.shareDepthFrom ? e.shareDepthFrom.__webglRenderbuffer : Tt.createRenderbuffer(), Tt.bindTexture(Tt.TEXTURE_2D, e.__webglTexture), A(Tt.TEXTURE_2D, e, n), Tt.texImage2D(Tt.TEXTURE_2D, 0, r, e.width, e.height, 0, r, i, null), r = Tt.TEXTURE_2D, Tt.bindFramebuffer(Tt.FRAMEBUFFER, e.__webglFramebuffer), Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, r, e.__webglTexture, 0), e.shareDepthFrom ? e.depthBuffer && !e.stencilBuffer ? Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.RENDERBUFFER, e.__webglRenderbuffer) : e.depthBuffer && e.stencilBuffer && Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.RENDERBUFFER, e.__webglRenderbuffer) : O(e.__webglRenderbuffer, e), n && Tt.generateMipmap(Tt.TEXTURE_2D);
				t ? Tt.bindTexture(Tt.TEXTURE_CUBE_MAP, null) : Tt.bindTexture(Tt.TEXTURE_2D, null), Tt.bindRenderbuffer(Tt.RENDERBUFFER, null), Tt.bindFramebuffer(Tt.FRAMEBUFFER, null)
			}
			e ? (t = t ? e.__webglFramebuffer[e.activeCubeFace] : e.__webglFramebuffer, n = e.width, e = e.height, i = r = 0) : (t = null, n = ht, e = pt, r = lt, i = ct), t !== $ && (Tt.bindFramebuffer(Tt.FRAMEBUFFER, t), Tt.viewport(r, i, n, e), $ = t), dt = n, vt = e
		}, this.shadowMapPlugin = new THREE.ShadowMapPlugin, this.addPrePlugin(this.shadowMapPlugin), this.addPostPlugin(new THREE.SpritePlugin), this.addPostPlugin(new THREE.LensFlarePlugin)
	}, THREE.WebGLRenderTarget = function(e, t, n) {
		this.width = e, this.height = t, n = n || {}, this.wrapS = void 0 !== n.wrapS ? n.wrapS : THREE.ClampToEdgeWrapping, this.wrapT = void 0 !== n.wrapT ? n.wrapT : THREE.ClampToEdgeWrapping, this.magFilter = void 0 !== n.magFilter ? n.magFilter : THREE.LinearFilter, this.minFilter = void 0 !== n.minFilter ? n.minFilter : THREE.LinearMipMapLinearFilter, this.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, this.offset = new THREE.Vector2(0, 0), this.repeat = new THREE.Vector2(1, 1), this.format = void 0 !== n.format ? n.format : THREE.RGBAFormat, this.type = void 0 !== n.type ? n.type : THREE.UnsignedByteType, this.depthBuffer = void 0 !== n.depthBuffer ? n.depthBuffer : !0, this.stencilBuffer = void 0 !== n.stencilBuffer ? n.stencilBuffer : !0, this.generateMipmaps = !0, this.shareDepthFrom = null
	}, THREE.WebGLRenderTarget.prototype = {
		constructor: THREE.WebGLRenderTarget,
		clone: function() {
			var e = new THREE.WebGLRenderTarget(this.width, this.height);
			return e.wrapS = this.wrapS, e.wrapT = this.wrapT, e.magFilter = this.magFilter, e.minFilter = this.minFilter, e.anisotropy = this.anisotropy, e.offset.copy(this.offset), e.repeat.copy(this.repeat), e.format = this.format, e.type = this.type, e.depthBuffer = this.depthBuffer, e.stencilBuffer = this.stencilBuffer, e.generateMipmaps = this.generateMipmaps, e.shareDepthFrom = this.shareDepthFrom, e
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}, THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype), THREE.WebGLRenderTargetCube = function(e, t, n) {
		THREE.WebGLRenderTarget.call(this, e, t, n), this.activeCubeFace = 0
	}, THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype), THREE.RenderableVertex = function() {
		this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
	}, THREE.RenderableVertex.prototype.copy = function(e) {
		this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen)
	}, THREE.RenderableFace = function() {
		this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.centroidModel = new THREE.Vector3, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.material = this.color = null, this.uvs = [
			[]
		], this.z = 0
	}, THREE.RenderableObject = function() {
		this.id = 0, this.object = null, this.z = 0
	}, THREE.RenderableSprite = function() {
		this.id = 0, this.object = null, this.rotation = this.z = this.y = this.x = 0, this.scale = new THREE.Vector2, this.material = null
	}, THREE.RenderableLine = function() {
		this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
	}, THREE.GeometryUtils = {
		merge: function(e, t, n) {
			var r, i, s = e.vertices.length,
				o = t instanceof THREE.Mesh ? t.geometry : t,
				u = e.vertices,
				a = o.vertices,
				f = e.faces,
				l = o.faces;
			e = e.faceVertexUvs[0], o = o.faceVertexUvs[0], void 0 === n && (n = 0), t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, i = (new THREE.Matrix3).getNormalMatrix(r)), t = 0;
			for (var c = a.length; t < c; t++) {
				var h = a[t].clone();
				r && h.applyMatrix4(r), u.push(h)
			}
			t = 0;
			for (c = l.length; t < c; t++) {
				var h = l[t],
					p, d, v = h.vertexNormals,
					m = h.vertexColors;
				p = new THREE.Face3(h.a + s, h.b + s, h.c + s), p.normal.copy(h.normal), i && p.normal.applyMatrix3(i).normalize(), u = 0;
				for (a = v.length; u < a; u++) d = v[u].clone(), i && d.applyMatrix3(i).normalize(), p.vertexNormals.push(d);
				p.color.copy(h.color), u = 0;
				for (a = m.length; u < a; u++) d = m[u], p.vertexColors.push(d.clone());
				p.materialIndex = h.materialIndex + n, p.centroid.copy(h.centroid), r && p.centroid.applyMatrix4(r), f.push(p)
			}
			t = 0;
			for (c = o.length; t < c; t++) {
				n = o[t], r = [], u = 0;
				for (a = n.length; u < a; u++) r.push(new THREE.Vector2(n[u].x, n[u].y));
				e.push(r)
			}
		},
		randomPointInTriangle: function() {
			var e = new THREE.Vector3;
			return function(t, n, r) {
				var i = new THREE.Vector3,
					s = THREE.Math.random16(),
					o = THREE.Math.random16();
				1 < s + o && (s = 1 - s, o = 1 - o);
				var u = 1 - s - o;
				return i.copy(t), i.multiplyScalar(s), e.copy(n), e.multiplyScalar(o), i.add(e), e.copy(r), e.multiplyScalar(u), i.add(e), i
			}
		}(),
		randomPointInFace: function(e, t, n) {
			return THREE.GeometryUtils.randomPointInTriangle(t.vertices[e.a], t.vertices[e.b], t.vertices[e.c])
		},
		randomPointsInGeometry: function(e, t) {
			function n(e) {
				function t(n, r) {
					if (r < n) return n;
					var i = n + Math.floor((r - n) / 2);
					return f[i] > e ? t(n, i - 1) : f[i] < e ? t(i + 1, r) : i
				}
				return t(0, f.length - 1)
			}
			var r, i, s = e.faces,
				o = e.vertices,
				u = s.length,
				a = 0,
				f = [],
				l, c, h;
			for (i = 0; i < u; i++) r = s[i], l = o[r.a], c = o[r.b], h = o[r.c], r._area = THREE.GeometryUtils.triangleArea(l, c, h), a += r._area, f[i] = a;
			r = [];
			for (i = 0; i < t; i++) o = THREE.Math.random16() * a, o = n(o), r[i] = THREE.GeometryUtils.randomPointInFace(s[o], e, !0);
			return r
		},
		triangleArea: function() {
			var e = new THREE.Vector3,
				t = new THREE.Vector3;
			return function(n, r, i) {
				return e.subVectors(r, n), t.subVectors(i, n), e.cross(t), .5 * e.length()
			}
		}(),
		center: function(e) {
			e.computeBoundingBox();
			var t = e.boundingBox,
				n = new THREE.Vector3;
			return n.addVectors(t.min, t.max), n.multiplyScalar(-0.5), e.applyMatrix((new THREE.Matrix4).makeTranslation(n.x, n.y, n.z)), e.computeBoundingBox(), n
		},
		triangulateQuads: function(e) {
			var t, n, r, i, s = [],
				o = [];
			t = 0;
			for (n = e.faceVertexUvs.length; t < n; t++) o[t] = [];
			t = 0;
			for (n = e.faces.length; t < n; t++)
				for (s.push(e.faces[t]), r = 0, i = e.faceVertexUvs.length; r < i; r++) o[r].push(e.faceVertexUvs[r][t]);
			e.faces = s, e.faceVertexUvs = o, e.computeCentroids(), e.computeFaceNormals(), e.computeVertexNormals(), e.hasTangents && e.computeTangents()
		}
	}, THREE.ImageUtils = {
		crossOrigin: void 0,
		loadTexture: function(e, t, n, r) {
			r = new THREE.ImageLoader, r.crossOrigin = this.crossOrigin;
			var i = new THREE.Texture(void 0, t);
			return t = r.load(e, function() {
				i.needsUpdate = !0, n && n(i)
			}), i.image = t, i.sourceFile = e, i
		},
		loadCompressedTexture: function(e, t, n, r) {
			var i = new THREE.CompressedTexture;
			i.mapping = t;
			var s = new XMLHttpRequest;
			return s.onload = function() {
				var e = THREE.ImageUtils.parseDDS(s.response, !0);
				i.format = e.format, i.mipmaps = e.mipmaps, i.image.width = e.width, i.image.height = e.height, i.generateMipmaps = !1, i.needsUpdate = !0, n && n(i)
			}, s.onerror = r, s.open("GET", e, !0), s.responseType = "arraybuffer", s.send(null), i
		},
		loadTextureCube: function(e, t, n, r) {
			var i = [];
			i.loadCount = 0;
			var s = new THREE.Texture;
			s.image = i, void 0 !== t && (s.mapping = t), s.flipY = !1, t = 0;
			for (var o = e.length; t < o; ++t) {
				var u = new Image;
				i[t] = u, u.onload = function() {
					i.loadCount += 1, 6 === i.loadCount && (s.needsUpdate = !0, n && n(s))
				}, u.onerror = r, u.crossOrigin = this.crossOrigin, u.src = e[t]
			}
			return s
		},
		loadCompressedTextureCube: function(e, t, n, r) {
			var i = [];
			i.loadCount = 0;
			var s = new THREE.CompressedTexture;
			s.image = i, void 0 !== t && (s.mapping = t), s.flipY = !1, s.generateMipmaps = !1, t = function(e, t) {
				return function() {
					var r = THREE.ImageUtils.parseDDS(e.response, !0);
					t.format = r.format, t.mipmaps = r.mipmaps, t.width = r.width, t.height = r.height, i.loadCount += 1, 6 === i.loadCount && (s.format = r.format, s.needsUpdate = !0, n && n(s))
				}
			};
			if (e instanceof Array)
				for (var o = 0, u = e.length; o < u; ++o) {
					var a = {};
					i[o] = a;
					var f = new XMLHttpRequest;
					f.onload = t(f, a), f.onerror = r, a = e[o], f.open("GET", a, !0), f.responseType = "arraybuffer", f.send(null)
				} else f = new XMLHttpRequest, f.onload = function() {
					var e = THREE.ImageUtils.parseDDS(f.response, !0);
					if (e.isCubemap) {
						for (var t = e.mipmaps.length / e.mipmapCount, r = 0; r < t; r++) {
							i[r] = {
								mipmaps: []
							};
							for (var o = 0; o < e.mipmapCount; o++) i[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + o]), i[r].format = e.format, i[r].width = e.width, i[r].height = e.height
						}
						s.format = e.format, s.needsUpdate = !0, n && n(s)
					}
				}, f.onerror = r, f.open("GET", e, !0), f.responseType = "arraybuffer", f.send(null);
			return s
		},
		loadDDSTexture: function(e, t, n, r) {
			var i = [];
			i.loadCount = 0;
			var s = new THREE.CompressedTexture;
			s.image = i, void 0 !== t && (s.mapping = t), s.flipY = !1, s.generateMipmaps = !1;
			var o = new XMLHttpRequest;
			return o.onload = function() {
				var e = THREE.ImageUtils.parseDDS(o.response, !0);
				if (e.isCubemap)
					for (var t = e.mipmaps.length / e.mipmapCount, r = 0; r < t; r++) {
						i[r] = {
							mipmaps: []
						};
						for (var u = 0; u < e.mipmapCount; u++) i[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + u]), i[r].format = e.format, i[r].width = e.width, i[r].height = e.height
					} else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
				s.format = e.format, s.needsUpdate = !0, n && n(s)
			}, o.onerror = r, o.open("GET", e, !0), o.responseType = "arraybuffer", o.send(null), s
		},
		parseDDS: function(e, t) {
			function n(e) {
				return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24)
			}

			function r(e, t, n, r) {
				var i = n * r * 4;
				e = new Uint8Array(e, t, i);
				for (var i = new Uint8Array(i), s = t = 0, o = 0; o < r; o++)
					for (var u = 0; u < n; u++) {
						var a = e[s];
						s++;
						var f = e[s];
						s++;
						var l = e[s];
						s++;
						var c = e[s];
						s++, i[t] = l, t++, i[t] = f, t++, i[t] = a, t++, i[t] = c, t++
					}
				return i
			}
			var i = {
					mipmaps: [],
					width: 0,
					height: 0,
					format: null,
					mipmapCount: 1
				},
				s = n("DXT1"),
				o = n("DXT3"),
				u = n("DXT5"),
				a = new Int32Array(e, 0, 31);
			if (542327876 !== a[0]) return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), i;
			if (!a[20] & 4) return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), i;
			var f = a[21],
				l = !1;
			switch (f) {
				case s:
					s = 8, i.format = THREE.RGB_S3TC_DXT1_Format;
					break;
				case o:
					s = 16, i.format = THREE.RGBA_S3TC_DXT3_Format;
					break;
				case u:
					s = 16, i.format = THREE.RGBA_S3TC_DXT5_Format;
					break;
				default:
					if (!(32 == a[22] && a[23] & 16711680 && a[24] & 65280 && a[25] & 255 && a[26] & 4278190080)) return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(f & 255, f >> 8 & 255, f >> 16 & 255, f >> 24 & 255)), i;
					l = !0, s = 64, i.format = THREE.RGBAFormat
			}
			i.mipmapCount = 1, a[2] & 131072 && !1 !== t && (i.mipmapCount = Math.max(1, a[7])), i.isCubemap = a[28] & 512 ? !0 : !1, i.width = a[4], i.height = a[3];
			for (var a = a[1] + 4, o = i.width, u = i.height, f = i.isCubemap ? 6 : 1, c = 0; c < f; c++) {
				for (var h = 0; h < i.mipmapCount; h++) {
					if (l) var p = r(e, a, o, u),
						d = p.length;
					else d = Math.max(4, o) / 4 * Math.max(4, u) / 4 * s, p = new Uint8Array(e, a, d);
					i.mipmaps.push({
						data: p,
						width: o,
						height: u
					}), a += d, o = Math.max(.5 * o, 1), u = Math.max(.5 * u, 1)
				}
				o = i.width, u = i.height
			}
			return i
		},
		getNormalMap: function(e, t) {
			var n = function(e) {
				var t = Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
				return [e[0] / t, e[1] / t, e[2] / t]
			};
			t |= 1;
			var r = e.width,
				i = e.height,
				s = document.createElement("canvas");
			s.width = r, s.height = i;
			var o = s.getContext("2d");
			o.drawImage(e, 0, 0);
			for (var u = o.getImageData(0, 0, r, i).data, a = o.createImageData(r, i), f = a.data, l = 0; l < r; l++)
				for (var c = 0; c < i; c++) {
					var h = 0 > c - 1 ? 0 : c - 1,
						p = c + 1 > i - 1 ? i - 1 : c + 1,
						d = 0 > l - 1 ? 0 : l - 1,
						v = l + 1 > r - 1 ? r - 1 : l + 1,
						m = [],
						g = [0, 0, u[4 * (c * r + l)] / 255 * t];
					m.push([-1, 0, u[4 * (c * r + d)] / 255 * t]), m.push([-1, -1, u[4 * (h * r + d)] / 255 * t]), m.push([0, -1, u[4 * (h * r + l)] / 255 * t]), m.push([1, -1, u[4 * (h * r + v)] / 255 * t]), m.push([1, 0, u[4 * (c * r + v)] / 255 * t]), m.push([1, 1, u[4 * (p * r + v)] / 255 * t]), m.push([0, 1, u[4 * (p * r + l)] / 255 * t]), m.push([-1, 1, u[4 * (p * r + d)] / 255 * t]), h = [], d = m.length;
					for (p = 0; p < d; p++) {
						var v = m[p],
							y = m[(p + 1) % d],
							v = [v[0] - g[0], v[1] - g[1], v[2] - g[2]],
							y = [y[0] - g[0], y[1] - g[1], y[2] - g[2]];
						h.push(n([v[1] * y[2] - v[2] * y[1], v[2] * y[0] - v[0] * y[2], v[0] * y[1] - v[1] * y[0]]))
					}
					m = [0, 0, 0];
					for (p = 0; p < h.length; p++) m[0] += h[p][0], m[1] += h[p][1], m[2] += h[p][2];
					m[0] /= h.length, m[1] /= h.length, m[2] /= h.length, g = 4 * (c * r + l), f[g] = (m[0] + 1) / 2 * 255 | 0, f[g + 1] = (m[1] + 1) / 2 * 255 | 0, f[g + 2] = 255 * m[2] | 0, f[g + 3] = 255
				}
			return o.putImageData(a, 0, 0), s
		},
		generateDataTexture: function(e, t, n) {
			var r = e * t,
				i = new Uint8Array(3 * r),
				s = Math.floor(255 * n.r),
				o = Math.floor(255 * n.g);
			n = Math.floor(255 * n.b);
			for (var u = 0; u < r; u++) i[3 * u] = s, i[3 * u + 1] = o, i[3 * u + 2] = n;
			return e = new THREE.DataTexture(i, e, t, THREE.RGBFormat), e.needsUpdate = !0, e
		}
	}, THREE.SceneUtils = {
		createMultiMaterialObject: function(e, t) {
			for (var n = new THREE.Object3D, r = 0, i = t.length; r < i; r++) n.add(new THREE.Mesh(e, t[r]));
			return n
		},
		detach: function(e, t, n) {
			e.applyMatrix(t.matrixWorld), t.remove(e), n.add(e)
		},
		attach: function(e, t, n) {
			var r = new THREE.Matrix4;
			r.getInverse(n.matrixWorld), e.applyMatrix(r), t.remove(e), n.add(e)
		}
	}, THREE.FontUtils = {
		faces: {},
		face: "helvetiker",
		weight: "normal",
		style: "normal",
		size: 150,
		divisions: 10,
		getFace: function() {
			return this.faces[this.face][this.weight][this.style]
		},
		loadFace: function(e) {
			var t = e.familyName.toLowerCase();
			return this.faces[t] = this.faces[t] || {}, this.faces[t][e.cssFontWeight] = this.faces[t][e.cssFontWeight] || {}, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e, this.faces[t][e.cssFontWeight][e.cssFontStyle] = e
		},
		drawText: function(e) {
			var t = this.getFace(),
				n = this.size / t.resolution,
				r = 0,
				i = String(e).split(""),
				s = i.length,
				o = [];
			for (e = 0; e < s; e++) {
				var u = new THREE.Path,
					u = this.extractGlyphPoints(i[e], t, n, r, u),
					r = r + u.offset;
				o.push(u.path)
			}
			return {
				paths: o,
				offset: r / 2
			}
		},
		extractGlyphPoints: function(e, t, n, r, i) {
			var s = [],
				o, u, a, f, l, c, h, p, d, v, m, g = t.glyphs[e] || t.glyphs["?"];
			if (g) {
				if (g.o)
					for (t = g._cachedOutline || (g._cachedOutline = g.o.split(" ")), f = t.length, e = 0; e < f;) switch (a = t[e++], a) {
						case "m":
							a = t[e++] * n + r, l = t[e++] * n, i.moveTo(a, l);
							break;
						case "l":
							a = t[e++] * n + r, l = t[e++] * n, i.lineTo(a, l);
							break;
						case "q":
							a = t[e++] * n + r, l = t[e++] * n, p = t[e++] * n + r, d = t[e++] * n, i.quadraticCurveTo(p, d, a, l);
							if (o = s[s.length - 1])
								for (c = o.x, h = o.y, o = 1, u = this.divisions; o <= u; o++) {
									var y = o / u;
									THREE.Shape.Utils.b2(y, c, p, a), THREE.Shape.Utils.b2(y, h, d, l)
								}
							break;
						case "b":
							if (a = t[e++] * n + r, l = t[e++] * n, p = t[e++] * n + r, d = t[e++] * -n, v = t[e++] * n + r, m = t[e++] * -n, i.bezierCurveTo(a, l, p, d, v, m), o = s[s.length - 1])
								for (c = o.x, h = o.y, o = 1, u = this.divisions; o <= u; o++) y = o / u, THREE.Shape.Utils.b3(y, c, p, v, a), THREE.Shape.Utils.b3(y, h, d, m, l)
					}
				return {
					offset: g.ha * n,
					path: i
				}
			}
		}
	}, THREE.FontUtils.generateShapes = function(e, t) {
		t = t || {};
		var n = void 0 !== t.curveSegments ? t.curveSegments : 4,
			r = void 0 !== t.font ? t.font : "helvetiker",
			i = void 0 !== t.weight ? t.weight : "normal",
			s = void 0 !== t.style ? t.style : "normal";
		THREE.FontUtils.size = void 0 !== t.size ? t.size : 100, THREE.FontUtils.divisions = n, THREE.FontUtils.face = r, THREE.FontUtils.weight = i, THREE.FontUtils.style = s, n = THREE.FontUtils.drawText(e).paths, r = [], i = 0;
		for (s = n.length; i < s; i++) Array.prototype.push.apply(r, n[i].toShapes());
		return r
	},
	function(e) {
		var t = function(e) {
			for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
			return .5 * n
		};
		return e.Triangulate = function(e, n) {
			var r = e.length;
			if (3 > r) return null;
			var i = [],
				s = [],
				o = [],
				u, a, f;
			if (0 < t(e))
				for (a = 0; a < r; a++) s[a] = a;
			else
				for (a = 0; a < r; a++) s[a] = r - 1 - a;
			var l = 2 * r;
			for (a = r - 1; 2 < r;) {
				if (0 >= l--) {
					console.log("Warning, unable to triangulate polygon!");
					break
				}
				u = a, r <= u && (u = 0), a = u + 1, r <= a && (a = 0), f = a + 1, r <= f && (f = 0);
				var c;
				e: {
					var h = c = void 0,
						p = void 0,
						d = void 0,
						v = void 0,
						m = void 0,
						g = void 0,
						y = void 0,
						w = void 0,
						h = e[s[u]].x,
						p = e[s[u]].y,
						d = e[s[a]].x,
						v = e[s[a]].y,
						m = e[s[f]].x,
						g = e[s[f]].y;
					if (1e-10 > (d - h) * (g - p) - (v - p) * (m - h)) c = !1;
					else {
						var E = void 0,
							S = void 0,
							x = void 0,
							T = void 0,
							N = void 0,
							C = void 0,
							k = void 0,
							L = void 0,
							A = void 0,
							O = void 0,
							A = L = k = w = y = void 0,
							E = m - d,
							S = g - v,
							x = h - m,
							T = p - g,
							N = d - h,
							C = v - p;
						for (c = 0; c < r; c++)
							if (y = e[s[c]].x, w = e[s[c]].y, !(y === h && w === p || y === d && w === v || y === m && w === g) && (k = y - h, L = w - p, A = y - d, O = w - v, y -= m, w -= g, A = E * O - S * A, k = N * L - C * k, L = x * w - T * y, -1e-10 <= A && -1e-10 <= L && -1e-10 <= k)) {
								c = !1;
								break e
							} c = !0
					}
				}
				if (c) {
					i.push([e[s[u]], e[s[a]], e[s[f]]]), o.push([s[u], s[a], s[f]]), u = a;
					for (f = a + 1; f < r; u++, f++) s[u] = s[f];
					r--, l = 2 * r
				}
			}
			return n ? o : i
		}, e.Triangulate.area = t, e
	}(THREE.FontUtils), self._typeface_js = {
		faces: THREE.FontUtils.faces,
		loadFace: THREE.FontUtils.loadFace
	}, THREE.typeface_js = self._typeface_js, THREE.Curve = function() {}, THREE.Curve.prototype.getPoint = function(e) {
		return console.log("Warning, getPoint() not implemented!"), null
	}, THREE.Curve.prototype.getPointAt = function(e) {
		return e = this.getUtoTmapping(e), this.getPoint(e)
	}, THREE.Curve.prototype.getPoints = function(e) {
		e || (e = 5);
		var t, n = [];
		for (t = 0; t <= e; t++) n.push(this.getPoint(t / e));
		return n
	}, THREE.Curve.prototype.getSpacedPoints = function(e) {
		e || (e = 5);
		var t, n = [];
		for (t = 0; t <= e; t++) n.push(this.getPointAt(t / e));
		return n
	}, THREE.Curve.prototype.getLength = function() {
		var e = this.getLengths();
		return e[e.length - 1]
	}, THREE.Curve.prototype.getLengths = function(e) {
		e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
		if (this.cacheArcLengths && this.cacheArcLengths.length == e + 1 && !this.needsUpdate) return this.cacheArcLengths;
		this.needsUpdate = !1;
		var t = [],
			n, r = this.getPoint(0),
			i, s = 0;
		t.push(0);
		for (i = 1; i <= e; i++) n = this.getPoint(i / e), s += n.distanceTo(r), t.push(s), r = n;
		return this.cacheArcLengths = t
	}, THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = !0, this.getLengths()
	}, THREE.Curve.prototype.getUtoTmapping = function(e, t) {
		var n = this.getLengths(),
			r = 0,
			i = n.length,
			s;
		s = t ? t : e * n[i - 1];
		for (var o = 0, u = i - 1, a; o <= u;)
			if (r = Math.floor(o + (u - o) / 2), a = n[r] - s, 0 > a) o = r + 1;
			else {
				if (!(0 < a)) {
					u = r;
					break
				}
				u = r - 1
			} return r = u, n[r] == s ? r / (i - 1) : (o = n[r], n = (r + (s - o) / (n[r + 1] - o)) / (i - 1))
	}, THREE.Curve.prototype.getTangent = function(e) {
		var t = e - 1e-4;
		return e += 1e-4, 0 > t && (t = 0), 1 < e && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
	}, THREE.Curve.prototype.getTangentAt = function(e) {
		return e = this.getUtoTmapping(e), this.getTangent(e)
	}, THREE.Curve.Utils = {
		tangentQuadraticBezier: function(e, t, n, r) {
			return 2 * (1 - e) * (n - t) + 2 * e * (r - n)
		},
		tangentCubicBezier: function(e, t, n, r, i) {
			return -3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i
		},
		tangentSpline: function(e, t, n, r, i) {
			return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + (-6 * e * e + 6 * e) + (3 * e * e - 2 * e)
		},
		interpolate: function(e, t, n, r, i) {
			e = .5 * (n - e), r = .5 * (r - t);
			var s = i * i;
			return (2 * t - 2 * n + e + r) * i * s + (-3 * t + 3 * n - 2 * e - r) * s + e * i + t
		}
	}, THREE.Curve.create = function(e, t) {
		return e.prototype = Object.create(THREE.Curve.prototype), e.prototype.getPoint = t, e
	}, THREE.CurvePath = function() {
		this.curves = [], this.bends = [], this.autoClose = !1
	}, THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype), THREE.CurvePath.prototype.add = function(e) {
		this.curves.push(e)
	}, THREE.CurvePath.prototype.checkConnection = function() {}, THREE.CurvePath.prototype.closePath = function() {
		var e = this.curves[0].getPoint(0),
			t = this.curves[this.curves.length - 1].getPoint(1);
		e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
	}, THREE.CurvePath.prototype.getPoint = function(e) {
		var t = e * this.getLength(),
			n = this.getCurveLengths();
		for (e = 0; e < n.length;) {
			if (n[e] >= t) return t = n[e] - t, e = this.curves[e], t = 1 - t / e.getLength(), e.getPointAt(t);
			e++
		}
		return null
	}, THREE.CurvePath.prototype.getLength = function() {
		var e = this.getCurveLengths();
		return e[e.length - 1]
	}, THREE.CurvePath.prototype.getCurveLengths = function() {
		if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
		var e = [],
			t = 0,
			n, r = this.curves.length;
		for (n = 0; n < r; n++) t += this.curves[n].getLength(), e.push(t);
		return this.cacheLengths = e
	}, THREE.CurvePath.prototype.getBoundingBox = function() {
		var e = this.getPoints(),
			t, n, r, i, s, o;
		t = n = Number.NEGATIVE_INFINITY, i = s = Number.POSITIVE_INFINITY;
		var u, a, f, l, c = e[0] instanceof THREE.Vector3;
		l = c ? new THREE.Vector3 : new THREE.Vector2, a = 0;
		for (f = e.length; a < f; a++) u = e[a], u.x > t ? t = u.x : u.x < i && (i = u.x), u.y > n ? n = u.y : u.y < s && (s = u.y), c && (u.z > r ? r = u.z : u.z < o && (o = u.z)), l.add(u);
		return e = {
			minX: i,
			minY: s,
			maxX: t,
			maxY: n,
			centroid: l.divideScalar(f)
		}, c && (e.maxZ = r, e.minZ = o), e
	}, THREE.CurvePath.prototype.createPointsGeometry = function(e) {
		return e = this.getPoints(e, !0), this.createGeometry(e)
	}, THREE.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
		return e = this.getSpacedPoints(e, !0), this.createGeometry(e)
	}, THREE.CurvePath.prototype.createGeometry = function(e) {
		for (var t = new THREE.Geometry, n = 0; n < e.length; n++) t.vertices.push(new THREE.Vector3(e[n].x, e[n].y, e[n].z || 0));
		return t
	}, THREE.CurvePath.prototype.addWrapPath = function(e) {
		this.bends.push(e)
	}, THREE.CurvePath.prototype.getTransformedPoints = function(e, t) {
		var n = this.getPoints(e),
			r, i;
		t || (t = this.bends), r = 0;
		for (i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
		return n
	}, THREE.CurvePath.prototype.getTransformedSpacedPoints = function(e, t) {
		var n = this.getSpacedPoints(e),
			r, i;
		t || (t = this.bends), r = 0;
		for (i = t.length; r < i; r++) n = this.getWrapPoints(n, t[r]);
		return n
	}, THREE.CurvePath.prototype.getWrapPoints = function(e, t) {
		var n = this.getBoundingBox(),
			r, i, s, o, u, a;
		r = 0;
		for (i = e.length; r < i; r++) s = e[r], o = s.x, u = s.y, a = o / n.maxX, a = t.getUtoTmapping(a, o), o = t.getPoint(a), a = t.getTangent(a), a.set(-a.y, a.x).multiplyScalar(u), s.x = o.x + a.x, s.y = o.y + a.y;
		return e
	}, THREE.Gyroscope = function() {
		THREE.Object3D.call(this)
	}, THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype), THREE.Gyroscope.prototype.updateMatrixWorld = function(e) {
		this.matrixAutoUpdate && this.updateMatrix();
		if (this.matrixWorldNeedsUpdate || e) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0;
		for (var t = 0, n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e)
	}, THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3, THREE.Gyroscope.prototype.translationObject = new THREE.Vector3, THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion, THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion, THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3, THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3, THREE.Path = function(e) {
		THREE.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
	}, THREE.Path.prototype = Object.create(THREE.CurvePath.prototype), THREE.PathActions = {
		MOVE_TO: "moveTo",
		LINE_TO: "lineTo",
		QUADRATIC_CURVE_TO: "quadraticCurveTo",
		BEZIER_CURVE_TO: "bezierCurveTo",
		CSPLINE_THRU: "splineThru",
		ARC: "arc",
		ELLIPSE: "ellipse"
	}, THREE.Path.prototype.fromPoints = function(e) {
		this.moveTo(e[0].x, e[0].y);
		for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
	}, THREE.Path.prototype.moveTo = function(e, t) {
		var n = Array.prototype.slice.call(arguments);
		this.actions.push({
			action: THREE.PathActions.MOVE_TO,
			args: n
		})
	}, THREE.Path.prototype.lineTo = function(e, t) {
		var n = Array.prototype.slice.call(arguments),
			r = this.actions[this.actions.length - 1].args,
			r = new THREE.LineCurve(new THREE.Vector2(r[r.length - 2], r[r.length - 1]), new THREE.Vector2(e, t));
		this.curves.push(r), this.actions.push({
			action: THREE.PathActions.LINE_TO,
			args: n
		})
	}, THREE.Path.prototype.quadraticCurveTo = function(e, t, n, r) {
		var i = Array.prototype.slice.call(arguments),
			s = this.actions[this.actions.length - 1].args,
			s = new THREE.QuadraticBezierCurve(new THREE.Vector2(s[s.length - 2], s[s.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
		this.curves.push(s), this.actions.push({
			action: THREE.PathActions.QUADRATIC_CURVE_TO,
			args: i
		})
	}, THREE.Path.prototype.bezierCurveTo = function(e, t, n, r, i, s) {
		var o = Array.prototype.slice.call(arguments),
			u = this.actions[this.actions.length - 1].args,
			u = new THREE.CubicBezierCurve(new THREE.Vector2(u[u.length - 2], u[u.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, s));
		this.curves.push(u), this.actions.push({
			action: THREE.PathActions.BEZIER_CURVE_TO,
			args: o
		})
	}, THREE.Path.prototype.splineThru = function(e) {
		var t = Array.prototype.slice.call(arguments),
			n = this.actions[this.actions.length - 1].args,
			n = [new THREE.Vector2(n[n.length - 2], n[n.length - 1])];
		Array.prototype.push.apply(n, e), n = new THREE.SplineCurve(n), this.curves.push(n), this.actions.push({
			action: THREE.PathActions.CSPLINE_THRU,
			args: t
		})
	}, THREE.Path.prototype.arc = function(e, t, n, r, i, s) {
		var o = this.actions[this.actions.length - 1].args;
		this.absarc(e + o[o.length - 2], t + o[o.length - 1], n, r, i, s)
	}, THREE.Path.prototype.absarc = function(e, t, n, r, i, s) {
		this.absellipse(e, t, n, n, r, i, s)
	}, THREE.Path.prototype.ellipse = function(e, t, n, r, i, s, o) {
		var u = this.actions[this.actions.length - 1].args;
		this.absellipse(e + u[u.length - 2], t + u[u.length - 1], n, r, i, s, o)
	}, THREE.Path.prototype.absellipse = function(e, t, n, r, i, s, o) {
		var u = Array.prototype.slice.call(arguments),
			a = new THREE.EllipseCurve(e, t, n, r, i, s, o);
		this.curves.push(a), a = a.getPoint(1), u.push(a.x), u.push(a.y), this.actions.push({
			action: THREE.PathActions.ELLIPSE,
			args: u
		})
	}, THREE.Path.prototype.getSpacedPoints = function(e, t) {
		e || (e = 40);
		for (var n = [], r = 0; r < e; r++) n.push(this.getPoint(r / e));
		return n
	}, THREE.Path.prototype.getPoints = function(e, t) {
		if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(e, t);
		e = e || 12;
		var n = [],
			r, i, s, o, u, a, f, l, c, h, p, d, v;
		r = 0;
		for (i = this.actions.length; r < i; r++) switch (s = this.actions[r], o = s.action, s = s.args, o) {
			case THREE.PathActions.MOVE_TO:
				n.push(new THREE.Vector2(s[0], s[1]));
				break;
			case THREE.PathActions.LINE_TO:
				n.push(new THREE.Vector2(s[0], s[1]));
				break;
			case THREE.PathActions.QUADRATIC_CURVE_TO:
				u = s[2], a = s[3], c = s[0], h = s[1], 0 < n.length ? (o = n[n.length - 1], p = o.x, d = o.y) : (o = this.actions[r - 1].args, p = o[o.length - 2], d = o[o.length - 1]);
				for (s = 1; s <= e; s++) v = s / e, o = THREE.Shape.Utils.b2(v, p, c, u), v = THREE.Shape.Utils.b2(v, d, h, a), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.BEZIER_CURVE_TO:
				u = s[4], a = s[5], c = s[0], h = s[1], f = s[2], l = s[3], 0 < n.length ? (o = n[n.length - 1], p = o.x, d = o.y) : (o = this.actions[r - 1].args, p = o[o.length - 2], d = o[o.length - 1]);
				for (s = 1; s <= e; s++) v = s / e, o = THREE.Shape.Utils.b3(v, p, c, f, u), v = THREE.Shape.Utils.b3(v, d, h, l, a), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.CSPLINE_THRU:
				o = this.actions[r - 1].args, v = [new THREE.Vector2(o[o.length - 2], o[o.length - 1])], o = e * s[0].length, v = v.concat(s[0]), v = new THREE.SplineCurve(v);
				for (s = 1; s <= o; s++) n.push(v.getPointAt(s / o));
				break;
			case THREE.PathActions.ARC:
				u = s[0], a = s[1], h = s[2], f = s[3], o = s[4], c = !!s[5], p = o - f, d = 2 * e;
				for (s = 1; s <= d; s++) v = s / d, c || (v = 1 - v), v = f + v * p, o = u + h * Math.cos(v), v = a + h * Math.sin(v), n.push(new THREE.Vector2(o, v));
				break;
			case THREE.PathActions.ELLIPSE:
				for (u = s[0], a = s[1], h = s[2], l = s[3], f = s[4], o = s[5], c = !!s[6], p = o - f, d = 2 * e, s = 1; s <= d; s++) v = s / d, c || (v = 1 - v), v = f + v * p, o = u + h * Math.cos(v), v = a + l * Math.sin(v), n.push(new THREE.Vector2(o, v))
		}
		return r = n[n.length - 1], 1e-10 > Math.abs(r.x - n[0].x) && 1e-10 > Math.abs(r.y - n[0].y) && n.splice(n.length - 1, 1), t && n.push(n[0]), n
	}, THREE.Path.prototype.toShapes = function(e) {
		function t(e, t) {
			for (var n = t.length, r = !1, i = n - 1, s = 0; s < n; i = s++) {
				var o = t[i],
					u = t[s],
					a = u.x - o.x,
					f = u.y - o.y;
				if (1e-10 < Math.abs(f)) {
					if (0 > f && (o = t[s], a = -a, u = t[i], f = -f), !(e.y < o.y || e.y > u.y))
						if (e.y == o.y) {
							if (e.x == o.x) return !0
						} else {
							i = f * (e.x - o.x) - a * (e.y - o.y);
							if (0 == i) return !0;
							0 > i || (r = !r)
						}
				} else if (e.y == o.y && (u.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= u.x)) return !0
			}
			return r
		}
		var n, r, i, s, o = [],
			u = new THREE.Path;
		n = 0;
		for (r = this.actions.length; n < r; n++) i = this.actions[n], s = i.args, i = i.action, i == THREE.PathActions.MOVE_TO && 0 != u.actions.length && (o.push(u), u = new THREE.Path), u[i].apply(u, s);
		0 != u.actions.length && o.push(u);
		if (0 == o.length) return [];
		var a, f, l;
		s = [];
		if (1 == o.length) return f = o[0], l = new THREE.Shape, l.actions = f.actions, l.curves = f.curves, s.push(l), s;
		var c = !THREE.Shape.Utils.isClockWise(o[0].getPoints()),
			c = e ? !c : c;
		l = [], u = [], i = [];
		var h = 0,
			p;
		u[h] = void 0, i[h] = [], n = 0;
		for (r = o.length; n < r; n++) f = o[n], p = f.getPoints(), a = THREE.Shape.Utils.isClockWise(p), (a = e ? !a : a) ? (!c && u[h] && h++, u[h] = {
			s: new THREE.Shape,
			p: p
		}, u[h].s.actions = f.actions, u[h].s.curves = f.curves, c && h++, i[h] = []) : i[h].push({
			h: f,
			p: p[0]
		});
		if (1 < u.length) {
			n = !1, r = [], e = 0;
			for (o = u.length; e < o; e++) l[e] = [];
			e = 0;
			for (o = u.length; e < o; e++)
				for (f = i[e], a = 0; a < f.length; a++) {
					c = f[a], h = !0;
					for (p = 0; p < u.length; p++) t(c.p, u[p].p) && (e != p && r.push({
						froms: e,
						tos: p,
						hole: a
					}), h ? (h = !1, l[p].push(c)) : n = !0);
					h && l[e].push(c)
				}
			0 < r.length && (n || (i = l))
		}
		n = 0;
		for (r = u.length; n < r; n++)
			for (l = u[n].s, s.push(l), e = i[n], o = 0, f = e.length; o < f; o++) l.holes.push(e[o].h);
		return s
	}, THREE.Shape = function() {
		THREE.Path.apply(this, arguments), this.holes = []
	}, THREE.Shape.prototype = Object.create(THREE.Path.prototype), THREE.Shape.prototype.extrude = function(e) {
		return new THREE.ExtrudeGeometry(this, e)
	}, THREE.Shape.prototype.makeGeometry = function(e) {
		return new THREE.ShapeGeometry(this, e)
	}, THREE.Shape.prototype.getPointsHoles = function(e) {
		var t, n = this.holes.length,
			r = [];
		for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedPoints(e, this.bends);
		return r
	}, THREE.Shape.prototype.getSpacedPointsHoles = function(e) {
		var t, n = this.holes.length,
			r = [];
		for (t = 0; t < n; t++) r[t] = this.holes[t].getTransformedSpacedPoints(e, this.bends);
		return r
	}, THREE.Shape.prototype.extractAllPoints = function(e) {
		return {
			shape: this.getTransformedPoints(e),
			holes: this.getPointsHoles(e)
		}
	}, THREE.Shape.prototype.extractPoints = function(e) {
		return this.useSpacedPoints ? this.extractAllSpacedPoints(e) : this.extractAllPoints(e)
	}, THREE.Shape.prototype.extractAllSpacedPoints = function(e) {
		return {
			shape: this.getTransformedSpacedPoints(e),
			holes: this.getSpacedPointsHoles(e)
		}
	}, THREE.Shape.Utils = {
		triangulateShape: function(e, t) {
			function n(e, t, n) {
				return e.x != t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x : t.x <= n.x && n.x <= e.x : e.y < t.y ? e.y <= n.y && n.y <= t.y : t.y <= n.y && n.y <= e.y
			}

			function r(e, t, r, i, s) {
				var o = t.x - e.x,
					u = t.y - e.y,
					a = i.x - r.x,
					f = i.y - r.y,
					l = e.x - r.x,
					c = e.y - r.y,
					h = u * a - o * f,
					p = u * l - o * c;
				if (1e-10 < Math.abs(h)) {
					if (0 < h) {
						if (0 > p || p > h) return [];
						a = f * l - a * c;
						if (0 > a || a > h) return []
					} else {
						if (0 < p || p < h) return [];
						a = f * l - a * c;
						if (0 < a || a < h) return []
					}
					return 0 == a ? !s || 0 != p && p != h ? [e] : [] : a == h ? !s || 0 != p && p != h ? [t] : [] : 0 == p ? [r] : p == h ? [i] : (s = a / h, [{
						x: e.x + s * o,
						y: e.y + s * u
					}])
				}
				return 0 != p || f * l != a * c ? [] : (u = 0 == o && 0 == u, a = 0 == a && 0 == f, u && a ? e.x != r.x || e.y != r.y ? [] : [e] : u ? n(r, i, e) ? [e] : [] : a ? n(e, t, r) ? [r] : [] : (0 != o ? (e.x < t.x ? (o = e, a = e.x, u = t, e = t.x) : (o = t, a = t.x, u = e, e = e.x), r.x < i.x ? (t = r, h = r.x, f = i, r = i.x) : (t = i, h = i.x, f = r, r = r.x)) : (e.y < t.y ? (o = e, a = e.y, u = t, e = t.y) : (o = t, a = t.y, u = e, e = e.y), r.y < i.y ? (t = r, h = r.y, f = i, r = i.y) : (t = i, h = i.y, f = r, r = r.y)), a <= h ? e < h ? [] : e == h ? s ? [] : [t] : e <= r ? [t, u] : [t, f] : a > r ? [] : a == r ? s ? [] : [o] : e <= r ? [o, u] : [o, f]))
			}

			function i(e, t, n, r) {
				var i = t.x - e.x,
					s = t.y - e.y;
				t = n.x - e.x, n = n.y - e.y;
				var o = r.x - e.x;
				return r = r.y - e.y, e = i * n - s * t, i = i * r - s * o, 1e-10 < Math.abs(e) ? (t = o * n - r * t, 0 < e ? 0 <= i && 0 <= t : 0 <= i || 0 <= t) : 0 < i
			}
			var s, o, u, a, f, l = {};
			u = e.concat(), s = 0;
			for (o = t.length; s < o; s++) Array.prototype.push.apply(u, t[s]);
			s = 0;
			for (o = u.length; s < o; s++) f = u[s].x + ":" + u[s].y, void 0 !== l[f] && console.log("Duplicate point", f), l[f] = s;
			s = function(e, t) {
				function n(e, t) {
					var n = u.length - 1,
						r = e - 1;
					0 > r && (r = n);
					var s = e + 1;
					return s > n && (s = 0), n = i(u[e], u[r], u[s], a[t]), n ? (n = a.length - 1, r = t - 1, 0 > r && (r = n), s = t + 1, s > n && (s = 0), (n = i(a[t], a[r], a[s], u[e])) ? !0 : !1) : !1
				}

				function s(e, t) {
					var n, i;
					for (n = 0; n < u.length; n++)
						if (i = n + 1, i %= u.length, i = r(e, t, u[n], u[i], !0), 0 < i.length) return !0;
					return !1
				}

				function o(e, n) {
					var i, s, o, u;
					for (i = 0; i < f.length; i++)
						for (s = t[f[i]], o = 0; o < s.length; o++)
							if (u = o + 1, u %= s.length, u = r(e, n, s[o], s[u], !0), 0 < u.length) return !0;
					return !1
				}
				var u = e.concat(),
					a, f = [],
					l, c, h, p, v, m = [],
					g, y, b, w = 0;
				for (l = t.length; w < l; w++) f.push(w);
				for (var E = 2 * f.length; 0 < f.length;) {
					E--;
					if (0 > E) {
						console.log("Infinite Loop! Holes left:" + f.length + ", Probably Hole outside Shape!");
						break
					}
					for (c = 0; c < u.length; c++) {
						h = u[c], l = -1;
						for (w = 0; w < f.length; w++)
							if (p = f[w], v = h.x + ":" + h.y + ":" + p, void 0 === m[v]) {
								a = t[p];
								for (g = 0; g < a.length; g++)
									if (p = a[g], n(c, g) && !s(h, p) && !o(h, p)) {
										l = g, f.splice(w, 1), p = u.slice(0, c + 1), g = u.slice(c), y = a.slice(l), b = a.slice(0, l + 1), u = p.concat(y).concat(b).concat(g);
										break
									} if (0 <= l) break;
								m[v] = !0
							} if (0 <= l) break
					}
				}
				return u
			}(e, t);
			var c = THREE.FontUtils.Triangulate(s, !1);
			s = 0;
			for (o = c.length; s < o; s++)
				for (a = c[s], u = 0; 3 > u; u++) f = a[u].x + ":" + a[u].y, f = l[f], void 0 !== f && (a[u] = f);
			return c.concat()
		},
		isClockWise: function(e) {
			return 0 > THREE.FontUtils.Triangulate.area(e)
		},
		b2p0: function(e, t) {
			var n = 1 - e;
			return n * n * t
		},
		b2p1: function(e, t) {
			return 2 * (1 - e) * e * t
		},
		b2p2: function(e, t) {
			return e * e * t
		},
		b2: function(e, t, n, r) {
			return this.b2p0(e, t) + this.b2p1(e, n) + this.b2p2(e, r)
		},
		b3p0: function(e, t) {
			var n = 1 - e;
			return n * n * n * t
		},
		b3p1: function(e, t) {
			var n = 1 - e;
			return 3 * n * n * e * t
		},
		b3p2: function(e, t) {
			return 3 * (1 - e) * e * e * t
		},
		b3p3: function(e, t) {
			return e * e * e * t
		},
		b3: function(e, t, n, r, i) {
			return this.b3p0(e, t) + this.b3p1(e, n) + this.b3p2(e, r) + this.b3p3(e, i)
		}
	}, THREE.LineCurve = function(e, t) {
		this.v1 = e, this.v2 = t
	}, THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.LineCurve.prototype.getPoint = function(e) {
		var t = this.v2.clone().sub(this.v1);
		return t.multiplyScalar(e).add(this.v1), t
	}, THREE.LineCurve.prototype.getPointAt = function(e) {
		return this.getPoint(e)
	}, THREE.LineCurve.prototype.getTangent = function(e) {
		return this.v2.clone().sub(this.v1).normalize()
	}, THREE.QuadraticBezierCurve = function(e, t, n) {
		this.v0 = e, this.v1 = t, this.v2 = n
	}, THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.QuadraticBezierCurve.prototype.getPoint = function(e) {
		var t;
		return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), new THREE.Vector2(t, e)
	}, THREE.QuadraticBezierCurve.prototype.getTangent = function(e) {
		var t;
		return t = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.x, this.v1.x, this.v2.x), e = THREE.Curve.Utils.tangentQuadraticBezier(e, this.v0.y, this.v1.y, this.v2.y), t = new THREE.Vector2(t, e), t.normalize(), t
	}, THREE.CubicBezierCurve = function(e, t, n, r) {
		this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
	}, THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype), THREE.CubicBezierCurve.prototype.getPoint = function(e) {
		var t;
		return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), new THREE.Vector2(t, e)
	}, THREE.CubicBezierCurve.prototype.getTangent = function(e) {
		var t;
		return t = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e = THREE.Curve.Utils.tangentCubicBezier(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t = new THREE.Vector2(t, e), t.normalize(), t
	}, THREE.SplineCurve = function(e) {
		this.points = void 0 == e ? [] : e
	}, THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype), THREE.SplineCurve.prototype.getPoint = function(e) {
		var t = new THREE.Vector2,
			n = [],
			r = this.points,
			i;
		return i = (r.length - 1) * e, e = Math.floor(i), i -= e, n[0] = 0 == e ? e : e - 1, n[1] = e, n[2] = e > r.length - 2 ? r.length - 1 : e + 1, n[3] = e > r.length - 3 ? r.length - 1 : e + 2, t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, i), t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, i), t
	}, THREE.EllipseCurve = function(e, t, n, r, i, s, o) {
		this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o
	}, THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype), THREE.EllipseCurve.prototype.getPoint = function(e) {
		var t;
		return t = this.aEndAngle - this.aStartAngle, 0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI), t = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t, e = this.aX + this.xRadius * Math.cos(t), t = this.aY + this.yRadius * Math.sin(t), new THREE.Vector2(e, t)
	}, THREE.ArcCurve = function(e, t, n, r, i, s) {
		THREE.EllipseCurve.call(this, e, t, n, n, r, i, s)
	}, THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype), THREE.LineCurve3 = THREE.Curve.create(function(e, t) {
		this.v1 = e, this.v2 = t
	}, function(e) {
		var t = new THREE.Vector3;
		return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
	}), THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(e, t, n) {
		this.v0 = e, this.v1 = t, this.v2 = n
	}, function(e) {
		var t, n;
		return t = THREE.Shape.Utils.b2(e, this.v0.x, this.v1.x, this.v2.x), n = THREE.Shape.Utils.b2(e, this.v0.y, this.v1.y, this.v2.y), e = THREE.Shape.Utils.b2(e, this.v0.z, this.v1.z, this.v2.z), new THREE.Vector3(t, n, e)
	}), THREE.CubicBezierCurve3 = THREE.Curve.create(function(e, t, n, r) {
		this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
	}, function(e) {
		var t, n;
		return t = THREE.Shape.Utils.b3(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), n = THREE.Shape.Utils.b3(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e = THREE.Shape.Utils.b3(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z), new THREE.Vector3(t, n, e)
	}), THREE.SplineCurve3 = THREE.Curve.create(function(e) {
		this.points = void 0 == e ? [] : e
	}, function(e) {
		var t = new THREE.Vector3,
			n = [],
			r = this.points,
			i;
		e *= r.length - 1, i = Math.floor(e), e -= i, n[0] = 0 == i ? i : i - 1, n[1] = i, n[2] = i > r.length - 2 ? r.length - 1 : i + 1, n[3] = i > r.length - 3 ? r.length - 1 : i + 2, i = r[n[0]];
		var s = r[n[1]],
			o = r[n[2]],
			n = r[n[3]];
		return t.x = THREE.Curve.Utils.interpolate(i.x, s.x, o.x, n.x, e), t.y = THREE.Curve.Utils.interpolate(i.y, s.y, o.y, n.y, e), t.z = THREE.Curve.Utils.interpolate(i.z, s.z, o.z, n.z, e), t
	}), THREE.ClosedSplineCurve3 = THREE.Curve.create(function(e) {
		this.points = void 0 == e ? [] : e
	}, function(e) {
		var t = new THREE.Vector3,
			n = [],
			r = this.points,
			i;
		return i = (r.length - 0) * e, e = Math.floor(i), i -= e, e += 0 < e ? 0 : (Math.floor(Math.abs(e) / r.length) + 1) * r.length, n[0] = (e - 1) % r.length, n[1] = e % r.length, n[2] = (e + 1) % r.length, n[3] = (e + 2) % r.length, t.x = THREE.Curve.Utils.interpolate(r[n[0]].x, r[n[1]].x, r[n[2]].x, r[n[3]].x, i), t.y = THREE.Curve.Utils.interpolate(r[n[0]].y, r[n[1]].y, r[n[2]].y, r[n[3]].y, i), t.z = THREE.Curve.Utils.interpolate(r[n[0]].z, r[n[1]].z, r[n[2]].z, r[n[3]].z, i), t
	}), THREE.AnimationHandler = function() {
		var e = [],
			t = {},
			n = {
				update: function(t) {
					for (var n = 0; n < e.length; n++) e[n].update(t)
				},
				addToUpdate: function(t) {
					-1 === e.indexOf(t) && e.push(t)
				},
				removeFromUpdate: function(t) {
					t = e.indexOf(t), -1 !== t && e.splice(t, 1)
				},
				add: function(e) {
					void 0 !== t[e.name] && console.log("THREE.AnimationHandler.add: Warning! " + e.name + " already exists in library. Overwriting."), t[e.name] = e;
					if (!0 !== e.initialized) {
						for (var n = 0; n < e.hierarchy.length; n++) {
							for (var r = 0; r < e.hierarchy[n].keys.length; r++)
								if (0 > e.hierarchy[n].keys[r].time && (e.hierarchy[n].keys[r].time = 0), void 0 !== e.hierarchy[n].keys[r].rot && !(e.hierarchy[n].keys[r].rot instanceof THREE.Quaternion)) {
									var i = e.hierarchy[n].keys[r].rot;
									e.hierarchy[n].keys[r].rot = new THREE.Quaternion(i[0], i[1], i[2], i[3])
								} if (e.hierarchy[n].keys.length && void 0 !== e.hierarchy[n].keys[0].morphTargets) {
								i = {};
								for (r = 0; r < e.hierarchy[n].keys.length; r++)
									for (var s = 0; s < e.hierarchy[n].keys[r].morphTargets.length; s++) {
										var o = e.hierarchy[n].keys[r].morphTargets[s];
										i[o] = -1
									}
								e.hierarchy[n].usedMorphTargets = i;
								for (r = 0; r < e.hierarchy[n].keys.length; r++) {
									var u = {};
									for (o in i) {
										for (s = 0; s < e.hierarchy[n].keys[r].morphTargets.length; s++)
											if (e.hierarchy[n].keys[r].morphTargets[s] === o) {
												u[o] = e.hierarchy[n].keys[r].morphTargetsInfluences[s];
												break
											} s === e.hierarchy[n].keys[r].morphTargets.length && (u[o] = 0)
									}
									e.hierarchy[n].keys[r].morphTargetsInfluences = u
								}
							}
							for (r = 1; r < e.hierarchy[n].keys.length; r++) e.hierarchy[n].keys[r].time === e.hierarchy[n].keys[r - 1].time && (e.hierarchy[n].keys.splice(r, 1), r--);
							for (r = 0; r < e.hierarchy[n].keys.length; r++) e.hierarchy[n].keys[r].index = r
						}
						e.initialized = !0
					}
				},
				get: function(e) {
					if ("string" == typeof e) return t[e] ? t[e] : (console.log("THREE.AnimationHandler.get: Couldn't find animation " + e), null)
				},
				parse: function(e) {
					var t = [];
					if (e instanceof THREE.SkinnedMesh)
						for (var n = 0; n < e.bones.length; n++) t.push(e.bones[n]);
					else r(e, t);
					return t
				}
			},
			r = function(e, t) {
				t.push(e);
				for (var n = 0; n < e.children.length; n++) r(e.children[n], t)
			};
		return n.LINEAR = 0, n.CATMULLROM = 1, n.CATMULLROM_FORWARD = 2, n
	}(), THREE.Animation = function(e, t) {
		this.root = e, this.data = THREE.AnimationHandler.get(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = 1, this.isPlaying = !1, this.loop = this.isPaused = !0, this.interpolationType = THREE.AnimationHandler.LINEAR
	}, THREE.Animation.prototype.play = function(e) {
		this.currentTime = void 0 !== e ? e : 0, !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0)), this.isPaused = !1, THREE.AnimationHandler.addToUpdate(this)
	}, THREE.Animation.prototype.pause = function() {
		!0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), this.isPaused = !this.isPaused
	}, THREE.Animation.prototype.stop = function() {
		this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.removeFromUpdate(this)
	}, THREE.Animation.prototype.reset = function() {
		for (var e = 0, t = this.hierarchy.length; e < t; e++) {
			var n = this.hierarchy[e];
			n.matrixAutoUpdate = !0, void 0 === n.animationCache && (n.animationCache = {}, n.animationCache.prevKey = {
				pos: 0,
				rot: 0,
				scl: 0
			}, n.animationCache.nextKey = {
				pos: 0,
				rot: 0,
				scl: 0
			}, n.animationCache.originalMatrix = n instanceof THREE.Bone ? n.skinMatrix : n.matrix);
			var r = n.animationCache.prevKey,
				n = n.animationCache.nextKey;
			r.pos = this.data.hierarchy[e].keys[0], r.rot = this.data.hierarchy[e].keys[0], r.scl = this.data.hierarchy[e].keys[0], n.pos = this.getNextKeyWith("pos", e, 1), n.rot = this.getNextKeyWith("rot", e, 1), n.scl = this.getNextKeyWith("scl", e, 1)
		}
	}, THREE.Animation.prototype.update = function() {
		var e = [],
			t = new THREE.Vector3,
			n = function(e, t) {
				var n = [],
					i = [],
					s, o, u, a, f, l;
				return s = (e.length - 1) * t, o = Math.floor(s), s -= o, n[0] = 0 === o ? o : o - 1, n[1] = o, n[2] = o > e.length - 2 ? o : o + 1, n[3] = o > e.length - 3 ? o : o + 2, o = e[n[0]], a = e[n[1]], f = e[n[2]], l = e[n[3]], n = s * s, u = s * n, i[0] = r(o[0], a[0], f[0], l[0], s, n, u), i[1] = r(o[1], a[1], f[1], l[1], s, n, u), i[2] = r(o[2], a[2], f[2], l[2], s, n, u), i
			},
			r = function(e, t, n, r, i, s, o) {
				return e = .5 * (n - e), r = .5 * (r - t), (2 * (t - n) + e + r) * o + (-3 * (t - n) - 2 * e - r) * s + e * i + t
			};
		return function(r) {
			if (!1 !== this.isPlaying) {
				this.currentTime += r * this.timeScale;
				var i;
				r = ["pos", "rot", "scl"];
				var s = this.data.length;
				if (!0 === this.loop && this.currentTime > s) this.currentTime %= s, this.reset();
				else if (!1 === this.loop && this.currentTime > s) {
					this.stop();
					return
				}
				this.currentTime = Math.min(this.currentTime, s);
				for (var s = 0, o = this.hierarchy.length; s < o; s++)
					for (var u = this.hierarchy[s], f = u.animationCache, l = 0; 3 > l; l++) {
						i = r[l];
						var h = f.prevKey[i],
							p = f.nextKey[i];
						if (p.time <= this.currentTime) {
							h = this.data.hierarchy[s].keys[0];
							for (p = this.getNextKeyWith(i, s, 1); p.time < this.currentTime && p.index > h.index;) h = p, p = this.getNextKeyWith(i, s, p.index + 1);
							f.prevKey[i] = h, f.nextKey[i] = p
						}
						u.matrixAutoUpdate = !0, u.matrixWorldNeedsUpdate = !0;
						var d = (this.currentTime - h.time) / (p.time - h.time),
							v = h[i],
							m = p[i];
						0 > d && (d = 0), 1 < d && (d = 1);
						if ("pos" === i) {
							if (i = u.position, this.interpolationType === THREE.AnimationHandler.LINEAR) i.x = v[0] + (m[0] - v[0]) * d, i.y = v[1] + (m[1] - v[1]) * d, i.z = v[2] + (m[2] - v[2]) * d;
							else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) e[0] = this.getPrevKeyWith("pos", s, h.index - 1).pos, e[1] = v, e[2] = m, e[3] = this.getNextKeyWith("pos", s, p.index + 1).pos, d = .33 * d + .33, h = n(e, d), i.x = h[0], i.y = h[1], i.z = h[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (d = n(e, 1.01 * d), t.set(d[0], d[1], d[2]), t.sub(i), t.y = 0, t.normalize(), i = Math.atan2(t.x, t.z), u.rotation.set(0, i, 0))
						} else "rot" === i ? THREE.Quaternion.slerp(v, m, u.quaternion, d) : "scl" === i && (i = u.scale, i.x = v[0] + (m[0] - v[0]) * d, i.y = v[1] + (m[1] - v[1]) * d, i.z = v[2] + (m[2] - v[2]) * d)
					}
			}
		}
	}(), THREE.Animation.prototype.getNextKeyWith = function(e, t, n) {
		var r = this.data.hierarchy[t].keys;
		for (n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? n < r.length - 1 ? n : r.length - 1 : n % r.length; n < r.length; n++)
			if (void 0 !== r[n][e]) return r[n];
		return this.data.hierarchy[t].keys[0]
	}, THREE.Animation.prototype.getPrevKeyWith = function(e, t, n) {
		var r = this.data.hierarchy[t].keys;
		for (n = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < n ? n : 0 : 0 <= n ? n : n + r.length; 0 <= n; n--)
			if (void 0 !== r[n][e]) return r[n];
		return this.data.hierarchy[t].keys[r.length - 1]
	}, THREE.KeyFrameAnimation = function(e, t) {
		this.root = e, this.data = THREE.AnimationHandler.get(t), this.hierarchy = THREE.AnimationHandler.parse(e), this.currentTime = 0, this.timeScale = .001, this.isPlaying = !1, this.loop = this.isPaused = !0;
		for (var n = 0, r = this.hierarchy.length; n < r; n++) {
			var i = this.data.hierarchy[n].sids,
				s = this.hierarchy[n];
			if (this.data.hierarchy[n].keys.length && i) {
				for (var o = 0; o < i.length; o++) {
					var u = i[o],
						a = this.getNextKeyWith(u, n, 0);
					a && a.apply(u)
				}
				s.matrixAutoUpdate = !1, this.data.hierarchy[n].node.updateMatrix(), s.matrixWorldNeedsUpdate = !0
			}
		}
	}, THREE.KeyFrameAnimation.prototype.play = function(e) {
		this.currentTime = void 0 !== e ? e : 0;
		if (!1 === this.isPlaying) {
			this.isPlaying = !0;
			var t = this.hierarchy.length,
				n, r;
			for (e = 0; e < t; e++) n = this.hierarchy[e], r = this.data.hierarchy[e], void 0 === r.animationCache && (r.animationCache = {}, r.animationCache.prevKey = null, r.animationCache.nextKey = null, r.animationCache.originalMatrix = n instanceof THREE.Bone ? n.skinMatrix : n.matrix), n = this.data.hierarchy[e].keys, n.length && (r.animationCache.prevKey = n[0], r.animationCache.nextKey = n[1], this.startTime = Math.min(n[0].time, this.startTime), this.endTime = Math.max(n[n.length - 1].time, this.endTime));
			this.update(0)
		}
		this.isPaused = !1, THREE.AnimationHandler.addToUpdate(this)
	}, THREE.KeyFrameAnimation.prototype.pause = function() {
		this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this), this.isPaused = !this.isPaused
	}, THREE.KeyFrameAnimation.prototype.stop = function() {
		this.isPaused = this.isPlaying = !1, THREE.AnimationHandler.removeFromUpdate(this);
		for (var e = 0; e < this.data.hierarchy.length; e++) {
			var t = this.hierarchy[e],
				n = this.data.hierarchy[e];
			if (void 0 !== n.animationCache) {
				var r = n.animationCache.originalMatrix;
				t instanceof THREE.Bone ? (r.copy(t.skinMatrix), t.skinMatrix = r) : (r.copy(t.matrix), t.matrix = r), delete n.animationCache
			}
		}
	}, THREE.KeyFrameAnimation.prototype.update = function(e) {
		if (!1 !== this.isPlaying) {
			this.currentTime += e * this.timeScale, e = this.data.length, !0 === this.loop && this.currentTime > e && (this.currentTime %= e), this.currentTime = Math.min(this.currentTime, e), e = 0;
			for (var t = this.hierarchy.length; e < t; e++) {
				var n = this.hierarchy[e],
					r = this.data.hierarchy[e],
					i = r.keys,
					r = r.animationCache;
				if (i.length) {
					var s = r.prevKey,
						o = r.nextKey;
					if (o.time <= this.currentTime) {
						for (; o.time < this.currentTime && o.index > s.index;) s = o, o = i[s.index + 1];
						r.prevKey = s, r.nextKey = o
					}
					o.time >= this.currentTime ? s.interpolate(o, this.currentTime) : s.interpolate(o, o.time), this.data.hierarchy[e].node.updateMatrix(), n.matrixWorldNeedsUpdate = !0
				}
			}
		}
	}, THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(e, t, n) {
		t = this.data.hierarchy[t].keys;
		for (n %= t.length; n < t.length; n++)
			if (t[n].hasTarget(e)) return t[n];
		return t[0]
	}, THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(e, t, n) {
		t = this.data.hierarchy[t].keys;
		for (n = 0 <= n ? n : n + t.length; 0 <= n; n--)
			if (t[n].hasTarget(e)) return t[n];
		return t[t.length - 1]
	}, THREE.MorphAnimation = function(e) {
		this.mesh = e, this.frames = e.morphTargetInfluences.length, this.currentTime = 0, this.duration = 1e3, this.loop = !0, this.isPlaying = !1
	}, THREE.MorphAnimation.prototype = {
		play: function() {
			this.isPlaying = !0
		},
		pause: function() {
			this.isPlaying = !1
		},
		update: function() {
			var e = 0,
				t = 0;
			return function(n) {
				if (!1 !== this.isPlaying) {
					this.currentTime += n, !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration), this.currentTime = Math.min(this.currentTime, this.duration), n = this.duration / this.frames;
					var r = Math.floor(this.currentTime / n);
					r != t && (this.mesh.morphTargetInfluences[e] = 0, this.mesh.morphTargetInfluences[t] = 1, this.mesh.morphTargetInfluences[r] = 0, e = t, t = r), this.mesh.morphTargetInfluences[r] = this.currentTime % n / n, this.mesh.morphTargetInfluences[e] = 1 - this.mesh.morphTargetInfluences[r]
				}
			}
		}()
	}, THREE.CubeCamera = function(e, t, n) {
		THREE.Object3D.call(this);
		var r = new THREE.PerspectiveCamera(90, 1, e, t);
		r.up.set(0, -1, 0), r.lookAt(new THREE.Vector3(1, 0, 0)), this.add(r);
		var i = new THREE.PerspectiveCamera(90, 1, e, t);
		i.up.set(0, -1, 0), i.lookAt(new THREE.Vector3(-1, 0, 0)), this.add(i);
		var s = new THREE.PerspectiveCamera(90, 1, e, t);
		s.up.set(0, 0, 1), s.lookAt(new THREE.Vector3(0, 1, 0)), this.add(s);
		var o = new THREE.PerspectiveCamera(90, 1, e, t);
		o.up.set(0, 0, -1), o.lookAt(new THREE.Vector3(0, -1, 0)), this.add(o);
		var u = new THREE.PerspectiveCamera(90, 1, e, t);
		u.up.set(0, -1, 0), u.lookAt(new THREE.Vector3(0, 0, 1)), this.add(u);
		var a = new THREE.PerspectiveCamera(90, 1, e, t);
		a.up.set(0, -1, 0), a.lookAt(new THREE.Vector3(0, 0, -1)), this.add(a), this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, {
			format: THREE.RGBFormat,
			magFilter: THREE.LinearFilter,
			minFilter: THREE.LinearFilter
		}), this.updateCubeMap = function(e, t) {
			var n = this.renderTarget,
				l = n.generateMipmaps;
			n.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, r, n), n.activeCubeFace = 1, e.render(t, i, n), n.activeCubeFace = 2, e.render(t, s, n), n.activeCubeFace = 3, e.render(t, o, n), n.activeCubeFace = 4, e.render(t, u, n), n.generateMipmaps = l, n.activeCubeFace = 5, e.render(t, a, n)
		}
	}, THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype), THREE.CombinedCamera = function(e, t, n, r, i, s, o) {
		THREE.Camera.call(this), this.fov = n, this.left = -e / 2, this.right = e / 2, this.top = t / 2, this.bottom = -t / 2, this.cameraO = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, s, o), this.cameraP = new THREE.PerspectiveCamera(n, e / t, r, i), this.zoom = 1, this.toPerspective()
	}, THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype), THREE.CombinedCamera.prototype.toPerspective = function() {
		this.near = this.cameraP.near, this.far = this.cameraP.far, this.cameraP.fov = this.fov / this.zoom, this.cameraP.updateProjectionMatrix(), this.projectionMatrix = this.cameraP.projectionMatrix, this.inPerspectiveMode = !0, this.inOrthographicMode = !1
	}, THREE.CombinedCamera.prototype.toOrthographic = function() {
		var e = this.cameraP.aspect,
			t = (this.cameraP.near + this.cameraP.far) / 2,
			t = Math.tan(this.fov / 2) * t,
			e = 2 * t * e / 2,
			t = t / this.zoom,
			e = e / this.zoom;
		this.cameraO.left = -e, this.cameraO.right = e, this.cameraO.top = t, this.cameraO.bottom = -t, this.cameraO.updateProjectionMatrix(), this.near = this.cameraO.near, this.far = this.cameraO.far, this.projectionMatrix = this.cameraO.projectionMatrix, this.inPerspectiveMode = !1, this.inOrthographicMode = !0
	}, THREE.CombinedCamera.prototype.setSize = function(e, t) {
		this.cameraP.aspect = e / t, this.left = -e / 2, this.right = e / 2, this.top = t / 2, this.bottom = -t / 2
	}, THREE.CombinedCamera.prototype.setFov = function(e) {
		this.fov = e, this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
	}, THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {
		this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic())
	}, THREE.CombinedCamera.prototype.setLens = function(e, t) {
		void 0 === t && (t = 24);
		var n = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e)));
		return this.setFov(n), n
	}, THREE.CombinedCamera.prototype.setZoom = function(e) {
		this.zoom = e, this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
	}, THREE.CombinedCamera.prototype.toFrontView = function() {
		this.rotation.x = 0, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.CombinedCamera.prototype.toBackView = function() {
		this.rotation.x = 0, this.rotation.y = Math.PI, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.CombinedCamera.prototype.toLeftView = function() {
		this.rotation.x = 0, this.rotation.y = -Math.PI / 2, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.CombinedCamera.prototype.toRightView = function() {
		this.rotation.x = 0, this.rotation.y = Math.PI / 2, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.CombinedCamera.prototype.toTopView = function() {
		this.rotation.x = -Math.PI / 2, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.CombinedCamera.prototype.toBottomView = function() {
		this.rotation.x = Math.PI / 2, this.rotation.y = 0, this.rotation.z = 0, this.rotationAutoUpdate = !1
	}, THREE.BoxGeometry = function(e, t, n, r, i, s) {
		function o(e, t, n, r, i, s, o, a) {
			var f, l = u.widthSegments,
				c = u.heightSegments,
				p = i / 2,
				d = s / 2,
				v = u.vertices.length;
			if ("x" === e && "y" === t || "y" === e && "x" === t) f = "z";
			else if ("x" === e && "z" === t || "z" === e && "x" === t) f = "y", c = u.depthSegments;
			else if ("z" === e && "y" === t || "y" === e && "z" === t) f = "x", l = u.depthSegments;
			var m = l + 1,
				g = c + 1,
				y = i / l,
				b = s / c,
				w = new THREE.Vector3;
			w[f] = 0 < o ? 1 : -1;
			for (i = 0; i < g; i++)
				for (s = 0; s < m; s++) {
					var E = new THREE.Vector3;
					E[e] = (s * y - p) * n, E[t] = (i * b - d) * r, E[f] = o, u.vertices.push(E)
				}
			for (i = 0; i < c; i++)
				for (s = 0; s < l; s++) d = s + m * i, e = s + m * (i + 1), t = s + 1 + m * (i + 1), n = s + 1 + m * i, r = new THREE.Vector2(s / l, 1 - i / c), o = new THREE.Vector2(s / l, 1 - (i + 1) / c), f = new THREE.Vector2((s + 1) / l, 1 - (i + 1) / c), p = new THREE.Vector2((s + 1) / l, 1 - i / c), d = new THREE.Face3(d + v, e + v, n + v), d.normal.copy(w), d.vertexNormals.push(w.clone(), w.clone(), w.clone()), d.materialIndex = a, u.faces.push(d), u.faceVertexUvs[0].push([r, o, p]), d = new THREE.Face3(e + v, t + v, n + v), d.normal.copy(w), d.vertexNormals.push(w.clone(), w.clone(), w.clone()), d.materialIndex = a, u.faces.push(d), u.faceVertexUvs[0].push([o.clone(), f, p.clone()])
		}
		THREE.Geometry.call(this);
		var u = this;
		this.width = e, this.height = t, this.depth = n, this.widthSegments = r || 1, this.heightSegments = i || 1, this.depthSegments = s || 1, e = this.width / 2, t = this.height / 2, n = this.depth / 2, o("z", "y", -1, -1, this.depth, this.height, e, 0), o("z", "y", 1, -1, this.depth, this.height, -e, 1), o("x", "z", 1, 1, this.width, this.depth, t, 2), o("x", "z", 1, -1, this.width, this.depth, -t, 3), o("x", "y", 1, -1, this.width, this.height, n, 4), o("x", "y", -1, -1, this.width, this.height, -n, 5), this.computeCentroids(), this.mergeVertices()
	}, THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CircleGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), this.radius = e = e || 50, this.segments = t = void 0 !== t ? Math.max(3, t) : 8, this.thetaStart = n = void 0 !== n ? n : 0, this.thetaLength = r = void 0 !== r ? r : 2 * Math.PI;
		var i, s = [];
		i = new THREE.Vector3;
		var o = new THREE.Vector2(.5, .5);
		this.vertices.push(i), s.push(o);
		for (i = 0; i <= t; i++) {
			var u = new THREE.Vector3,
				a = n + i / t * r;
			u.x = e * Math.cos(a), u.y = e * Math.sin(a), this.vertices.push(u), s.push(new THREE.Vector2((u.x / e + 1) / 2, (u.y / e + 1) / 2))
		}
		n = new THREE.Vector3(0, 0, 1);
		for (i = 1; i <= t; i++) this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()])), this.faceVertexUvs[0].push([s[i].clone(), s[i + 1].clone(), o.clone()]);
		this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
	}, THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.CubeGeometry = THREE.BoxGeometry, THREE.CylinderGeometry = function(e, t, n, r, i, s) {
		THREE.Geometry.call(this), this.radiusTop = e = void 0 !== e ? e : 20, this.radiusBottom = t = void 0 !== t ? t : 20, this.height = n = void 0 !== n ? n : 100, this.radialSegments = r = r || 8, this.heightSegments = i = i || 1, this.openEnded = s = void 0 !== s ? s : !1;
		var o = n / 2,
			u, a, f = [],
			l = [];
		for (a = 0; a <= i; a++) {
			var c = [],
				h = [],
				p = a / i,
				d = p * (t - e) + e;
			for (u = 0; u <= r; u++) {
				var v = u / r,
					m = new THREE.Vector3;
				m.x = d * Math.sin(v * Math.PI * 2), m.y = -p * n + o, m.z = d * Math.cos(v * Math.PI * 2), this.vertices.push(m), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(v, 1 - p))
			}
			f.push(c), l.push(h)
		}
		n = (t - e) / n;
		for (u = 0; u < r; u++)
			for (0 !== e ? (c = this.vertices[f[0][u]].clone(), h = this.vertices[f[0][u + 1]].clone()) : (c = this.vertices[f[1][u]].clone(), h = this.vertices[f[1][u + 1]].clone()), c.setY(Math.sqrt(c.x * c.x + c.z * c.z) * n).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * n).normalize(), a = 0; a < i; a++) {
				var p = f[a][u],
					d = f[a + 1][u],
					v = f[a + 1][u + 1],
					m = f[a][u + 1],
					g = c.clone(),
					y = c.clone(),
					b = h.clone(),
					w = h.clone(),
					E = l[a][u].clone(),
					S = l[a + 1][u].clone(),
					x = l[a + 1][u + 1].clone(),
					T = l[a][u + 1].clone();
				this.faces.push(new THREE.Face3(p, d, m, [g, y, w])), this.faceVertexUvs[0].push([E, S, T]), this.faces.push(new THREE.Face3(d, v, m, [y.clone(), b, w.clone()])), this.faceVertexUvs[0].push([S.clone(), x, T.clone()])
			}
		if (!1 === s && 0 < e)
			for (this.vertices.push(new THREE.Vector3(0, o, 0)), u = 0; u < r; u++) p = f[0][u], d = f[0][u + 1], v = this.vertices.length - 1, g = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), b = new THREE.Vector3(0, 1, 0), E = l[0][u].clone(), S = l[0][u + 1].clone(), x = new THREE.Vector2(S.x, 0), this.faces.push(new THREE.Face3(p, d, v, [g, y, b])), this.faceVertexUvs[0].push([E, S, x]);
		if (!1 === s && 0 < t)
			for (this.vertices.push(new THREE.Vector3(0, -o, 0)), u = 0; u < r; u++) p = f[a][u + 1], d = f[a][u], v = this.vertices.length - 1, g = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), b = new THREE.Vector3(0, -1, 0), E = l[a][u + 1].clone(), S = l[a][u].clone(), x = new THREE.Vector2(S.x, 1), this.faces.push(new THREE.Face3(p, d, v, [g, y, b])), this.faceVertexUvs[0].push([E, S, x]);
		this.computeCentroids(), this.computeFaceNormals()
	}, THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry = function(e, t) {
		"undefined" != typeof e && (THREE.Geometry.call(this), e = e instanceof Array ? e : [e], this.shapebb = e[e.length - 1].getBoundingBox(), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals())
	}, THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
		for (var n = e.length, r = 0; r < n; r++) this.addShape(e[r], t)
	}, THREE.ExtrudeGeometry.prototype.addShape = function(e, t) {
		function n(e, t, n) {
			return t || console.log("die"), t.clone().multiplyScalar(n).add(e)
		}

		function r(e, t, n) {
			var r = THREE.Math.sign,
				i = 1,
				i = e.x - t.x,
				s = e.y - t.y,
				o = n.x - e.x,
				u = n.y - e.y,
				a = i * i + s * s;
			if (1e-10 < Math.abs(i * u - s * o)) {
				var f = Math.sqrt(a),
					r = Math.sqrt(o * o + u * u),
					a = t.x - s / f;
				t = t.y + i / f, o = ((n.x - u / r - a) * u - (n.y + o / r - t) * o) / (i * u - s * o), n = a + i * o - e.x, e = t + s * o - e.y, i = n * n + e * e;
				if (2 >= i) return new THREE.Vector2(n, e);
				i = Math.sqrt(i / 2)
			} else e = !1, 1e-10 < i ? 1e-10 < o && (e = !0) : -1e-10 > i ? -1e-10 > o && (e = !0) : r(s) == r(u) && (e = !0), e ? (n = -s, e = i, i = Math.sqrt(a)) : (n = i, e = s, i = Math.sqrt(a / 2));
			return new THREE.Vector2(n / i, e / i)
		}

		function i(n, r) {
			var i, s;
			for (q = n.length; 0 <= --q;) {
				i = q, s = q - 1, 0 > s && (s = n.length - 1);
				for (var o = 0, u = p + 2 * l, o = 0; o < u; o++) {
					var a = j * o,
						f = j * (o + 1),
						c = r + i + a,
						a = r + s + a,
						h = r + s + f,
						f = r + i + f,
						d = n,
						v = o,
						m = u,
						g = i,
						w = s,
						c = c + L,
						a = a + L,
						h = h + L,
						f = f + L;
					k.faces.push(new THREE.Face3(c, a, f, null, null, y)), k.faces.push(new THREE.Face3(a, h, f, null, null, y)), c = b.generateSideWallUV(k, e, d, t, c, a, h, f, v, m, g, w), k.faceVertexUvs[0].push([c[0], c[1], c[3]]), k.faceVertexUvs[0].push([c[1], c[2], c[3]])
				}
			}
		}

		function s(e, t, n) {
			k.vertices.push(new THREE.Vector3(e, t, n))
		}

		function o(n, r, i, s) {
			n += L, r += L, i += L, k.faces.push(new THREE.Face3(n, r, i, null, null, g)), n = s ? b.generateBottomUV(k, e, t, n, r, i) : b.generateTopUV(k, e, t, n, r, i), k.faceVertexUvs[0].push(n)
		}
		var u = void 0 !== t.amount ? t.amount : 100,
			a = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
			f = void 0 !== t.bevelSize ? t.bevelSize : a - 2,
			l = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
			c = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
			h = void 0 !== t.curveSegments ? t.curveSegments : 12,
			p = void 0 !== t.steps ? t.steps : 1,
			d = t.extrudePath,
			v, m = !1,
			g = t.material,
			y = t.extrudeMaterial,
			b = void 0 !== t.UVGenerator ? t.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
			w, E, S, x;
		d && (v = d.getSpacedPoints(p), m = !0, c = !1, w = void 0 !== t.frames ? t.frames : new THREE.TubeGeometry.FrenetFrames(d, p, !1), E = new THREE.Vector3, S = new THREE.Vector3, x = new THREE.Vector3), c || (f = a = l = 0);
		var T, N, C, k = this,
			L = this.vertices.length,
			d = e.extractPoints(h),
			h = d.shape,
			A = d.holes;
		if (d = !THREE.Shape.Utils.isClockWise(h)) {
			h = h.reverse(), N = 0;
			for (C = A.length; N < C; N++) T = A[N], THREE.Shape.Utils.isClockWise(T) && (A[N] = T.reverse());
			d = !1
		}
		var O = THREE.Shape.Utils.triangulateShape(h, A),
			M = h;
		N = 0;
		for (C = A.length; N < C; N++) T = A[N], h = h.concat(T);
		var _, D, P, H, B, j = h.length,
			F, I = O.length,
			d = [],
			q = 0;
		P = M.length, _ = P - 1;
		for (D = q + 1; q < P; q++, _++, D++) _ === P && (_ = 0), D === P && (D = 0), d[q] = r(M[q], M[_], M[D]);
		var R = [],
			U, z = d.concat();
		N = 0;
		for (C = A.length; N < C; N++) {
			T = A[N], U = [], q = 0, P = T.length, _ = P - 1;
			for (D = q + 1; q < P; q++, _++, D++) _ === P && (_ = 0), D === P && (D = 0), U[q] = r(T[q], T[_], T[D]);
			R.push(U), z = z.concat(U)
		}
		for (_ = 0; _ < l; _++) {
			P = _ / l, H = a * (1 - P), D = f * Math.sin(P * Math.PI / 2), q = 0;
			for (P = M.length; q < P; q++) B = n(M[q], d[q], D), s(B.x, B.y, -H);
			N = 0;
			for (C = A.length; N < C; N++)
				for (T = A[N], U = R[N], q = 0, P = T.length; q < P; q++) B = n(T[q], U[q], D), s(B.x, B.y, -H)
		}
		D = f;
		for (q = 0; q < j; q++) B = c ? n(h[q], z[q], D) : h[q], m ? (S.copy(w.normals[0]).multiplyScalar(B.x), E.copy(w.binormals[0]).multiplyScalar(B.y), x.copy(v[0]).add(S).add(E), s(x.x, x.y, x.z)) : s(B.x, B.y, 0);
		for (P = 1; P <= p; P++)
			for (q = 0; q < j; q++) B = c ? n(h[q], z[q], D) : h[q], m ? (S.copy(w.normals[P]).multiplyScalar(B.x), E.copy(w.binormals[P]).multiplyScalar(B.y), x.copy(v[P]).add(S).add(E), s(x.x, x.y, x.z)) : s(B.x, B.y, u / p * P);
		for (_ = l - 1; 0 <= _; _--) {
			P = _ / l, H = a * (1 - P), D = f * Math.sin(P * Math.PI / 2), q = 0;
			for (P = M.length; q < P; q++) B = n(M[q], d[q], D), s(B.x, B.y, u + H);
			N = 0;
			for (C = A.length; N < C; N++)
				for (T = A[N], U = R[N], q = 0, P = T.length; q < P; q++) B = n(T[q], U[q], D), m ? s(B.x, B.y + v[p - 1].y, v[p - 1].x + H) : s(B.x, B.y, u + H)
		}(function() {
			if (c) {
				var e;
				e = 0 * j;
				for (q = 0; q < I; q++) F = O[q], o(F[2] + e, F[1] + e, F[0] + e, !0);
				e = p + 2 * l, e *= j;
				for (q = 0; q < I; q++) F = O[q], o(F[0] + e, F[1] + e, F[2] + e, !1)
			} else {
				for (q = 0; q < I; q++) F = O[q], o(F[2], F[1], F[0], !0);
				for (q = 0; q < I; q++) F = O[q], o(F[0] + j * p, F[1] + j * p, F[2] + j * p, !1)
			}
		})(),
		function() {
			var e = 0;
			i(M, e), e += M.length, N = 0;
			for (C = A.length; N < C; N++) T = A[N], i(T, e), e += T.length
		}()
	}, THREE.ExtrudeGeometry.WorldUVGenerator = {
		generateTopUV: function(e, t, n, r, i, s) {
			return t = e.vertices[i].x, i = e.vertices[i].y, n = e.vertices[s].x, s = e.vertices[s].y, [new THREE.Vector2(e.vertices[r].x, e.vertices[r].y), new THREE.Vector2(t, i), new THREE.Vector2(n, s)]
		},
		generateBottomUV: function(e, t, n, r, i, s) {
			return this.generateTopUV(e, t, n, r, i, s)
		},
		generateSideWallUV: function(e, t, n, r, i, s, o, u, a, f, l, c) {
			t = e.vertices[i].x, n = e.vertices[i].y, i = e.vertices[i].z, r = e.vertices[s].x, a = e.vertices[s].y, s = e.vertices[s].z, f = e.vertices[o].x, l = e.vertices[o].y, o = e.vertices[o].z, c = e.vertices[u].x;
			var h = e.vertices[u].y;
			return e = e.vertices[u].z, .01 > Math.abs(n - a) ? [new THREE.Vector2(t, 1 - i), new THREE.Vector2(r, 1 - s), new THREE.Vector2(f, 1 - o), new THREE.Vector2(c, 1 - e)] : [new THREE.Vector2(n, 1 - i), new THREE.Vector2(a, 1 - s), new THREE.Vector2(l, 1 - o), new THREE.Vector2(h, 1 - e)]
		}
	}, THREE.ExtrudeGeometry.__v1 = new THREE.Vector2, THREE.ExtrudeGeometry.__v2 = new THREE.Vector2, THREE.ExtrudeGeometry.__v3 = new THREE.Vector2, THREE.ExtrudeGeometry.__v4 = new THREE.Vector2, THREE.ExtrudeGeometry.__v5 = new THREE.Vector2, THREE.ExtrudeGeometry.__v6 = new THREE.Vector2, THREE.ShapeGeometry = function(e, t) {
		THREE.Geometry.call(this), 0 == e instanceof Array && (e = [e]), this.shapebb = e[e.length - 1].getBoundingBox(), this.addShapeList(e, t), this.computeCentroids(), this.computeFaceNormals()
	}, THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ShapeGeometry.prototype.addShapeList = function(e, t) {
		for (var n = 0, r = e.length; n < r; n++) this.addShape(e[n], t);
		return this
	}, THREE.ShapeGeometry.prototype.addShape = function(e, t) {
		void 0 === t && (t = {});
		var n = t.material,
			r = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
			i, s, o, u = this.vertices.length;
		i = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments : 12);
		var a = i.shape,
			f = i.holes;
		if (!THREE.Shape.Utils.isClockWise(a))
			for (a = a.reverse(), i = 0, s = f.length; i < s; i++) o = f[i], THREE.Shape.Utils.isClockWise(o) && (f[i] = o.reverse());
		var l = THREE.Shape.Utils.triangulateShape(a, f);
		i = 0;
		for (s = f.length; i < s; i++) o = f[i], a = a.concat(o);
		f = a.length, s = l.length;
		for (i = 0; i < f; i++) o = a[i], this.vertices.push(new THREE.Vector3(o.x, o.y, 0));
		for (i = 0; i < s; i++) f = l[i], a = f[0] + u, o = f[1] + u, f = f[2] + u, this.faces.push(new THREE.Face3(a, o, f, null, null, n)), this.faceVertexUvs[0].push(r.generateBottomUV(this, e, t, a, o, f))
	}, THREE.LatheGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), t = t || 12, n = n || 0, r = r || 2 * Math.PI;
		for (var i = 1 / (e.length - 1), s = 1 / t, o = 0, u = t; o <= u; o++)
			for (var a = n + o * s * r, f = Math.cos(a), l = Math.sin(a), a = 0, c = e.length; a < c; a++) {
				var h = e[a],
					p = new THREE.Vector3;
				p.x = f * h.x - l * h.y, p.y = l * h.x + f * h.y, p.z = h.z, this.vertices.push(p)
			}
		n = e.length, o = 0;
		for (u = t; o < u; o++)
			for (a = 0, c = e.length - 1; a < c; a++) {
				t = l = a + n * o, r = l + n;
				var f = l + 1 + n,
					l = l + 1,
					h = o * s,
					p = a * i,
					d = h + s,
					v = p + i;
				this.faces.push(new THREE.Face3(t, r, l)), this.faceVertexUvs[0].push([new THREE.Vector2(h, p), new THREE.Vector2(d, p), new THREE.Vector2(h, v)]), this.faces.push(new THREE.Face3(r, f, l)), this.faceVertexUvs[0].push([new THREE.Vector2(d, p), new THREE.Vector2(d, v), new THREE.Vector2(h, v)])
			}
		this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.PlaneGeometry = function(e, t, n, r) {
		THREE.Geometry.call(this), this.width = e, this.height = t, this.widthSegments = n || 1, this.heightSegments = r || 1;
		var i = e / 2,
			s = t / 2;
		n = this.widthSegments, r = this.heightSegments;
		var o = n + 1,
			u = r + 1,
			a = this.width / n,
			f = this.height / r,
			l = new THREE.Vector3(0, 0, 1);
		for (e = 0; e < u; e++)
			for (t = 0; t < o; t++) this.vertices.push(new THREE.Vector3(t * a - i, -(e * f - s), 0));
		for (e = 0; e < r; e++)
			for (t = 0; t < n; t++) {
				var c = t + o * e,
					i = t + o * (e + 1),
					s = t + 1 + o * (e + 1),
					u = t + 1 + o * e,
					a = new THREE.Vector2(t / n, 1 - e / r),
					f = new THREE.Vector2(t / n, 1 - (e + 1) / r),
					h = new THREE.Vector2((t + 1) / n, 1 - (e + 1) / r),
					p = new THREE.Vector2((t + 1) / n, 1 - e / r),
					c = new THREE.Face3(c, i, u);
				c.normal.copy(l), c.vertexNormals.push(l.clone(), l.clone(), l.clone()), this.faces.push(c), this.faceVertexUvs[0].push([a, f, p]), c = new THREE.Face3(i, s, u), c.normal.copy(l), c.vertexNormals.push(l.clone(), l.clone(), l.clone()), this.faces.push(c), this.faceVertexUvs[0].push([f.clone(), h, p.clone()])
			}
		this.computeCentroids()
	}, THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.RingGeometry = function(e, t, n, r, i, s) {
		THREE.Geometry.call(this), e = e || 0, t = t || 50, i = void 0 !== i ? i : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(3, r) : 8;
		var o, u = [],
			a = e,
			f = (t - e) / r;
		for (e = 0; e <= r; e++) {
			for (o = 0; o <= n; o++) {
				var l = new THREE.Vector3,
					c = i + o / n * s;
				l.x = a * Math.cos(c), l.y = a * Math.sin(c), this.vertices.push(l), u.push(new THREE.Vector2((l.x / t + 1) / 2, (l.y / t + 1) / 2))
			}
			a += f
		}
		t = new THREE.Vector3(0, 0, 1);
		for (e = 0; e < r; e++)
			for (i = e * n, o = 0; o <= n; o++) c = o + i, s = c + e, f = c + n + e, l = c + n + 1 + e, this.faces.push(new THREE.Face3(s, f, l, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([u[s].clone(), u[f].clone(), u[l].clone()]), s = c + e, f = c + n + 1 + e, l = c + 1 + e, this.faces.push(new THREE.Face3(s, f, l, [t.clone(), t.clone(), t.clone()])), this.faceVertexUvs[0].push([u[s].clone(), u[f].clone(), u[l].clone()]);
		this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
	}, THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.SphereGeometry = function(e, t, n, r, i, s, o) {
		THREE.Geometry.call(this), this.radius = e = e || 50, this.widthSegments = t = Math.max(3, Math.floor(t) || 8), this.heightSegments = n = Math.max(2, Math.floor(n) || 6), this.phiStart = r = void 0 !== r ? r : 0, this.phiLength = i = void 0 !== i ? i : 2 * Math.PI, this.thetaStart = s = void 0 !== s ? s : 0, this.thetaLength = o = void 0 !== o ? o : Math.PI;
		var u, a, f = [],
			l = [];
		for (a = 0; a <= n; a++) {
			var c = [],
				h = [];
			for (u = 0; u <= t; u++) {
				var p = u / t,
					d = a / n,
					v = new THREE.Vector3;
				v.x = -e * Math.cos(r + p * i) * Math.sin(s + d * o), v.y = e * Math.cos(s + d * o), v.z = e * Math.sin(r + p * i) * Math.sin(s + d * o), this.vertices.push(v), c.push(this.vertices.length - 1), h.push(new THREE.Vector2(p, 1 - d))
			}
			f.push(c), l.push(h)
		}
		for (a = 0; a < this.heightSegments; a++)
			for (u = 0; u < this.widthSegments; u++) {
				t = f[a][u + 1], n = f[a][u], r = f[a + 1][u], i = f[a + 1][u + 1], s = this.vertices[t].clone().normalize(), o = this.vertices[n].clone().normalize();
				var c = this.vertices[r].clone().normalize(),
					h = this.vertices[i].clone().normalize(),
					p = l[a][u + 1].clone(),
					d = l[a][u].clone(),
					v = l[a + 1][u].clone(),
					m = l[a + 1][u + 1].clone();
				Math.abs(this.vertices[t].y) === this.radius ? (p.x = (p.x + d.x) / 2, this.faces.push(new THREE.Face3(t, r, i, [s, c, h])), this.faceVertexUvs[0].push([p, v, m])) : Math.abs(this.vertices[r].y) === this.radius ? (v.x = (v.x + m.x) / 2, this.faces.push(new THREE.Face3(t, n, r, [s, o, c])), this.faceVertexUvs[0].push([p, d, v])) : (this.faces.push(new THREE.Face3(t, n, i, [s, o, h])), this.faceVertexUvs[0].push([p, d, m]), this.faces.push(new THREE.Face3(n, r, i, [o.clone(), c, h.clone()])), this.faceVertexUvs[0].push([d.clone(), v, m.clone()]))
			}
		this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
	}, THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TextGeometry = function(e, t) {
		t = t || {};
		var n = THREE.FontUtils.generateShapes(e, t);
		t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), THREE.ExtrudeGeometry.call(this, n, t)
	}, THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype), THREE.TorusGeometry = function(e, t, n, r, i) {
		THREE.Geometry.call(this), this.radius = e || 100, this.tube = t || 40, this.radialSegments = n || 8, this.tubularSegments = r || 6, this.arc = i || 2 * Math.PI, i = new THREE.Vector3, e = [], t = [];
		for (n = 0; n <= this.radialSegments; n++)
			for (r = 0; r <= this.tubularSegments; r++) {
				var s = r / this.tubularSegments * this.arc,
					o = n / this.radialSegments * Math.PI * 2;
				i.x = this.radius * Math.cos(s), i.y = this.radius * Math.sin(s);
				var u = new THREE.Vector3;
				u.x = (this.radius + this.tube * Math.cos(o)) * Math.cos(s), u.y = (this.radius + this.tube * Math.cos(o)) * Math.sin(s), u.z = this.tube * Math.sin(o), this.vertices.push(u), e.push(new THREE.Vector2(r / this.tubularSegments, n / this.radialSegments)), t.push(u.clone().sub(i).normalize())
			}
		for (n = 1; n <= this.radialSegments; n++)
			for (r = 1; r <= this.tubularSegments; r++) {
				i = (this.tubularSegments + 1) * n + r - 1;
				var s = (this.tubularSegments + 1) * (n - 1) + r - 1,
					o = (this.tubularSegments + 1) * (n - 1) + r,
					u = (this.tubularSegments + 1) * n + r,
					a = new THREE.Face3(i, s, u, [t[i].clone(), t[s].clone(), t[u].clone()]);
				this.faces.push(a), this.faceVertexUvs[0].push([e[i].clone(), e[s].clone(), e[u].clone()]), a = new THREE.Face3(s, o, u, [t[s].clone(), t[o].clone(), t[u].clone()]), this.faces.push(a), this.faceVertexUvs[0].push([e[s].clone(), e[o].clone(), e[u].clone()])
			}
		this.computeCentroids(), this.computeFaceNormals()
	}, THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TorusKnotGeometry = function(e, t, n, r, i, s, o) {
		function u(e, t, n, r, i) {
			var s = Math.cos(e),
				o = Math.sin(e);
			return e *= t / n, t = Math.cos(e), s *= r * (2 + t) * .5, o = r * (2 + t) * o * .5, r = i * r * Math.sin(e) * .5, new THREE.Vector3(s, o, r)
		}
		THREE.Geometry.call(this), this.radius = e || 100, this.tube = t || 40, this.radialSegments = n || 64, this.tubularSegments = r || 8, this.p = i || 2, this.q = s || 3, this.heightScale = o || 1, this.grid = Array(this.radialSegments), n = new THREE.Vector3, r = new THREE.Vector3, i = new THREE.Vector3;
		for (e = 0; e < this.radialSegments; ++e)
			for (this.grid[e] = Array(this.tubularSegments), t = e / this.radialSegments * 2 * this.p * Math.PI, s = u(t, this.q, this.p, this.radius, this.heightScale), t = u(t + .01, this.q, this.p, this.radius, this.heightScale), n.subVectors(t, s), r.addVectors(t, s), i.crossVectors(n, r), r.crossVectors(i, n), i.normalize(), r.normalize(), t = 0; t < this.tubularSegments; ++t) {
				var a = t / this.tubularSegments * 2 * Math.PI;
				o = -this.tube * Math.cos(a);
				var a = this.tube * Math.sin(a),
					f = new THREE.Vector3;
				f.x = s.x + o * r.x + a * i.x, f.y = s.y + o * r.y + a * i.y, f.z = s.z + o * r.z + a * i.z, this.grid[e][t] = this.vertices.push(f) - 1
			}
		for (e = 0; e < this.radialSegments; ++e)
			for (t = 0; t < this.tubularSegments; ++t) {
				i = (e + 1) % this.radialSegments, s = (t + 1) % this.tubularSegments, n = this.grid[e][t], r = this.grid[i][t], i = this.grid[i][s], s = this.grid[e][s], o = new THREE.Vector2(e / this.radialSegments, t / this.tubularSegments);
				var a = new THREE.Vector2((e + 1) / this.radialSegments, t / this.tubularSegments),
					f = new THREE.Vector2((e + 1) / this.radialSegments, (t + 1) / this.tubularSegments),
					l = new THREE.Vector2(e / this.radialSegments, (t + 1) / this.tubularSegments);
				this.faces.push(new THREE.Face3(n, r, s)), this.faceVertexUvs[0].push([o, a, l]), this.faces.push(new THREE.Face3(r, i, s)), this.faceVertexUvs[0].push([a.clone(), f, l.clone()])
			}
		this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry = function(e, t, n, r, i) {
		THREE.Geometry.call(this), this.path = e, this.segments = t || 64, this.radius = n || 1, this.radialSegments = r || 8, this.closed = i || !1, this.grid = [];
		var s, o;
		r = this.segments + 1;
		var u, a, f;
		i = new THREE.Vector3;
		var l, c;
		t = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed), l = t.normals, c = t.binormals, this.tangents = t.tangents, this.normals = l, this.binormals = c;
		for (t = 0; t < r; t++)
			for (this.grid[t] = [], n = t / (r - 1), f = e.getPointAt(n), s = l[t], o = c[t], n = 0; n < this.radialSegments; n++) u = n / this.radialSegments * 2 * Math.PI, a = -this.radius * Math.cos(u), u = this.radius * Math.sin(u), i.copy(f), i.x += a * s.x + u * o.x, i.y += a * s.y + u * o.y, i.z += a * s.z + u * o.z, this.grid[t][n] = this.vertices.push(new THREE.Vector3(i.x, i.y, i.z)) - 1;
		for (t = 0; t < this.segments; t++)
			for (n = 0; n < this.radialSegments; n++) i = this.closed ? (t + 1) % this.segments : t + 1, l = (n + 1) % this.radialSegments, e = this.grid[t][n], r = this.grid[i][n], i = this.grid[i][l], l = this.grid[t][l], c = new THREE.Vector2(t / this.segments, n / this.radialSegments), s = new THREE.Vector2((t + 1) / this.segments, n / this.radialSegments), o = new THREE.Vector2((t + 1) / this.segments, (n + 1) / this.radialSegments), a = new THREE.Vector2(t / this.segments, (n + 1) / this.radialSegments), this.faces.push(new THREE.Face3(e, r, l)), this.faceVertexUvs[0].push([c, s, a]), this.faces.push(new THREE.Face3(r, i, l)), this.faceVertexUvs[0].push([s.clone(), o, a.clone()]);
		this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TubeGeometry.FrenetFrames = function(e, t, n) {
		new THREE.Vector3;
		var r = new THREE.Vector3;
		new THREE.Vector3;
		var i = [],
			s = [],
			o = [],
			u = new THREE.Vector3,
			a = new THREE.Matrix4;
		t += 1;
		var f, l, c;
		this.tangents = i, this.normals = s, this.binormals = o;
		for (f = 0; f < t; f++) l = f / (t - 1), i[f] = e.getTangentAt(l), i[f].normalize();
		s[0] = new THREE.Vector3, o[0] = new THREE.Vector3, e = Number.MAX_VALUE, f = Math.abs(i[0].x), l = Math.abs(i[0].y), c = Math.abs(i[0].z), f <= e && (e = f, r.set(1, 0, 0)), l <= e && (e = l, r.set(0, 1, 0)), c <= e && r.set(0, 0, 1), u.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], u), o[0].crossVectors(i[0], s[0]);
		for (f = 1; f < t; f++) s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), u.crossVectors(i[f - 1], i[f]), 1e-4 < u.length() && (u.normalize(), r = Math.acos(THREE.Math.clamp(i[f - 1].dot(i[f]), -1, 1)), s[f].applyMatrix4(a.makeRotationAxis(u, r))), o[f].crossVectors(i[f], s[f]);
		if (n)
			for (r = Math.acos(THREE.Math.clamp(s[0].dot(s[t - 1]), -1, 1)), r /= t - 1, 0 < i[0].dot(u.crossVectors(s[0], s[t - 1])) && (r = -r), f = 1; f < t; f++) s[f].applyMatrix4(a.makeRotationAxis(i[f], r * f)), o[f].crossVectors(i[f], s[f])
	}, THREE.PolyhedronGeometry = function(e, t, n, r) {
		function i(e) {
			var t = e.normalize().clone();
			t.index = a.vertices.push(t) - 1;
			var n = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
			return e = Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5, t.uv = new THREE.Vector2(n, 1 - e), t
		}

		function s(e, t, n) {
			var r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()]);
			r.centroid.add(e).add(t).add(n).divideScalar(3), a.faces.push(r), r = r.centroid, r = Math.atan2(r.z, -r.x), a.faceVertexUvs[0].push([u(e.uv, e, r), u(t.uv, t, r), u(n.uv, n, r)])
		}

		function o(e, t) {
			var n = Math.pow(2, t);
			Math.pow(4, t);
			for (var r = i(a.vertices[e.a]), o = i(a.vertices[e.b]), u = i(a.vertices[e.c]), f = [], l = 0; l <= n; l++) {
				f[l] = [];
				for (var c = i(r.clone().lerp(u, l / n)), h = i(o.clone().lerp(u, l / n)), p = n - l, d = 0; d <= p; d++) f[l][d] = 0 == d && l == n ? c : i(c.clone().lerp(h, d / p))
			}
			for (l = 0; l < n; l++)
				for (d = 0; d < 2 * (n - l) - 1; d++) r = Math.floor(d / 2), 0 == d % 2 ? s(f[l][r + 1], f[l + 1][r], f[l][r]) : s(f[l][r + 1], f[l + 1][r + 1], f[l + 1][r])
		}

		function u(e, t, n) {
			return 0 > n && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new THREE.Vector2(n / 2 / Math.PI + .5, e.y)), e.clone()
		}
		THREE.Geometry.call(this), n = n || 1, r = r || 0;
		for (var a = this, f = 0, l = e.length; f < l; f++) i(new THREE.Vector3(e[f][0], e[f][1], e[f][2]));
		e = this.vertices;
		for (var c = [], f = 0, l = t.length; f < l; f++) {
			var h = e[t[f][0]],
				p = e[t[f][1]],
				d = e[t[f][2]];
			c[f] = new THREE.Face3(h.index, p.index, d.index, [h.clone(), p.clone(), d.clone()])
		}
		f = 0;
		for (l = c.length; f < l; f++) o(c[f], r);
		f = 0;
		for (l = this.faceVertexUvs[0].length; f < l; f++) t = this.faceVertexUvs[0][f], r = t[0].x, e = t[1].x, c = t[2].x, h = Math.max(r, Math.max(e, c)), p = Math.min(r, Math.min(e, c)), .9 < h && .1 > p && (.2 > r && (t[0].x += 1), .2 > e && (t[1].x += 1), .2 > c && (t[2].x += 1));
		f = 0;
		for (l = this.vertices.length; f < l; f++) this.vertices[f].multiplyScalar(n);
		this.mergeVertices(), this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3, n)
	}, THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.IcosahedronGeometry = function(e, t) {
		this.radius = e, this.detail = t;
		var n = (1 + Math.sqrt(5)) / 2;
		THREE.PolyhedronGeometry.call(this, [
			[-1, n, 0],
			[1, n, 0],
			[-1, -n, 0],
			[1, -n, 0],
			[0, -1, n],
			[0, 1, n],
			[0, -1, -n],
			[0, 1, -n],
			[n, 0, -1],
			[n, 0, 1],
			[-n, 0, -1],
			[-n, 0, 1]
		], [
			[0, 11, 5],
			[0, 5, 1],
			[0, 1, 7],
			[0, 7, 10],
			[0, 10, 11],
			[1, 5, 9],
			[5, 11, 4],
			[11, 10, 2],
			[10, 7, 6],
			[7, 1, 8],
			[3, 9, 4],
			[3, 4, 2],
			[3, 2, 6],
			[3, 6, 8],
			[3, 8, 9],
			[4, 9, 5],
			[2, 4, 11],
			[6, 2, 10],
			[8, 6, 7],
			[9, 8, 1]
		], e, t)
	}, THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.OctahedronGeometry = function(e, t) {
		THREE.PolyhedronGeometry.call(this, [
			[1, 0, 0],
			[-1, 0, 0],
			[0, 1, 0],
			[0, -1, 0],
			[0, 0, 1],
			[0, 0, -1]
		], [
			[0, 2, 4],
			[0, 4, 3],
			[0, 3, 5],
			[0, 5, 2],
			[1, 2, 5],
			[1, 5, 3],
			[1, 3, 4],
			[1, 4, 2]
		], e, t)
	}, THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.TetrahedronGeometry = function(e, t) {
		THREE.PolyhedronGeometry.call(this, [
			[1, 1, 1],
			[-1, -1, 1],
			[-1, 1, -1],
			[1, -1, -1]
		], [
			[2, 1, 0],
			[0, 3, 2],
			[1, 3, 0],
			[2, 3, 1]
		], e, t)
	}, THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.ParametricGeometry = function(e, t, n) {
		THREE.Geometry.call(this);
		var r = this.vertices,
			i = this.faces,
			s = this.faceVertexUvs[0],
			o, u, a, f, l = t + 1;
		for (o = 0; o <= n; o++)
			for (f = o / n, u = 0; u <= t; u++) a = u / t, a = e(a, f), r.push(a);
		var c, h, p, d;
		for (o = 0; o < n; o++)
			for (u = 0; u < t; u++) e = o * l + u, r = o * l + u + 1, f = (o + 1) * l + u + 1, a = (o + 1) * l + u, c = new THREE.Vector2(u / t, o / n), h = new THREE.Vector2((u + 1) / t, o / n), p = new THREE.Vector2((u + 1) / t, (o + 1) / n), d = new THREE.Vector2(u / t, (o + 1) / n), i.push(new THREE.Face3(e, r, a)), s.push([c, h, d]), i.push(new THREE.Face3(r, f, a)), s.push([h.clone(), p, d.clone()]);
		this.computeCentroids(), this.computeFaceNormals(), this.computeVertexNormals()
	}, THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype), THREE.AxisHelper = function(e) {
		e = e || 1;
		var t = new THREE.Geometry;
		t.vertices.push(new THREE.Vector3, new THREE.Vector3(e, 0, 0), new THREE.Vector3, new THREE.Vector3(0, e, 0), new THREE.Vector3, new THREE.Vector3(0, 0, e)), t.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775)), e = new THREE.LineBasicMaterial({
			vertexColors: THREE.VertexColors
		}), THREE.Line.call(this, t, e, THREE.LinePieces)
	}, THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype), THREE.ArrowHelper = function(e, t, n, r, i, s) {
		THREE.Object3D.call(this), void 0 === r && (r = 16776960), void 0 === n && (n = 1), void 0 === i && (i = .2 * n), void 0 === s && (s = .2 * i), this.position = t, t = new THREE.Geometry, t.vertices.push(new THREE.Vector3(0, 0, 0)), t.vertices.push(new THREE.Vector3(0, 1, 0)), this.line = new THREE.Line(t, new THREE.LineBasicMaterial({
			color: r
		})), this.line.matrixAutoUpdate = !1, this.add(this.line), t = new THREE.CylinderGeometry(0, .5, 1, 5, 1), t.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0)), this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({
			color: r
		})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s)
	}, THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.ArrowHelper.prototype.setDirection = function() {
		var e = new THREE.Vector3,
			t;
		return function(n) {
			.99999 < n.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > n.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
		}
	}(), THREE.ArrowHelper.prototype.setLength = function(e, t, n) {
		void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, e, 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
	}, THREE.ArrowHelper.prototype.setColor = function(e) {
		this.line.material.color.setHex(e), this.cone.material.color.setHex(e)
	}, THREE.BoxHelper = function(e) {
		var t = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, -1, 1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1)];
		this.vertices = t;
		var n = new THREE.Geometry;
		n.vertices.push(t[0], t[1], t[1], t[2], t[2], t[3], t[3], t[0], t[4], t[5], t[5], t[6], t[6], t[7], t[7], t[4], t[0], t[4], t[1], t[5], t[2], t[6], t[3], t[7]), THREE.Line.call(this, n, new THREE.LineBasicMaterial({
			color: 16776960
		}), THREE.LinePieces), void 0 !== e && this.update(e)
	}, THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype), THREE.BoxHelper.prototype.update = function(e) {
		var t = e.geometry;
		null === t.boundingBox && t.computeBoundingBox();
		var n = t.boundingBox.min,
			t = t.boundingBox.max,
			r = this.vertices;
		r[0].set(t.x, t.y, t.z), r[1].set(n.x, t.y, t.z), r[2].set(n.x, n.y, t.z), r[3].set(t.x, n.y, t.z), r[4].set(t.x, t.y, n.z), r[5].set(n.x, t.y, n.z), r[6].set(n.x, n.y, n.z), r[7].set(t.x, n.y, n.z), this.geometry.computeBoundingSphere(), this.geometry.verticesNeedUpdate = !0, this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.BoundingBoxHelper = function(e, t) {
		var n = void 0 !== t ? t : 8947848;
		this.object = e, this.box = new THREE.Box3, THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
			color: n,
			wireframe: !0
		}))
	}, THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.BoundingBoxHelper.prototype.update = function() {
		this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
	}, THREE.CameraHelper = function(e) {
		function t(e, t, r) {
			n(e, r), n(t, r)
		}

		function n(e, t) {
			r.vertices.push(new THREE.Vector3), r.colors.push(new THREE.Color(t)), void 0 === s[e] && (s[e] = []), s[e].push(r.vertices.length - 1)
		}
		var r = new THREE.Geometry,
			i = new THREE.LineBasicMaterial({
				color: 16777215,
				vertexColors: THREE.FaceColors
			}),
			s = {};
		t("n1", "n2", 16755200), t("n2", "n4", 16755200), t("n4", "n3", 16755200), t("n3", "n1", 16755200), t("f1", "f2", 16755200), t("f2", "f4", 16755200), t("f4", "f3", 16755200), t("f3", "f1", 16755200), t("n1", "f1", 16755200), t("n2", "f2", 16755200), t("n3", "f3", 16755200), t("n4", "f4", 16755200), t("p", "n1", 16711680), t("p", "n2", 16711680), t("p", "n3", 16711680), t("p", "n4", 16711680), t("u1", "u2", 43775), t("u2", "u3", 43775), t("u3", "u1", 43775), t("c", "t", 16777215), t("p", "c", 3355443), t("cn1", "cn2", 3355443), t("cn3", "cn4", 3355443), t("cf1", "cf2", 3355443), t("cf3", "cf4", 3355443), THREE.Line.call(this, r, i, THREE.LinePieces), this.camera = e, this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
	}, THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype), THREE.CameraHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Camera,
			n = new THREE.Projector;
		return function() {
			function r(r, s, o, u) {
				e.set(s, o, u), n.unprojectVector(e, t), r = i.pointMap[r];
				if (void 0 !== r)
					for (s = 0, o = r.length; s < o; s++) i.geometry.vertices[r[s]].copy(e)
			}
			var i = this;
			t.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -0.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), this.geometry.verticesNeedUpdate = !0
		}
	}(), THREE.DirectionalLightHelper = function(e, t) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
		var n = new THREE.PlaneGeometry(t, t),
			r = new THREE.MeshBasicMaterial({
				wireframe: !0,
				fog: !1
			});
		r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new THREE.Mesh(n, r), this.add(this.lightPlane), n = new THREE.Geometry, n.vertices.push(new THREE.Vector3), n.vertices.push(new THREE.Vector3), r = new THREE.LineBasicMaterial({
			fog: !1
		}), r.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new THREE.Line(n, r), this.add(this.targetLine), this.update()
	}, THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.DirectionalLightHelper.prototype.dispose = function() {
		this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
	}, THREE.DirectionalLightHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3,
			n = new THREE.Vector3;
		return function() {
			e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(n), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
		}
	}(), THREE.EdgesHelper = function(e, t) {
		var n = void 0 !== t ? t : 16777215,
			r = [0, 0],
			i = {},
			s = function(e, t) {
				return e - t
			},
			o = ["a", "b", "c"],
			u = new THREE.BufferGeometry,
			a = e.geometry.clone();
		a.mergeVertices(), a.computeFaceNormals();
		for (var f = a.vertices, a = a.faces, l = 0, c = 0, h = a.length; c < h; c++)
			for (var p = a[c], d = 0; 3 > d; d++) {
				r[0] = p[o[d]], r[1] = p[o[(d + 1) % 3]], r.sort(s);
				var v = r.toString();
				void 0 === i[v] ? (i[v] = {
					vert1: r[0],
					vert2: r[1],
					face1: c,
					face2: void 0
				}, l++) : i[v].face2 = c
			}
		u.addAttribute("position", Float32Array, 2 * l, 3), r = u.attributes.position.array, s = 0;
		for (v in i)
			if (o = i[v], void 0 === o.face2 || .9999 > a[o.face1].normal.dot(a[o.face2].normal)) l = f[o.vert1], r[s++] = l.x, r[s++] = l.y, r[s++] = l.z, l = f[o.vert2], r[s++] = l.x, r[s++] = l.y, r[s++] = l.z;
		THREE.Line.call(this, u, new THREE.LineBasicMaterial({
			color: n
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== n ? n : 16776960, r = void 0 !== r ? r : 1, t = new THREE.Geometry, n = 0;
		for (var i = this.object.geometry.faces.length; n < i; n++) t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3);
		THREE.Line.call(this, t, new THREE.LineBasicMaterial({
			color: e,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
	}, THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.FaceNormalsHelper.prototype.update = function(e) {
		var t = new THREE.Vector3;
		return function(e) {
			this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld), e = this.geometry.vertices;
			for (var n = this.object.geometry.faces, r = this.object.matrixWorld, i = 0, s = n.length; i < s; i++) {
				var o = n[i];
				t.copy(o.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
				var u = 2 * i;
				e[u].copy(o.centroid).applyMatrix4(r), e[u + 1].addVectors(e[u], t)
			}
			return this.geometry.verticesNeedUpdate = !0, this
		}
	}(), THREE.GridHelper = function(e, t) {
		var n = new THREE.Geometry,
			r = new THREE.LineBasicMaterial({
				vertexColors: THREE.VertexColors
			});
		this.color1 = new THREE.Color(4473924), this.color2 = new THREE.Color(8947848);
		for (var i = -e; i <= e; i += t) {
			n.vertices.push(new THREE.Vector3(-e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
			var s = 0 === i ? this.color1 : this.color2;
			n.colors.push(s, s, s, s)
		}
		THREE.Line.call(this, n, r, THREE.LinePieces)
	}, THREE.GridHelper.prototype = Object.create(THREE.Line.prototype), THREE.GridHelper.prototype.setColors = function(e, t) {
		this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
	}, THREE.HemisphereLightHelper = function(e, t, n, r) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new THREE.Color, new THREE.Color], e = new THREE.SphereGeometry(t, 4, 2), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
		for (t = 0; 8 > t; t++) e.faces[t].color = this.colors[4 > t ? 0 : 1];
		t = new THREE.MeshBasicMaterial({
			vertexColors: THREE.FaceColors,
			wireframe: !0
		}), this.lightSphere = new THREE.Mesh(e, t), this.add(this.lightSphere), this.update()
	}, THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.HemisphereLightHelper.prototype.dispose = function() {
		this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
	}, THREE.HemisphereLightHelper.prototype.update = function() {
		var e = new THREE.Vector3;
		return function() {
			this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
		}
	}(), THREE.PointLightHelper = function(e, t) {
		this.light = e, this.light.updateMatrixWorld();
		var n = new THREE.SphereGeometry(t, 4, 2),
			r = new THREE.MeshBasicMaterial({
				wireframe: !0,
				fog: !1
			});
		r.color.copy(this.light.color).multiplyScalar(this.light.intensity), THREE.Mesh.call(this, n, r), this.matrixWorld = this.light.matrixWorld, this.matrixAutoUpdate = !1
	}, THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype), THREE.PointLightHelper.prototype.dispose = function() {
		this.geometry.dispose(), this.material.dispose()
	}, THREE.PointLightHelper.prototype.update = function() {
		this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
	}, THREE.SpotLightHelper = function(e) {
		THREE.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrixWorld = e.matrixWorld, this.matrixAutoUpdate = !1, e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0), e.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0)), e.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
		var t = new THREE.MeshBasicMaterial({
			wireframe: !0,
			fog: !1
		});
		this.cone = new THREE.Mesh(e, t), this.add(this.cone), this.update()
	}, THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype), THREE.SpotLightHelper.prototype.dispose = function() {
		this.cone.geometry.dispose(), this.cone.material.dispose()
	}, THREE.SpotLightHelper.prototype.update = function() {
		var e = new THREE.Vector3,
			t = new THREE.Vector3;
		return function() {
			var n = this.light.distance ? this.light.distance : 1e4,
				r = n * Math.tan(this.light.angle);
			this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
		}
	}(), THREE.VertexNormalsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 16711680, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
		for (var i = 0, s = e.length; i < s; i++)
			for (var o = 0, u = e[i].vertexNormals.length; o < u; o++) n.vertices.push(new THREE.Vector3), n.vertices.push(new THREE.Vector3);
		THREE.Line.call(this, n, new THREE.LineBasicMaterial({
			color: t,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.normalMatrix = new THREE.Matrix3, this.update()
	}, THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexNormalsHelper.prototype.update = function(e) {
		var t = new THREE.Vector3;
		return function(e) {
			e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0), this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
			for (var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, s = this.object.matrixWorld, o = 0, u = 0, a = i.length; u < a; u++)
				for (var f = i[u], l = 0, c = f.vertexNormals.length; l < c; l++) {
					var h = f.vertexNormals[l];
					n[o].copy(r[f[e[l]]]).applyMatrix4(s), t.copy(h).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size), t.add(n[o]), o += 1, n[o].copy(t), o += 1
				}
			return this.geometry.verticesNeedUpdate = !0, this
		}
	}(), THREE.VertexTangentsHelper = function(e, t, n, r) {
		this.object = e, this.size = void 0 !== t ? t : 1, t = void 0 !== n ? n : 255, r = void 0 !== r ? r : 1, n = new THREE.Geometry, e = e.geometry.faces;
		for (var i = 0, s = e.length; i < s; i++)
			for (var o = 0, u = e[i].vertexTangents.length; o < u; o++) n.vertices.push(new THREE.Vector3), n.vertices.push(new THREE.Vector3);
		THREE.Line.call(this, n, new THREE.LineBasicMaterial({
			color: t,
			linewidth: r
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.update()
	}, THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype), THREE.VertexTangentsHelper.prototype.update = function(e) {
		var t = new THREE.Vector3;
		return function(e) {
			e = ["a", "b", "c", "d"], this.object.updateMatrixWorld(!0);
			for (var n = this.geometry.vertices, r = this.object.geometry.vertices, i = this.object.geometry.faces, s = this.object.matrixWorld, o = 0, u = 0, a = i.length; u < a; u++)
				for (var f = i[u], l = 0, c = f.vertexTangents.length; l < c; l++) {
					var h = f.vertexTangents[l];
					n[o].copy(r[f[e[l]]]).applyMatrix4(s), t.copy(h).transformDirection(s).multiplyScalar(this.size), t.add(n[o]), o += 1, n[o].copy(t), o += 1
				}
			return this.geometry.verticesNeedUpdate = !0, this
		}
	}(), THREE.WireframeHelper = function(e, t) {
		var n = void 0 !== t ? t : 16777215,
			r = [0, 0],
			i = {},
			s = function(e, t) {
				return e - t
			},
			o = ["a", "b", "c"],
			u = new THREE.BufferGeometry;
		if (e.geometry instanceof THREE.Geometry) {
			for (var a = e.geometry.vertices, f = e.geometry.faces, l = 0, c = new Uint32Array(6 * f.length), h = 0, p = f.length; h < p; h++)
				for (var d = f[h], v = 0; 3 > v; v++) {
					r[0] = d[o[v]], r[1] = d[o[(v + 1) % 3]], r.sort(s);
					var m = r.toString();
					void 0 === i[m] && (c[2 * l] = r[0], c[2 * l + 1] = r[1], i[m] = !0, l++)
				}
			u.addAttribute("position", Float32Array, 2 * l, 3), r = u.attributes.position.array, h = 0;
			for (p = l; h < p; h++)
				for (v = 0; 2 > v; v++) l = a[c[2 * h + v]], o = 6 * h + 3 * v, r[o + 0] = l.x, r[o + 1] = l.y, r[o + 2] = l.z
		} else if (e.geometry instanceof THREE.BufferGeometry && void 0 !== e.geometry.attributes.index) {
			for (var a = e.geometry.attributes.position.array, p = e.geometry.attributes.index.array, f = e.geometry.offsets, l = 0, c = new Uint32Array(2 * p.length), d = 0, g = f.length; d < g; ++d)
				for (var v = f[d].start, m = f[d].count, o = f[d].index, h = v, y = v + m; h < y; h += 3)
					for (v = 0; 3 > v; v++) r[0] = o + p[h + v], r[1] = o + p[h + (v + 1) % 3], r.sort(s), m = r.toString(), void 0 === i[m] && (c[2 * l] = r[0], c[2 * l + 1] = r[1], i[m] = !0, l++);
			u.addAttribute("position", Float32Array, 2 * l, 3), r = u.attributes.position.array, h = 0;
			for (p = l; h < p; h++)
				for (v = 0; 2 > v; v++) o = 6 * h + 3 * v, l = 3 * c[2 * h + v], r[o + 0] = a[l], r[o + 1] = a[l + 1], r[o + 2] = a[l + 2]
		} else if (e.geometry instanceof THREE.BufferGeometry)
			for (a = e.geometry.attributes.position.array, l = a.length / 3, c = l / 3, u.addAttribute("position", Float32Array, 2 * l, 3), r = u.attributes.position.array, h = 0, p = c; h < p; h++)
				for (v = 0; 3 > v; v++) o = 18 * h + 6 * v, c = 9 * h + 3 * v, r[o + 0] = a[c], r[o + 1] = a[c + 1], r[o + 2] = a[c + 2], l = 9 * h + (v + 1) % 3 * 3, r[o + 3] = a[l], r[o + 4] = a[l + 1], r[o + 5] = a[l + 2];
		THREE.Line.call(this, u, new THREE.LineBasicMaterial({
			color: n
		}), THREE.LinePieces), this.matrixAutoUpdate = !1, this.matrixWorld = e.matrixWorld
	}, THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype), THREE.ImmediateRenderObject = function() {
		THREE.Object3D.call(this), this.render = function(e) {}
	}, THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare = function(e, t, n, r, i) {
		THREE.Object3D.call(this), this.lensFlares = [], this.positionScreen = new THREE.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, n, r, i)
	}, THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype), THREE.LensFlare.prototype.add = function(e, t, n, r, i, s) {
		void 0 === t && (t = -1), void 0 === n && (n = 0), void 0 === s && (s = 1), void 0 === i && (i = new THREE.Color(16777215)), void 0 === r && (r = THREE.NormalBlending), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
			texture: e,
			size: t,
			distance: n,
			x: 0,
			y: 0,
			z: 0,
			scale: 1,
			rotation: 1,
			opacity: s,
			color: i,
			blending: r
		})
	}, THREE.LensFlare.prototype.updateLensFlares = function() {
		var e, t = this.lensFlares.length,
			n, r = 2 * -this.positionScreen.x,
			i = 2 * -this.positionScreen.y;
		for (e = 0; e < t; e++) n = this.lensFlares[e], n.x = this.positionScreen.x + r * n.distance, n.y = this.positionScreen.y + i * n.distance, n.wantedRotation = n.x * Math.PI * .25, n.rotation += .25 * (n.wantedRotation - n.rotation)
	}, THREE.MorphBlendMesh = function(e, t) {
		THREE.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
		var n = this.geometry.morphTargets.length;
		this.createAnimation("__default", 0, n - 1, n / 1), this.setAnimationWeight("__default", 1)
	}, THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype), THREE.MorphBlendMesh.prototype.createAnimation = function(e, t, n, r) {
		t = {
			startFrame: t,
			endFrame: n,
			length: n - t + 1,
			fps: r,
			duration: (n - t) / r,
			lastFrame: 0,
			currentFrame: 0,
			active: !1,
			time: 0,
			direction: 1,
			weight: 1,
			directionBackwards: !1,
			mirroredLoop: !1
		}, this.animationsMap[e] = t, this.animationsList.push(t)
	}, THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
		for (var t = /([a-z]+)(\d+)/, n, r = {}, i = this.geometry, s = 0, o = i.morphTargets.length; s < o; s++) {
			var u = i.morphTargets[s].name.match(t);
			if (u && 1 < u.length) {
				var a = u[1];
				r[a] || (r[a] = {
					start: Infinity,
					end: -Infinity
				}), u = r[a], s < u.start && (u.start = s), s > u.end && (u.end = s), n || (n = a)
			}
		}
		for (a in r) u = r[a], this.createAnimation(a, u.start, u.end, e);
		this.firstAnimation = n
	}, THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
		if (e = this.animationsMap[e]) e.direction = 1, e.directionBackwards = !1
	}, THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
		if (e = this.animationsMap[e]) e.direction = -1, e.directionBackwards = !0
	}, THREE.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
	}, THREE.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
	}, THREE.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.weight = t)
	}, THREE.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
		var n = this.animationsMap[e];
		n && (n.time = t)
	}, THREE.MorphBlendMesh.prototype.getAnimationTime = function(e) {
		var t = 0;
		if (e = this.animationsMap[e]) t = e.time;
		return t
	}, THREE.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
		var t = -1;
		if (e = this.animationsMap[e]) t = e.duration;
		return t
	}, THREE.MorphBlendMesh.prototype.playAnimation = function(e) {
		var t = this.animationsMap[e];
		t ? (t.time = 0, t.active = !0) : console.warn("animation[" + e + "] undefined")
	}, THREE.MorphBlendMesh.prototype.stopAnimation = function(e) {
		if (e = this.animationsMap[e]) e.active = !1
	}, THREE.MorphBlendMesh.prototype.update = function(e) {
		for (var t = 0, n = this.animationsList.length; t < n; t++) {
			var r = this.animationsList[t];
			if (r.active) {
				var i = r.duration / r.length;
				r.time += r.direction * e;
				if (r.mirroredLoop) {
					if (r.time > r.duration || 0 > r.time) r.direction *= -1, r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0), 0 > r.time && (r.time = 0, r.directionBackwards = !1)
				} else r.time %= r.duration, 0 > r.time && (r.time += r.duration);
				var s = r.startFrame + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
					o = r.weight;
				s !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * o, this.morphTargetInfluences[s] = 0, r.lastFrame = r.currentFrame, r.currentFrame = s), i = r.time % i / i, r.directionBackwards && (i = 1 - i), this.morphTargetInfluences[r.currentFrame] = i * o, this.morphTargetInfluences[r.lastFrame] = (1 - i) * o
			}
		}
	}, THREE.LensFlarePlugin = function() {
		function e(e, n) {
			var r = t.createProgram(),
				i = t.createShader(t.FRAGMENT_SHADER),
				s = t.createShader(t.VERTEX_SHADER),
				o = "precision " + n + " float;\n";
			return t.shaderSource(i, o + e.fragmentShader), t.shaderSource(s, o + e.vertexShader), t.compileShader(i), t.compileShader(s), t.attachShader(r, i), t.attachShader(r, s), t.linkProgram(r), r
		}
		var t, n, r, i, s, o, u, a, f, l, c, h, p;
		this.init = function(v) {
			t = v.context, n = v, r = v.getPrecision(), i = new Float32Array(16), s = new Uint16Array(6), v = 0, i[v++] = -1, i[v++] = -1, i[v++] = 0, i[v++] = 0, i[v++] = 1, i[v++] = -1, i[v++] = 1, i[v++] = 0, i[v++] = 1, i[v++] = 1, i[v++] = 1, i[v++] = 1, i[v++] = -1, i[v++] = 1, i[v++] = 0, i[v++] = 1, v = 0, s[v++] = 0, s[v++] = 1, s[v++] = 2, s[v++] = 0, s[v++] = 2, s[v++] = 3, o = t.createBuffer(), u = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), t.bufferData(t.ELEMENT_ARRAY_BUFFER, s, t.STATIC_DRAW), a = t.createTexture(), f = t.createTexture(), t.bindTexture(t.TEXTURE_2D, a), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 16, 16, 0, t.RGB, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.bindTexture(t.TEXTURE_2D, f), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 16, 16, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), 0 >= t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (l = !1, c = e(THREE.ShaderFlares.lensFlare, r)) : (l = !0, c = e(THREE.ShaderFlares.lensFlareVertexTexture, r)), h = {}, p = {}, h.vertex = t.getAttribLocation(c, "position"), h.uv = t.getAttribLocation(c, "uv"), p.renderType = t.getUniformLocation(c, "renderType"), p.map = t.getUniformLocation(c, "map"), p.occlusionMap = t.getUniformLocation(c, "occlusionMap"), p.opacity = t.getUniformLocation(c, "opacity"), p.color = t.getUniformLocation(c, "color"), p.scale = t.getUniformLocation(c, "scale"), p.rotation = t.getUniformLocation(c, "rotation"), p.screenPosition = t.getUniformLocation(c, "screenPosition")
		}, this.render = function(e, r, i, s) {
			e = e.__webglFlares;
			var d = e.length;
			if (d) {
				var v = new THREE.Vector3,
					m = s / i,
					y = .5 * i,
					w = .5 * s,
					E = 16 / s,
					S = new THREE.Vector2(E * m, E),
					x = new THREE.Vector3(1, 1, 0),
					T = new THREE.Vector2(1, 1),
					N = p,
					E = h;
				t.useProgram(c), t.enableVertexAttribArray(h.vertex), t.enableVertexAttribArray(h.uv), t.uniform1i(N.occlusionMap, 0), t.uniform1i(N.map, 1), t.bindBuffer(t.ARRAY_BUFFER, o), t.vertexAttribPointer(E.vertex, 2, t.FLOAT, !1, 16, 0), t.vertexAttribPointer(E.uv, 2, t.FLOAT, !1, 16, 8), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, u), t.disable(t.CULL_FACE), t.depthMask(!1);
				var C, L, A, O, M;
				for (C = 0; C < d; C++)
					if (E = 16 / s, S.set(E * m, E), O = e[C], v.set(O.matrixWorld.elements[12], O.matrixWorld.elements[13], O.matrixWorld.elements[14]), v.applyMatrix4(r.matrixWorldInverse), v.applyProjection(r.projectionMatrix), x.copy(v), T.x = x.x * y + y, T.y = x.y * w + w, l || 0 < T.x && T.x < i && 0 < T.y && T.y < s)
						for (t.activeTexture(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, a), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGB, T.x - 8, T.y - 8, 16, 16, 0), t.uniform1i(N.renderType, 0), t.uniform2f(N.scale, S.x, S.y), t.uniform3f(N.screenPosition, x.x, x.y, x.z), t.disable(t.BLEND), t.enable(t.DEPTH_TEST), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, f), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, T.x - 8, T.y - 8, 16, 16, 0), t.uniform1i(N.renderType, 1), t.disable(t.DEPTH_TEST), t.activeTexture(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, a), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0), O.positionScreen.copy(x), O.customUpdateCallback ? O.customUpdateCallback(O) : O.updateLensFlares(), t.uniform1i(N.renderType, 2), t.enable(t.BLEND), L = 0, A = O.lensFlares.length; L < A; L++) M = O.lensFlares[L], .001 < M.opacity && .001 < M.scale && (x.x = M.x, x.y = M.y, x.z = M.z, E = M.size * M.scale / s, S.x = E * m, S.y = E, t.uniform3f(N.screenPosition, x.x, x.y, x.z), t.uniform2f(N.scale, S.x, S.y), t.uniform1f(N.rotation, M.rotation), t.uniform1f(N.opacity, M.opacity), t.uniform3f(N.color, M.color.r, M.color.g, M.color.b), n.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), n.setTexture(M.texture, 1), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
				t.enable(t.CULL_FACE), t.enable(t.DEPTH_TEST), t.depthMask(!0)
			}
		}
	}, THREE.ShadowMapPlugin = function() {
		var e, t, n, r, i, s, o = new THREE.Frustum,
			u = new THREE.Matrix4,
			a = new THREE.Vector3,
			f = new THREE.Vector3,
			l = new THREE.Vector3;
		this.init = function(o) {
			e = o.context, t = o, o = THREE.ShaderLib.depthRGBA;
			var u = THREE.UniformsUtils.clone(o.uniforms);
			n = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u
			}), r = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				morphTargets: !0
			}), i = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				skinning: !0
			}), s = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				morphTargets: !0,
				skinning: !0
			}), n._shadowPass = !0, r._shadowPass = !0, i._shadowPass = !0, s._shadowPass = !0
		}, this.render = function(e, n) {
			t.shadowMapEnabled && t.shadowMapAutoUpdate && this.update(e, n)
		}, this.update = function(p, v) {
			var m, y, w, E, S, x, T, N, C, L = [];
			E = 0, e.clearColor(1, 1, 1, 1), e.disable(e.BLEND), e.enable(e.CULL_FACE), e.frontFace(e.CCW), t.shadowMapCullFace === THREE.CullFaceFront ? e.cullFace(e.FRONT) : e.cullFace(e.BACK), t.setDepthTest(!0), m = 0;
			for (y = p.__lights.length; m < y; m++)
				if (w = p.__lights[m], w.castShadow)
					if (w instanceof THREE.DirectionalLight && w.shadowCascade)
						for (S = 0; S < w.shadowCascadeCount; S++) {
							var A;
							if (w.shadowCascadeArray[S]) A = w.shadowCascadeArray[S];
							else {
								C = w, T = S, A = new THREE.DirectionalLight, A.isVirtual = !0, A.onlyShadow = !0, A.castShadow = !0, A.shadowCameraNear = C.shadowCameraNear, A.shadowCameraFar = C.shadowCameraFar, A.shadowCameraLeft = C.shadowCameraLeft, A.shadowCameraRight = C.shadowCameraRight, A.shadowCameraBottom = C.shadowCameraBottom, A.shadowCameraTop = C.shadowCameraTop, A.shadowCameraVisible = C.shadowCameraVisible, A.shadowDarkness = C.shadowDarkness, A.shadowBias = C.shadowCascadeBias[T], A.shadowMapWidth = C.shadowCascadeWidth[T], A.shadowMapHeight = C.shadowCascadeHeight[T], A.pointsWorld = [], A.pointsFrustum = [], N = A.pointsWorld, x = A.pointsFrustum;
								for (var O = 0; 8 > O; O++) N[O] = new THREE.Vector3, x[O] = new THREE.Vector3;
								N = C.shadowCascadeNearZ[T], C = C.shadowCascadeFarZ[T], x[0].set(-1, -1, N), x[1].set(1, -1, N), x[2].set(-1, 1, N), x[3].set(1, 1, N), x[4].set(-1, -1, C), x[5].set(1, -1, C), x[6].set(-1, 1, C), x[7].set(1, 1, C), A.originalCamera = v, x = new THREE.Gyroscope, x.position = w.shadowCascadeOffset, x.add(A), x.add(A.target), v.add(x), w.shadowCascadeArray[S] = A, console.log("Created virtualLight", A)
							}
							T = w, N = S, C = T.shadowCascadeArray[N], C.position.copy(T.position), C.target.position.copy(T.target.position), C.lookAt(C.target), C.shadowCameraVisible = T.shadowCameraVisible, C.shadowDarkness = T.shadowDarkness, C.shadowBias = T.shadowCascadeBias[N], x = T.shadowCascadeNearZ[N], T = T.shadowCascadeFarZ[N], C = C.pointsFrustum, C[0].z = x, C[1].z = x, C[2].z = x, C[3].z = x, C[4].z = T, C[5].z = T, C[6].z = T, C[7].z = T, L[E] = A, E++
						} else L[E] = w, E++;
			m = 0;
			for (y = L.length; m < y; m++) {
				w = L[m], w.shadowMap || (S = THREE.LinearFilter, t.shadowMapType === THREE.PCFSoftShadowMap && (S = THREE.NearestFilter), w.shadowMap = new THREE.WebGLRenderTarget(w.shadowMapWidth, w.shadowMapHeight, {
					minFilter: S,
					magFilter: S,
					format: THREE.RGBAFormat
				}), w.shadowMapSize = new THREE.Vector2(w.shadowMapWidth, w.shadowMapHeight), w.shadowMatrix = new THREE.Matrix4);
				if (!w.shadowCamera) {
					if (w instanceof THREE.SpotLight) w.shadowCamera = new THREE.PerspectiveCamera(w.shadowCameraFov, w.shadowMapWidth / w.shadowMapHeight, w.shadowCameraNear, w.shadowCameraFar);
					else {
						if (!(w instanceof THREE.DirectionalLight)) {
							console.error("Unsupported light type for shadow");
							continue
						}
						w.shadowCamera = new THREE.OrthographicCamera(w.shadowCameraLeft, w.shadowCameraRight, w.shadowCameraTop, w.shadowCameraBottom, w.shadowCameraNear, w.shadowCameraFar)
					}
					p.add(w.shadowCamera), !0 === p.autoUpdate && p.updateMatrixWorld()
				}
				w.shadowCameraVisible && !w.cameraHelper && (w.cameraHelper = new THREE.CameraHelper(w.shadowCamera), w.shadowCamera.add(w.cameraHelper));
				if (w.isVirtual && A.originalCamera == v) {
					S = v, E = w.shadowCamera, x = w.pointsFrustum, C = w.pointsWorld, a.set(Infinity, Infinity, Infinity), f.set(-Infinity, -Infinity, -Infinity);
					for (T = 0; 8 > T; T++) N = C[T], N.copy(x[T]), THREE.ShadowMapPlugin.__projector.unprojectVector(N, S), N.applyMatrix4(E.matrixWorldInverse), N.x < a.x && (a.x = N.x), N.x > f.x && (f.x = N.x), N.y < a.y && (a.y = N.y), N.y > f.y && (f.y = N.y), N.z < a.z && (a.z = N.z), N.z > f.z && (f.z = N.z);
					E.left = a.x, E.right = f.x, E.top = f.y, E.bottom = a.y, E.updateProjectionMatrix()
				}
				E = w.shadowMap, x = w.shadowMatrix, S = w.shadowCamera, S.position.setFromMatrixPosition(w.matrixWorld), l.setFromMatrixPosition(w.target.matrixWorld), S.lookAt(l), S.updateMatrixWorld(), S.matrixWorldInverse.getInverse(S.matrixWorld), w.cameraHelper && (w.cameraHelper.visible = w.shadowCameraVisible), w.shadowCameraVisible && w.cameraHelper.update(), x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(S.projectionMatrix), x.multiply(S.matrixWorldInverse), u.multiplyMatrices(S.projectionMatrix, S.matrixWorldInverse), o.setFromMatrix(u), t.setRenderTarget(E), t.clear(), C = p.__webglObjects, w = 0;
				for (E = C.length; w < E; w++) T = C[w], x = T.object, T.render = !1, !x.visible || !x.castShadow || (x instanceof THREE.Mesh || x instanceof THREE.ParticleSystem) && x.frustumCulled && !o.intersectsObject(x) || (x._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, x.matrixWorld), T.render = !0);
				w = 0;
				for (E = C.length; w < E; w++) T = C[w], T.render && (x = T.object, T = T.buffer, O = x.material instanceof THREE.MeshFaceMaterial ? x.material.materials[0] : x.material, N = void 0 !== x.geometry.morphTargets && 0 < x.geometry.morphTargets.length && O.morphTargets, O = x instanceof THREE.SkinnedMesh && O.skinning, N = x.customDepthMaterial ? x.customDepthMaterial : O ? N ? s : i : N ? r : n, T instanceof THREE.BufferGeometry ? t.renderBufferDirect(S, p.__lights, null, N, T, x) : t.renderBuffer(S, p.__lights, null, N, T, x));
				C = p.__webglObjectsImmediate, w = 0;
				for (E = C.length; w < E; w++) T = C[w], x = T.object, x.visible && x.castShadow && (x._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, x.matrixWorld), t.renderImmediateObject(S, p.__lights, null, n, x))
			}
			m = t.getClearColor(), y = t.getClearAlpha(), e.clearColor(m.r, m.g, m.b, y), e.enable(e.BLEND), t.shadowMapCullFace === THREE.CullFaceFront && e.cullFace(e.BACK)
		}
	}, THREE.ShadowMapPlugin.__projector = new THREE.Projector, THREE.SpritePlugin = function() {
		function g(e, t) {
			return e.z !== t.z ? t.z - e.z : t.id - e.id
		}
		var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, y, b, w, E, S, x, T, N;
		this.init = function(g) {
			y = g.context, b = g, E = new Float32Array([-0.5, -0.5, 0, 0, .5, -0.5, 1, 0, .5, .5, 1, 1, -0.5, .5, 0, 1]), S = new Uint16Array([0, 1, 2, 0, 2, 3]), x = y.createBuffer(), T = y.createBuffer(), y.bindBuffer(y.ARRAY_BUFFER, x), y.bufferData(y.ARRAY_BUFFER, E, y.STATIC_DRAW), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, T), y.bufferData(y.ELEMENT_ARRAY_BUFFER, S, y.STATIC_DRAW), g = y.createProgram();
			var C = y.createShader(y.VERTEX_SHADER),
				L = y.createShader(y.FRAGMENT_SHADER);
			y.shaderSource(C, ["precision " + b.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), y.shaderSource(L, ["precision " + b.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), y.compileShader(C), y.compileShader(L), y.attachShader(g, C), y.attachShader(g, L), y.linkProgram(g), N = g, v = y.getAttribLocation(N, "position"), m = y.getAttribLocation(N, "uv"), e = y.getUniformLocation(N, "uvOffset"), t = y.getUniformLocation(N, "uvScale"), n = y.getUniformLocation(N, "rotation"), r = y.getUniformLocation(N, "scale"), i = y.getUniformLocation(N, "color"), s = y.getUniformLocation(N, "map"), o = y.getUniformLocation(N, "opacity"), u = y.getUniformLocation(N, "modelViewMatrix"), a = y.getUniformLocation(N, "projectionMatrix"), f = y.getUniformLocation(N, "fogType"), l = y.getUniformLocation(N, "fogDensity"), c = y.getUniformLocation(N, "fogNear"), h = y.getUniformLocation(N, "fogFar"), p = y.getUniformLocation(N, "fogColor"), d = y.getUniformLocation(N, "alphaTest"), g = document.createElement("canvas"), g.width = 8, g.height = 8, C = g.getContext("2d"), C.fillStyle = "#ffffff", C.fillRect(0, 0, g.width, g.height), w = new THREE.Texture(g), w.needsUpdate = !0
		}, this.render = function(E, S, C, L) {
			C = E.__webglSprites;
			if (L = C.length) {
				y.useProgram(N), y.enableVertexAttribArray(v), y.enableVertexAttribArray(m), y.disable(y.CULL_FACE), y.enable(y.BLEND), y.bindBuffer(y.ARRAY_BUFFER, x), y.vertexAttribPointer(v, 2, y.FLOAT, !1, 16, 0), y.vertexAttribPointer(m, 2, y.FLOAT, !1, 16, 8), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, T), y.uniformMatrix4fv(a, !1, S.projectionMatrix.elements), y.activeTexture(y.TEXTURE0), y.uniform1i(s, 0);
				var A = 0,
					O = 0,
					M = E.fog;
				M ? (y.uniform3f(p, M.color.r, M.color.g, M.color.b), M instanceof THREE.Fog ? (y.uniform1f(c, M.near), y.uniform1f(h, M.far), y.uniform1i(f, 1), O = A = 1) : M instanceof THREE.FogExp2 && (y.uniform1f(l, M.density), y.uniform1i(f, 2), O = A = 2)) : (y.uniform1i(f, 0), O = A = 0);
				for (var _, P = [], M = 0; M < L; M++) _ = C[M], !1 !== _.visible && (_._modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, _.matrixWorld), _.z = -_._modelViewMatrix.elements[14]);
				C.sort(g);
				for (M = 0; M < L; M++) _ = C[M], !1 !== _.visible && (S = _.material, y.uniform1f(d, S.alphaTest), y.uniformMatrix4fv(u, !1, _._modelViewMatrix.elements), P[0] = _.scale.x, P[1] = _.scale.y, _ = E.fog && S.fog ? O : 0, A !== _ && (y.uniform1i(f, _), A = _), null !== S.map ? (y.uniform2f(e, S.map.offset.x, S.map.offset.y), y.uniform2f(t, S.map.repeat.x, S.map.repeat.y)) : (y.uniform2f(e, 0, 0), y.uniform2f(t, 1, 1)), y.uniform1f(o, S.opacity), y.uniform3f(i, S.color.r, S.color.g, S.color.b), y.uniform1f(n, S.rotation), y.uniform2fv(r, P), b.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst), b.setDepthTest(S.depthTest), b.setDepthWrite(S.depthWrite), S.map && S.map.image && S.map.image.width ? b.setTexture(S.map, 0) : b.setTexture(w, 0), y.drawElements(y.TRIANGLES, 6, y.UNSIGNED_SHORT, 0));
				y.enable(y.CULL_FACE)
			}
		}
	}, THREE.DepthPassPlugin = function() {
		this.enabled = !1, this.renderTarget = null;
		var e, t, n, r, i, s, o = new THREE.Frustum,
			u = new THREE.Matrix4;
		this.init = function(o) {
			e = o.context, t = o, o = THREE.ShaderLib.depthRGBA;
			var u = THREE.UniformsUtils.clone(o.uniforms);
			n = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u
			}), r = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				morphTargets: !0
			}), i = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				skinning: !0
			}), s = new THREE.ShaderMaterial({
				fragmentShader: o.fragmentShader,
				vertexShader: o.vertexShader,
				uniforms: u,
				morphTargets: !0,
				skinning: !0
			}), n._shadowPass = !0, r._shadowPass = !0, i._shadowPass = !0, s._shadowPass = !0
		}, this.render = function(e, t) {
			this.enabled && this.update(e, t)
		}, this.update = function(l, p) {
			var v, m, y, w, E, S;
			e.clearColor(1, 1, 1, 1), e.disable(e.BLEND), t.setDepthTest(!0), !0 === l.autoUpdate && l.updateMatrixWorld(), p.matrixWorldInverse.getInverse(p.matrixWorld), u.multiplyMatrices(p.projectionMatrix, p.matrixWorldInverse), o.setFromMatrix(u), t.setRenderTarget(this.renderTarget), t.clear(), S = l.__webglObjects, v = 0;
			for (m = S.length; v < m; v++) y = S[v], E = y.object, y.render = !1, !E.visible || (E instanceof THREE.Mesh || E instanceof THREE.ParticleSystem) && E.frustumCulled && !o.intersectsObject(E) || (E._modelViewMatrix.multiplyMatrices(p.matrixWorldInverse, E.matrixWorld), y.render = !0);
			var x;
			v = 0;
			for (m = S.length; v < m; v++) y = S[v], y.render && (E = y.object, y = y.buffer, E instanceof THREE.ParticleSystem && !E.customDepthMaterial || ((x = E.material instanceof THREE.MeshFaceMaterial ? E.material.materials[0] : E.material) && t.setMaterialFaces(E.material), w = 0 < E.geometry.morphTargets.length && x.morphTargets, x = E instanceof THREE.SkinnedMesh && x.skinning, w = E.customDepthMaterial ? E.customDepthMaterial : x ? w ? s : i : w ? r : n, y instanceof THREE.BufferGeometry ? t.renderBufferDirect(p, l.__lights, null, w, y, E) : t.renderBuffer(p, l.__lights, null, w, y, E)));
			S = l.__webglObjectsImmediate, v = 0;
			for (m = S.length; v < m; v++) y = S[v], E = y.object, E.visible && (E._modelViewMatrix.multiplyMatrices(p.matrixWorldInverse, E.matrixWorld), t.renderImmediateObject(p, l.__lights, null, n, E));
			v = t.getClearColor(), m = t.getClearAlpha(), e.clearColor(v.r, v.g, v.b, m), e.enable(e.BLEND)
		}
	}, THREE.ShaderFlares = {
		lensFlareVertexTexture: {
			vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
			fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
		},
		lensFlare: {
			vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
			fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
		}
	}, define("three", function() {}), define("threejs/OrbitControls", ["three"], function() {
		THREE.OrbitControls = function(e, t) {
			function k() {
				return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed
			}

			function L() {
				return Math.pow(.95, n.zoomSpeed)
			}

			function A(e) {
				if (n.enabled === !1) return;
				e.preventDefault();
				if (e.button === 0) {
					if (n.noRotate === !0) return;
					x = S.ROTATE, i.set(e.clientX, e.clientY)
				} else if (e.button === 1) {
					if (n.noZoom === !0) return;
					x = S.DOLLY, h.set(e.clientX, e.clientY)
				} else if (e.button === 2) {
					if (n.noPan === !0) return;
					x = S.PAN, u.set(e.clientX, e.clientY)
				}
				n.domElement.addEventListener("mousemove", O, !1), n.domElement.addEventListener("mouseup", M, !1), n.dispatchEvent(N)
			}

			function O(e) {
				if (n.enabled === !1) return;
				e.preventDefault();
				var t = n.domElement === document ? n.domElement.body : n.domElement;
				if (x === S.ROTATE) {
					if (n.noRotate === !0) return;
					s.set(e.clientX, e.clientY), o.subVectors(s, i), n.rotateLeft(2 * Math.PI * o.x / t.clientWidth * n.rotateSpeed), n.rotateUp(2 * Math.PI * o.y / t.clientHeight * n.rotateSpeed), i.copy(s), y = g, m = v
				} else if (x === S.DOLLY) {
					if (n.noZoom === !0) return;
					p.set(e.clientX, e.clientY), d.subVectors(p, h), d.y > 0 ? n.dollyIn() : n.dollyOut(), h.copy(p)
				} else if (x === S.PAN) {
					if (n.noPan === !0) return;
					a.set(e.clientX, e.clientY), f.subVectors(a, u), n.pan(f.x, f.y), u.copy(a)
				}
			}

			function M() {
				if (n.enabled === !1) return;
				n.domElement.removeEventListener("mousemove", O, !1), n.domElement.removeEventListener("mouseup", M, !1), n.dispatchEvent(C), x = S.NONE
			}

			function _(e) {
				if (n.enabled === !1 || n.noZoom === !0) return;
				e.preventDefault();
				var t = 0;
				e.wheelDelta !== undefined ? t = e.wheelDelta : e.detail !== undefined && (t = -e.detail), t > 0 ? n.dollyOut() : n.dollyIn(), n.dispatchEvent(N), n.dispatchEvent(C)
			}

			function D(e) {
				if (n.enabled === !1 || n.noKeys === !0 || n.noPan === !0) return;
				switch (e.keyCode) {
					case n.keys.UP:
						n.pan(0, n.keyPanSpeed);
						break;
					case n.keys.BOTTOM:
						n.pan(0, -n.keyPanSpeed);
						break;
					case n.keys.LEFT:
						n.pan(n.keyPanSpeed, 0);
						break;
					case n.keys.RIGHT:
						n.pan(-n.keyPanSpeed, 0)
				}
			}

			function P(e) {
				if (n.enabled === !1) return;
				switch (e.touches.length) {
					case 1:
						if (n.noRotate === !0) return;
						x = S.TOUCH_ROTATE, i.set(e.touches[0].pageX, e.touches[0].pageY);
						break;
					case 2:
						if (n.noZoom === !0) return;
						x = S.TOUCH_DOLLY;
						var t = e.touches[0].pageX - e.touches[1].pageX,
							r = e.touches[0].pageY - e.touches[1].pageY,
							s = Math.sqrt(t * t + r * r);
						h.set(0, s);
						break;
					case 3:
						if (n.noPan === !0) return;
						x = S.TOUCH_PAN, u.set(e.touches[0].pageX, e.touches[0].pageY);
						break;
					default:
						x = S.NONE
				}
				n.dispatchEvent(N)
			}

			function H(e) {
				if (n.enabled === !1) return;
				e.preventDefault(), e.stopPropagation();
				var t = n.domElement === document ? n.domElement.body : n.domElement;
				switch (e.touches.length) {
					case 1:
						if (n.noRotate === !0) return;
						if (x !== S.TOUCH_ROTATE) return;
						s.set(e.touches[0].pageX, e.touches[0].pageY), o.subVectors(s, i), n.rotateLeft(2 * Math.PI * o.x / t.clientWidth * n.rotateSpeed), n.rotateUp(2 * Math.PI * o.y / t.clientHeight * n.rotateSpeed), i.copy(s);
						break;
					case 2:
						if (n.noZoom === !0) return;
						if (x !== S.TOUCH_DOLLY) return;
						var r = e.touches[0].pageX - e.touches[1].pageX,
							l = e.touches[0].pageY - e.touches[1].pageY,
							c = Math.sqrt(r * r + l * l);
						p.set(0, c), d.subVectors(p, h), d.y > 0 ? n.dollyOut() : n.dollyIn(), h.copy(p);
						break;
					case 3:
						if (n.noPan === !0) return;
						if (x !== S.TOUCH_PAN) return;
						a.set(e.touches[0].pageX, e.touches[0].pageY), f.subVectors(a, u), n.pan(f.x, f.y), u.copy(a);
						break;
					default:
						x = S.NONE
				}
			}

			function B() {
				if (n.enabled === !1) return;
				n.dispatchEvent(C), x = S.NONE
			}
			this.object = e, this.domElement = t !== undefined ? t : document, this.paused = !1, this.enabled = !0, this.target = new THREE.Vector3, this.center = this.target, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = Infinity, this.noRotate = !1, this.rotateSpeed = 1, this.noPan = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.noKeys = !1, this.keys = {
				LEFT: 37,
				UP: 38,
				RIGHT: 39,
				BOTTOM: 40
			};
			var n = this,
				r = 1e-6,
				i = new THREE.Vector2,
				s = new THREE.Vector2,
				o = new THREE.Vector2,
				u = new THREE.Vector2,
				a = new THREE.Vector2,
				f = new THREE.Vector2,
				l = new THREE.Vector3,
				c = new THREE.Vector3,
				h = new THREE.Vector2,
				p = new THREE.Vector2,
				d = new THREE.Vector2,
				v = 0,
				m = 0,
				g = 0,
				y = 0,
				b = 1,
				w = new THREE.Vector3,
				E = new THREE.Vector3,
				S = {
					NONE: -1,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2,
					TOUCH_ROTATE: 3,
					TOUCH_DOLLY: 4,
					TOUCH_PAN: 5
				},
				x = S.NONE;
			this.target0 = this.target.clone(), this.position0 = this.object.position.clone();
			var T = {
					type: "change"
				},
				N = {
					type: "start"
				},
				C = {
					type: "end"
				};
			this.rotateLeft = function(e) {
				e === undefined && (e = k()), g -= e
			}, this.rotateUp = function(e) {
				e === undefined && (e = k()), v -= e
			}, this.panLeft = function(e) {
				var t = this.object.matrix.elements;
				l.set(t[0], t[1], t[2]), l.multiplyScalar(-e), w.add(l)
			}, this.panUp = function(e) {
				var t = this.object.matrix.elements;
				l.set(t[4], t[5], t[6]), l.multiplyScalar(e), w.add(l)
			}, this.pan = function(e, t) {
				var r = n.domElement === document ? n.domElement.body : n.domElement;
				if (n.object.fov !== undefined) {
					var i = n.object.position,
						s = i.clone().sub(n.target),
						o = s.length();
					o *= Math.tan(n.object.fov / 2 * Math.PI / 180), n.panLeft(2 * e * o / r.clientHeight), n.panUp(2 * t * o / r.clientHeight)
				} else n.object.top !== undefined ? (n.panLeft(e * (n.object.right - n.object.left) / r.clientWidth), n.panUp(t * (n.object.top - n.object.bottom) / r.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
			}, this.dollyIn = function(e) {
				e === undefined && (e = L()), b /= e
			}, this.dollyOut = function(e) {
				e === undefined && (e = L()), b *= e
			}, this.update = function() {
				if (this.paused) return;
				var e = this.object.position;
				c.copy(e).sub(this.target);
				var t = Math.atan2(c.x, c.z),
					n = Math.atan2(Math.sqrt(c.x * c.x + c.z * c.z), c.y);
				this.autoRotate && this.rotateLeft(k()), t += g, n += v, n = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, n)), n = Math.max(r, Math.min(Math.PI - r, n));
				var i = c.length() * b;
				i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(w), c.x = i * Math.sin(n) * Math.sin(t), c.y = i * Math.cos(n), c.z = i * Math.sin(n) * Math.cos(t), e.copy(this.target).add(c), this.object.lookAt(this.target), x == S.NONE ? (g = y *= .8, v = m *= .8) : (g = 0, v = 0), b = 1, w.set(0, 0, 0), E.distanceTo(this.object.position) > 0 && (this.dispatchEvent(T), E.copy(this.object.position))
			}, this.reset = function() {
				x = S.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.update()
			}, this.domElement.addEventListener("mousedown", A, !1), this.domElement.addEventListener("mousewheel", _, !1), this.domElement.addEventListener("DOMMouseScroll", _, !1), this.domElement.addEventListener("touchstart", P, !1), this.domElement.addEventListener("touchend", B, !1), this.domElement.addEventListener("touchmove", H, !1), window.addEventListener("keydown", D, !1)
		}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype)
	}), define("app/scene", ["jquery", "three", "threejs/OrbitControls"], function() {
		WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
		var e = new THREE.PerspectiveCamera(35, WIDTH / HEIGHT, 1, 1e4);
		e.position.x = -290, e.position.y = 80, e.position.z = -900, e.target = new THREE.Vector3(0, 80, 0), e.lookAt(e.target);
		var t = new THREE.Scene,
			n = new THREE.WebGLRenderer({
				antialias: !0
			});
		isMobile ? (n.setSize(WIDTH / 2, HEIGHT / 2), n.domElement.style.height = HEIGHT + "px", n.domElement.style.width = WIDTH + "px") : n.setSize(WIDTH, HEIGHT), n.autoClear = !1, n.shadowMapEnabled = !0, n.shadowMapSoft = !0, document.body.insertBefore(n.domElement, $(".exp-vortex")[0]), n.domElement.setAttribute("class", "gramophone"), n.domElement.style.opacity = 0, $(window).on("resize", function() {
			WIDTH = window.innerWidth, HEIGHT = window.innerHeight, isMobile ? (n.setSize(WIDTH / 2, HEIGHT / 2), n.domElement.style.height = HEIGHT + "px", n.domElement.style.width = WIDTH + "px") : n.setSize(WIDTH, HEIGHT), e.aspect = WIDTH / HEIGHT, e.updateProjectionMatrix()
		});
		var r = new THREE.OrbitControls(e);
		r.target = e.target, r.maxPolarAngle = Math.PI / 2, r.minDistance = 270, r.maxDistance = 1e3, r.noPan = !0, r.zoomSpeed = .3;
		var i = new THREE.PlaneGeometry(900, 900, 1, 1),
			s = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-floor.jpg")
			}),
			o = new THREE.Mesh(i, s);
		o.rotation.x = -Math.PI / 2, o.rotation.z = Math.PI * 3 / 4, o.receiveShadow = !0, t.add(o);
		var u = new THREE.PlaneGeometry(2e3, 2e3, 1, 1),
			a = new THREE.MeshBasicMaterial({
				color: 0
			}),
			f = new THREE.Mesh(u, a);
		f.position.y = -1, f.rotation.x = -Math.PI / 2, t.add(f);
		var l = new THREE.PlaneGeometry(1e3, 1e3, 1, 1);
		for (var c = 0; c < l.vertices.length; c++) l.vertices[c].z = -800;
		var h = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-background_001.jpg")
			}),
			p = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-background_002.jpg")
			}),
			d = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-background_003.jpg")
			}),
			v = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-background_004.jpg")
			}),
			m = new THREE.Mesh(l, v),
			g = new THREE.Mesh(l, p),
			y = new THREE.Mesh(l, d),
			b = new THREE.Mesh(l, h);
		m.position.y = 500, m.rotation.y = -0.3, t.add(m), g.position.y = 500, g.rotation.y = 1.3707963267948964, t.add(g), y.position.y = 500, y.rotation.y = 2.5415926535897926, t.add(y), b.position.y = 500, b.rotation.y = 4.812388980384689, t.add(b);
		var w = new THREE.SpotLight(16777215);
		w.position.set(212, 430, -314), w.castShadow = !0, w.angle = .434, w.shadowMapWidth = 1024, w.shadowMapHeight = 1024, w.shadowCameraNear = 400, w.shadowCameraFar = 1e3, w.shadowCameraFov = 40, w.shadowDarkness = 1, w.intensity = 1.1, w.distance = 1e3, w.exponent = 5, w.target.position.y = 115, t.add(w);
		var E = new THREE.DirectionalLight(16777215, .3);
		E.position.set(-310, 350, 200), t.add(E);
		var S = new THREE.DirectionalLight(16777215, .4);
		S.position.set(420, -60, 250), t.add(S);
		var x = new THREE.DirectionalLight(16777215, .2);
		x.position.set(480, 350, 330), t.add(x);
		var T = new THREE.DirectionalLight(16777215, .4);
		return T.position.set(175, -90, -390), t.add(T), {
			camera: e,
			scene: t,
			renderer: n,
			controls: r
		}
	}), define("app/winder", ["jquery", "app/pubsub"], function(e) {
		var t = function(t, n) {
			var r = this;
			r.id = n ? n : "wind", r.c = {
				x: WIDTH / 2,
				y: HEIGHT / 2
			};
			var i = function(e) {
					e.objectX && (r.c.x = e.objectX, r.c.y = e.objectY);
					var t = {
							x: e.clientX,
							y: e.clientY
						},
						n = Math.atan2(r.c.y - t.y, t.x - r.c.x);
					return n
				},
				s = function(t) {
					var n = i(t),
						s = function(t) {
							t = t.type == "touchmove" ? t.originalEvent.touches[0] : t;
							var s = i(t),
								o = s * 180 / Math.PI - n * 180 / Math.PI;
							o += o > 180 ? -360 : o < -180 ? 360 : 0, e.publish(r.id, [o]), n = s
						},
						o = function() {
							e(document).off("mousemove", s), e(document).off("mouseup", o), e(document).off("mouseleave", o), e(document).off("touchmove", s), e(document).off("touchend", o), e.publish(r.id + "end")
						};
					e(document).on("mousemove", s), e(document).on("mouseup", o), e(document).on("mouseleave", o), e(document).on("touchmove", s), e(document).on("touchend", o), e.publish(r.id + "start")
				};
			t.on("mousedown", s)
		};
		return t
	}), define("app/objects", ["jquery", "app/scene", "app/winder", "app/pubsub", "three"], function(e, t, n) {
		var r = t.camera,
			i = t.scene,
			s = t.renderer,
			o = {},
			u = new THREE.ShaderMaterial({
				uniforms: {
					tMatCap: {
						type: "t",
						value: THREE.ImageUtils.loadTexture("/matcap.jpg")
					}
				},
				vertexShader: ["varying vec2 vN;", "void main() {", "vec4 p = vec4( position, 1. );", "vec3 e = normalize( vec3( modelViewMatrix * p ) );", "vec3 n = normalize( normalMatrix * normal );", "vec3 r = reflect( e, n );", "float m = 2. * sqrt( ", "pow( r.x, 2. ) + ", "pow( r.y, 2. ) + ", "pow( r.z + 1., 2. ) ", ");", "vN = r.xy / m + .5;", "gl_Position = projectionMatrix * modelViewMatrix * p;", "}"].join("\n"),
				fragmentShader: ["uniform sampler2D tMatCap;", "varying vec2 vN;", "void main() {", "vec3 base = texture2D( tMatCap, vN ).rgb;", "gl_FragColor = vec4( base, 1. );", "}"].join("\n"),
				morphTargets: !0,
				shading: THREE.SmoothShading
			});
		u.uniforms.tMatCap.value.wrapS = u.uniforms.tMatCap.value.wrapT = THREE.ClampToEdgeWrapping;
		var a = new THREE.MeshPhongMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-cone.jpg"),
				bumpMap: THREE.ImageUtils.loadTexture("/txt-cone_bump.jpg"),
				specularMap: THREE.ImageUtils.loadTexture("/txt-cone_spec.jpg"),
				bumpScale: .5,
				specular: 7960953,
				shininess: 50
			}),
			f = new THREE.MeshPhongMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-box.jpg"),
				bumpMap: THREE.ImageUtils.loadTexture("/txt-box_bump.jpg"),
				specularMap: THREE.ImageUtils.loadTexture("/txt-box_spec.jpg"),
				bumpScale: .5,
				specular: 4473924,
				shininess: 100
			}),
			l = new THREE.MeshPhongMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-vinyl-001.jpg"),
				specular: 4473924
			}),
			c = new THREE.MeshPhongMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-metal.jpg"),
				bumpMap: THREE.ImageUtils.loadTexture("/txt-metal_bump.jpg"),
				bumpScale: .1,
				specular: 16777215,
				shininess: 8
			}),
			h = new THREE.MeshPhongMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-metal_dark.jpg"),
				specular: 4473924,
				shininess: 8
			}),
			p = new THREE.MeshPhongMaterial({
				color: 1118481,
				specular: 3355443,
				shininess: 10
			}),
			d = new THREE.MeshPhongMaterial({
				color: 16777215,
				specular: 3355443,
				shininess: 10
			}),
			v = new THREE.MeshPhongMaterial({
				color: 0,
				specularMap: THREE.ImageUtils.loadTexture("/txt-keyboard_spec.jpg"),
				specular: 7960953,
				shininess: 50
			});
		sceneMenu = new THREE.Scene, sceneMenuUI = new THREE.Scene;
		var m = new THREE.ShaderMaterial({
			uniforms: {
				linewidth: {
					type: "f",
					value: 1
				}
			},
			vertexShader: ["uniform float linewidth;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vec4 displacement = vec4( normalize( normalMatrix * normal ) * linewidth, 0.0 ) + mvPosition;", "gl_Position = projectionMatrix * displacement;", "}"].join("\n"),
			fragmentShader: ["void main() {", "gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );", "}"].join("\n")
		});
		m.side = THREE.BackSide;
		var g = new THREE.MeshBasicMaterial({
				color: 0
			}),
			y = function(e) {
				var t = e.clone(),
					n = e.clone();
				t.traverse(function(e) {
					e instanceof THREE.Mesh && (e.material = m)
				}), n.traverse(function(e) {
					e instanceof THREE.Mesh && (e.material = g)
				}), sceneMenu.add(t), sceneMenu.add(n), s.clear(), s.render(sceneMenu, r);
				var i = {},
					o = {};
				for (var u = 0; u < t.children.length; u++) i[t.children[u].name] = t.children[u];
				for (var u = 0; u < n.children.length; u++) o[n.children[u].name] = n.children[u];
				return [i, o]
			},
			b = new THREE.ObjectLoader;
		return b.load("/gramophone.js", function(t) {
			for (var n = 0; n < t.children.length; n++) {
				o[t.children[n].name] = t.children[n];
				switch (t.children[n].name) {
					case "arm":
						t.children[n].children[0].material = c, t.children[n].children[1].children[0].material = h, t.children[n].children[1].children[1].material = c;
						break;
					case "turntable":
						t.children[n].children[0].material = l, t.children[n].children[1].material = p;
						break;
					case "misc":
						t.children[n].children[0].material = c, t.children[n].children[1].material = f, t.children[n].children[2].material = h, t.children[n].children[3].material = p, t.children[n].children[4].material = p, t.children[n].children[5].material = p;
						break;
					case "manivelle":
						t.children[n].children[0].material = c, t.children[n].children[1].material = p;
						break;
					case "porte":
						t.children[n].children[0].material = f, t.children[n].children[1].material = c;
						break;
					case "cone":
						t.children[n].children[0].material = h, t.children[n].children[1].material = a;
						break;
					case "keyboard":
						t.children[n].children[0].material = p, t.children[n].children[1].material = c, t.children[n].children[2].material = v, t.children[n].children[2].children[7].material = c, t.children[n].children[2].children[0].material = d, t.children[n].children[2].children[1].material = d, t.children[n].children[2].children[2].material = d, t.children[n].children[2].children[3].material = d, t.children[n].children[2].children[4].material = d, t.children[n].children[2].children[5].material = d, t.children[n].children[2].children[6].material = d
				}
			}
			t.traverse(function(e) {
				e instanceof THREE.Mesh && (e.castShadow = !0)
			}), i.add(t);
			var r = [o].concat(y(t));
			e.publish("loadedObjects", r)
		}), o
	}), define("threejs/postprocessing/MaskPass", ["three"], function() {
		THREE.MaskPass = function(e, t) {
			this.scene = e, this.camera = t, this.enabled = !0, this.clear = !0, this.needsSwap = !1, this.inverse = !1
		}, THREE.MaskPass.prototype = {
			render: function(e, t, n, r) {
				var i = e.context;
				i.colorMask(!1, !1, !1, !1), i.depthMask(!1);
				var s, o;
				this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), i.enable(i.STENCIL_TEST), i.stencilOp(i.REPLACE, i.REPLACE, i.REPLACE), i.stencilFunc(i.ALWAYS, s, 4294967295), i.clearStencil(o), e.render(this.scene, this.camera, n, this.clear), e.render(this.scene, this.camera, t, this.clear), i.colorMask(!0, !0, !0, !0), i.depthMask(!0), i.stencilFunc(i.EQUAL, 1, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP)
			}
		}, THREE.ClearMaskPass = function() {
			this.enabled = !0
		}, THREE.ClearMaskPass.prototype = {
			render: function(e, t, n, r) {
				var i = e.context;
				i.disable(i.STENCIL_TEST)
			}
		}
	}), define("threejs/postprocessing/ShaderPass", ["three"], function() {
		THREE.ShaderPass = function(e, t) {
			this.textureID = t !== undefined ? t : "tDiffuse", this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({
				uniforms: this.uniforms,
				vertexShader: e.vertexShader,
				fragmentShader: e.fragmentShader
			}), this.renderToScreen = !1, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new THREE.Scene, this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null), this.scene.add(this.quad)
		}, THREE.ShaderPass.prototype = {
			render: function(e, t, n, r) {
				this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n), this.quad.material = this.material, this.renderToScreen ? e.render(this.scene, this.camera) : e.render(this.scene, this.camera, t, this.clear)
			}
		}
	}), define("threejs/shaders/CopyShader", ["three"], function() {
		THREE.CopyShader = {
			uniforms: {
				tDiffuse: {
					type: "t",
					value: null
				},
				opacity: {
					type: "f",
					value: 1
				}
			},
			vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
			fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
		}
	}), define("threejs/postprocessing/EffectComposer", ["three", "threejs/postprocessing/MaskPass", "threejs/postprocessing/ShaderPass", "threejs/shaders/CopyShader"], function() {
		THREE.EffectComposer = function(e, t) {
			this.renderer = e;
			if (t === undefined) {
				var n = window.innerWidth || 1,
					r = window.innerHeight || 1,
					i = {
						minFilter: THREE.LinearFilter,
						magFilter: THREE.LinearFilter,
						format: THREE.RGBAFormat,
						stencilBuffer: !1
					};
				t = new THREE.WebGLRenderTarget(n, r, i)
			}
			this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.passes = [], THREE.CopyShader === undefined && console.error("THREE.EffectComposer relies on THREE.CopyShader"), this.copyPass = new THREE.ShaderPass(THREE.CopyShader)
		}, THREE.EffectComposer.prototype = {
			swapBuffers: function() {
				var e = this.readBuffer;
				this.readBuffer = this.writeBuffer, this.writeBuffer = e
			},
			addPass: function(e) {
				this.passes.push(e)
			},
			insertPass: function(e, t) {
				this.passes.splice(t, 0, e)
			},
			render: function(e) {
				this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
				var t = !1,
					n, r, i = this.passes.length;
				for (r = 0; r < i; r++) {
					n = this.passes[r];
					if (!n.enabled) continue;
					n.render(this.renderer, this.writeBuffer, this.readBuffer, e, t);
					if (n.needsSwap) {
						if (t) {
							var s = this.renderer.context;
							s.stencilFunc(s.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), s.stencilFunc(s.EQUAL, 1, 4294967295)
						}
						this.swapBuffers()
					}
					n instanceof THREE.MaskPass ? t = !0 : n instanceof THREE.ClearMaskPass && (t = !1)
				}
			},
			reset: function(e) {
				e === undefined && (e = this.renderTarget1.clone(), e.width = window.innerWidth, e.height = window.innerHeight), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
			},
			setSize: function(e, t) {
				var n = this.renderTarget1.clone();
				n.width = e, n.height = t, this.reset(n)
			}
		}
	}), define("threejs/postprocessing/RenderPass", ["three"], function() {
		THREE.RenderPass = function(e, t, n, r, i) {
			this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = i !== undefined ? i : 1, this.oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.enabled = !0, this.clear = !0, this.needsSwap = !1
		}, THREE.RenderPass.prototype = {
			render: function(e, t, n, r) {
				this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (this.oldClearColor.copy(e.getClearColor()), this.oldClearAlpha = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), e.render(this.scene, this.camera, n, this.clear), this.clearColor && e.setClearColor(this.oldClearColor, this.oldClearAlpha), this.scene.overrideMaterial = null
			}
		}
	}), define("threejs/postprocessing/DotScreenPass", ["three"], function() {
		THREE.DotScreenPass = function(e, t, n) {
			THREE.DotScreenShader === undefined && console.error("THREE.DotScreenPass relies on THREE.DotScreenShader");
			var r = THREE.DotScreenShader;
			this.uniforms = THREE.UniformsUtils.clone(r.uniforms), e !== undefined && this.uniforms.center.value.copy(e), t !== undefined && (this.uniforms.angle.value = t), n !== undefined && (this.uniforms.scale.value = n), this.material = new THREE.ShaderMaterial({
				uniforms: this.uniforms,
				vertexShader: r.vertexShader,
				fragmentShader: r.fragmentShader
			}), this.enabled = !0, this.renderToScreen = !1, this.needsSwap = !0, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new THREE.Scene, this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null), this.scene.add(this.quad)
		}, THREE.DotScreenPass.prototype = {
			render: function(e, t, n, r) {
				this.uniforms.tDiffuse.value = n, this.uniforms.tSize.value.set(n.width, n.height), this.quad.material = this.material, this.renderToScreen ? e.render(this.scene, this.camera) : e.render(this.scene, this.camera, t, !1)
			}
		}
	}), define("threejs/shaders/MenuShader", ["three"], function() {
		THREE.MenuShader = {
			uniforms: {
				tDiffuse: {
					type: "t",
					value: null
				},
				tPattern: {
					type: "t",
					value: null
				},
				opacity: {
					type: "f",
					value: null
				},
				patternSize: {
					type: "f",
					value: null
				},
				resolution: {
					type: "v2",
					value: new THREE.Vector2
				}
			},
			vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
			fragmentShader: ["uniform sampler2D tDiffuse;", "uniform sampler2D tPattern;", "uniform float opacity;", "varying vec2 vUv;", "void main(){", "gl_FragColor = opacity * texture2D(tPattern, vUv) + (1.0 - opacity) * texture2D(tDiffuse, vUv);", "}"].join("\n")
		}
	}), define("threejs/shaders/DotScreenShader", ["three"], function() {
		THREE.DotScreenShader = {
			uniforms: {
				tDiffuse: {
					type: "t",
					value: null
				},
				tSize: {
					type: "v2",
					value: new THREE.Vector2(256, 256)
				},
				center: {
					type: "v2",
					value: new THREE.Vector2(.5, .5)
				},
				angle: {
					type: "f",
					value: 1.57
				},
				scale: {
					type: "f",
					value: 1
				}
			},
			vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
			fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "float s = sin( angle ), c = cos( angle );", "vec2 tex = vUv * tSize - center;", "vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "float average = ( color.r + color.g + color.b ) / 3.0;", "gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")
		}
	}), define("easing", [], function() {
		easing = {
			linear: function(e, t, n, r) {
				return e == 0 ? t : n * (e /= r) + t
			},
			easeInQuad: function(e, t, n, r) {
				return n * (e /= r) * e + t
			},
			easeOutQuad: function(e, t, n, r) {
				return -n * (e /= r) * (e - 2) + t
			},
			easeInOutQuad: function(e, t, n, r) {
				return (e /= r / 2) < 1 ? n / 2 * e * e + t : -n / 2 * (--e * (e - 2) - 1) + t
			},
			easeInCubic: function(e, t, n, r) {
				return n * (e /= r) * e * e + t
			},
			easeOutCubic: function(e, t, n, r) {
				return n * ((e = e / r - 1) * e * e + 1) + t
			},
			easeInOutCubic: function(e, t, n, r) {
				return (e /= r / 2) < 1 ? n / 2 * e * e * e + t : n / 2 * ((e -= 2) * e * e + 2) + t
			},
			easeInQuart: function(e, t, n, r) {
				return n * (e /= r) * e * e * e + t
			},
			easeOutQuart: function(e, t, n, r) {
				return -n * ((e = e / r - 1) * e * e * e - 1) + t
			},
			easeInOutQuart: function(e, t, n, r) {
				return (e /= r / 2) < 1 ? n / 2 * e * e * e * e + t : -n / 2 * ((e -= 2) * e * e * e - 2) + t
			},
			easeInQuint: function(e, t, n, r) {
				return n * (e /= r) * e * e * e * e + t
			},
			easeOutQuint: function(e, t, n, r) {
				return n * ((e = e / r - 1) * e * e * e * e + 1) + t
			},
			easeInOutQuint: function(e, t, n, r) {
				return (e /= r / 2) < 1 ? n / 2 * e * e * e * e * e + t : n / 2 * ((e -= 2) * e * e * e * e + 2) + t
			},
			easeInSine: function(e, t, n, r) {
				return -n * Math.cos(e / r * (Math.PI / 2)) + n + t
			},
			easeOutSine: function(e, t, n, r) {
				return n * Math.sin(e / r * (Math.PI / 2)) + t
			},
			easeInOutSine: function(e, t, n, r) {
				return -n / 2 * (Math.cos(Math.PI * e / r) - 1) + t
			},
			easeInExpo: function(e, t, n, r) {
				return e == 0 ? t : n * Math.pow(2, 10 * (e / r - 1)) + t
			},
			easeOutExpo: function(e, t, n, r) {
				return e == r ? t + n : n * (-Math.pow(2, -10 * e / r) + 1) + t
			},
			easeInOutExpo: function(e, t, n, r) {
				return e == 0 ? t : e == r ? t + n : (e /= r / 2) < 1 ? n / 2 * Math.pow(2, 10 * (e - 1)) + t : n / 2 * (-Math.pow(2, -10 * --e) + 2) + t
			},
			easeInCirc: function(e, t, n, r) {
				return -n * (Math.sqrt(1 - (e /= r) * e) - 1) + t
			},
			easeOutCirc: function(e, t, n, r) {
				return n * Math.sqrt(1 - (e = e / r - 1) * e) + t
			},
			easeInOutCirc: function(e, t, n, r) {
				return (e /= r / 2) < 1 ? -n / 2 * (Math.sqrt(1 - e * e) - 1) + t : n / 2 * (Math.sqrt(1 - (e -= 2) * e) + 1) + t
			},
			easeInElastic: function(e, t, n, r) {
				var i = 1.70158,
					s = 0,
					o = n;
				if (e == 0) return t;
				if ((e /= r) == 1) return t + n;
				s || (s = r * .3);
				if (o < Math.abs(n)) {
					o = n;
					var i = s / 4
				} else var i = s / (2 * Math.PI) * Math.asin(n / o);
				return -(o * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * r - i) * 2 * Math.PI / s)) + t
			},
			easeOutElastic: function(e, t, n, r) {
				var i = 1.70158,
					s = 0,
					o = n;
				if (e == 0) return t;
				if ((e /= r) == 1) return t + n;
				s || (s = r * .3);
				if (o < Math.abs(n)) {
					o = n;
					var i = s / 4
				} else var i = s / (2 * Math.PI) * Math.asin(n / o);
				return o * Math.pow(2, -10 * e) * Math.sin((e * r - i) * 2 * Math.PI / s) + n + t
			},
			easeInOutElastic: function(e, t, n, r) {
				var i = 1.70158,
					s = 0,
					o = n;
				if (e == 0) return t;
				if ((e /= r / 2) == 2) return t + n;
				s || (s = r * .3 * 1.5);
				if (o < Math.abs(n)) {
					o = n;
					var i = s / 4
				} else var i = s / (2 * Math.PI) * Math.asin(n / o);
				return e < 1 ? -0.5 * o * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * r - i) * 2 * Math.PI / s) + t : o * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * r - i) * 2 * Math.PI / s) * .5 + n + t
			},
			easeInBack: function(e, t, n, r, i) {
				return i == undefined && (i = 1.70158), n * (e /= r) * e * ((i + 1) * e - i) + t
			},
			easeOutBack: function(e, t, n, r, i) {
				return i == undefined && (i = 1.70158), n * ((e = e / r - 1) * e * ((i + 1) * e + i) + 1) + t
			},
			easeInOutBack: function(e, t, n, r, i) {
				return i == undefined && (i = 1.70158), (e /= r / 2) < 1 ? n / 2 * e * e * (((i *= 1.525) + 1) * e - i) + t : n / 2 * ((e -= 2) * e * (((i *= 1.525) + 1) * e + i) + 2) + t
			},
			easeInBounce: function(e, t, n, r) {
				return n - easing.easeOutBounce(r - e, 0, n, r) + t
			},
			easeOutBounce: function(e, t, n, r) {
				return (e /= r) < 1 / 2.75 ? n * 7.5625 * e * e + t : e < 2 / 2.75 ? n * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? n * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : n * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
			}
		}
	}), define("app/expVortex", ["jquery", "app/scene", "three", "app/pubsub", "easing"], function(e, t) {
		function N(e) {
			var t = new THREE.Mesh(a, u);
			return t.position.x = 15 * Math.sin(e / (Math.PI * (l / 20))), t.position.y = 15 * Math.cos(e / (Math.PI * (l / 20))), t.position.z = -e * (c / l), t
		}
		var n = t.camera,
			r = t.scene,
			i = t.renderer,
			s = !1,
			o = function() {};
		sceneVortex = new THREE.Scene, sceneVortex.fog = new THREE.Fog(0, 0, 500);
		var u = new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-vortex.jpg")
			}),
			a = new THREE.TorusGeometry(50, 20, 2, 32),
			f = function(e) {
				e.computeBoundingBox();
				var t = e.boundingBox.max,
					n = e.boundingBox.min,
					r = new THREE.Vector2(0 - n.x, 0 - n.y),
					i = new THREE.Vector2(t.x - n.x, t.y - n.y);
				e.faceVertexUvs[0] = [];
				for (S = 0; S < e.faces.length; S++) {
					var s = e.vertices[e.faces[S].a],
						o = e.vertices[e.faces[S].b],
						u = e.vertices[e.faces[S].c];
					e.faceVertexUvs[0].push([new THREE.Vector2((s.x + r.x) / i.x, (s.y + r.y) / i.y), new THREE.Vector2((o.x + r.x) / i.x, (o.y + r.y) / i.y), new THREE.Vector2((u.x + r.x) / i.x, (u.y + r.y) / i.y)])
				}
				e.uvsNeedUpdate = !0
			};
		f(a);
		var l = 100,
			c = 500,
			h = 0,
			p = 5,
			d = 0,
			v = [],
			m = new THREE.Object3D;
		m.position.set(111, 159, 126), m.quaternion.setFromEuler(new THREE.Euler(-1.14, 1.25, 1.19, "XYZ")), sceneVortex.add(m);
		var g = [],
			y = ["/txt-vortex-part-001.png", "/txt-vortex-part-002.png", "/txt-vortex-part-003.png", "/txt-vortex-part-004.png", "/txt-vortex-part-005.png", "/txt-vortex-part-006.png", "/txt-vortex-part-007.png"],
			b = [.5, .7, 1, .4, .2, .5, 1],
			w = function(e) {
				e.rotation.z = Math.random() * Math.PI * 2, e.position.z = Math.random() * -c - c, e.position.x = Math.random() * 26 - 13, e.position.y = Math.random() * 26 - 13, e.rotationSpeed = Math.random() * .2 - .1, e.vortexSpeed = Math.random() * .8 + .2
			},
			E = new THREE.PlaneGeometry(10, 10);
		for (var S = 0; S < y.length; S++) {
			var x = new THREE.MeshBasicMaterial({
					map: THREE.ImageUtils.loadTexture(y[S]),
					transparent: !0
				}),
				T = new THREE.Mesh(E, x);
			T.scale.set(b[S], b[S], b[S]), w(T), m.add(T), g.push(T)
		}
		for (var S = 0; S < l; S++) {
			var C = N(S);
			v.push(C), m.add(C)
		}
		var k = {
				z: 113,
				y: 135
			},
			L = {
				z: k.z,
				y: k.y,
				active: !1
			},
			A = function(e) {
				var t = {
						x: WIDTH / 2,
						y: HEIGHT / 2
					},
					n = {
						x: e.clientX - t.x,
						y: e.clientY - t.y
					},
					r = {
						x: n.x / t.x,
						y: n.y / t.y
					};
				L.z = k.z + r.x * 13, L.y = k.y + r.y * 13
			},
			O = 0,
			M = new Uint8Array(16),
			_ = !1,
			D = !1,
			P = function() {
				if (!s) return;
				for (var e = 0; e < g.length; e++) g[e].position.z += p * g[e].vortexSpeed, g[e].rotation.z += g[e].rotationSpeed, g[e].position.z >= 0 && w(g[e]);
				for (var e = 0; e < v.length; e++) v[e].position.z += p, v[e].position.z >= 0 && (v[e].position.z -= c, h = 30 * Math.sin(d / (50 * Math.PI)), O += h, v[e].rotation.z = O * Math.PI / 180, d++);
				if (L.active) {
					audio.analyser.getByteFrequencyData(M);
					if (M[0] > 80) {
						if (!_) {
							var t = n.target.z,
								r = 0;
							D = !D;
							var i = D,
								o = function() {
									if (i !== D) return;
									if (r > 30) {
										p = 5;
										return
									}
									requestAnimationFrame(o), p = 5 + 5 * (30 - r) / 30, r++
								};
							o()
						}
						_ = !0
					} else _ = !1;
					n.position.z += (L.z - n.position.z) / 10, n.position.y += (L.y - n.position.y) / 10, n.lookAt(n.target)
				}
			},
			H = function(t) {
				s = !0, e(".interface .menu-prompt")[0].style.display = "none", e.publish("intube");
				var r = function(t, i) {
					if (i != "vortex") return;
					e.unsubscribe("cameraAnimEnd", r), e.publish("vortexEnter"), o.animate({
						position: new THREE.Vector3(31, 135, 113),
						target: new THREE.Vector3(-40, 110, 100),
						duration: 120,
						ease: "easeInOutQuint"
					});
					var s = -1,
						u = 200,
						a, f, l = !1,
						c = function() {
							s++;
							if (l) return;
							if (s >= u) {
								e(document).on("mousemove", A), L.active = !0, e(".exp-vortex")[0].style.display = "block", e(".exp-vortex .close-prompt").on("click", B);
								return
							}
							requestAnimationFrame(c), a = 60, f = 50, s >= a && s <= a + f, a = 70, f = 130, s >= a && s <= a + f && n.projectionMatrix.makePerspective(easing.easeOutSine(s - a, 35, 45, f), WIDTH / HEIGHT, 1, 1e4)
						};
					c()
				};
				e.subscribe("cameraAnimEnd", r)
			},
			B = function() {
				e(".exp-vortex")[0].style.display = "none", e(".exp-vortex .close-prompt").off("click", B), e(".interface .menu-prompt")[0].style.display = "block", e.publish("vortexExit"), L.active = !1, e(document).off("mousemove", A);
				var t = -1,
					r = 80,
					i, u, a = !1,
					f = function() {
						t++;
						if (a) return;
						if (t >= r) {
							s = !1, e.publish("resetViewport", []), e.publish("intube");
							return
						}
						t == 20 && o.animate({
							position: new THREE.Vector3(380, 260, 180),
							target: new THREE.Vector3(-40, 110, 100),
							duration: 60,
							ease: "easeInOutQuad"
						}), requestAnimationFrame(f), i = 0, u = 50, t >= i && t <= i + u, i = 0, u = 50, t >= i && t <= i + u && n.projectionMatrix.makePerspective(easing.easeOutSine(t - i, 80, -45, u), WIDTH / HEIGHT, 1, 1e4)
					};
				f()
			};
		return {
			cone: function(e, t) {
				e.on("mousedown", H), o = t
			},
			update: P
		}
	}), define("app/render", ["jquery", "app/scene", "app/objects", "three", "threejs/postprocessing/EffectComposer", "threejs/postprocessing/RenderPass", "threejs/postprocessing/DotScreenPass", "threejs/shaders/MenuShader", "threejs/shaders/DotScreenShader", "app/expVortex"], function(e, t) {
		var n = t.camera,
			r = t.scene,
			i = t.renderer,
			s = {
				minFilter: THREE.LinearFilter,
				magFilter: THREE.LinearFilter,
				format: THREE.RGBAFormat,
				stencilBuffer: !1
			},
			o = new THREE.WebGLRenderTarget(WIDTH, HEIGHT, s),
			u = new THREE.EffectComposer(i),
			a = new THREE.RenderPass(r, n);
		a.clearColor = 0, a.clearAlpha = 0, u.addPass(a);
		var f = new THREE.ShaderPass(THREE.MenuShader);
		i.render(sceneVortex, n, o, !0), f.uniforms.tPattern.value = o, f.uniforms.opacity.value = 0, f.renderToScreen = !0, u.addPass(f);
		var l = new THREE.EffectComposer(i),
			a = new THREE.RenderPass(r, n);
		l.addPass(a);
		var c = new THREE.ShaderPass(THREE.DotScreenShader);
		c.uniforms.scale.value = 2, c.renderToScreen = !0, l.addPass(c);
		var h = !1,
			p = !1,
			d = !1,
			v = !1,
			m = 0,
			g = !1,
			y = function(e) {
				g = !g;
				var t = -1,
					n = e ? 120 : 60,
					r = e ? 40 : 0,
					i = e ? 80 : n,
					s = g,
					o = function() {
						t++;
						if (s !== g) return;
						if (t >= n) {
							e ? (d = !0, p = !1) : p = !1;
							return
						}
						requestAnimationFrame(o), t >= r && t <= r + i && (m = e ? easing.easeInSine(t - r, 0, 1, i) : easing.easeInSine(t - r, 1, -1, i))
					};
				o()
			};
		e.subscribe("menuRender", function() {
			h = !h
		}), e.subscribe("vortexEnter", function() {
			p = !0, y(!0)
		}), e.subscribe("vortexExit", function() {
			y(!1), d = !1, p = !0
		}), e.subscribe("dotRenderOn", function() {
			v = !0
		}), e.subscribe("dotRenderOff", function() {
			v = !1
		});
		var b = function() {
			h ? (i.clear(), i.render(sceneMenu, n), i.clear(!1, !0, !1), i.render(sceneMenuUI, n)) : p ? (i.render(sceneVortex, n, o, !0), f.uniforms.tPattern.value = o, f.uniforms.opacity.value = m, u.render()) : d ? (i.clear(), i.render(sceneVortex, n)) : v ? l.render() : (i.clear(), i.render(r, n))
		};
		return b
	}), define("app/slider", ["jquery", "app/pubsub"], function(e) {
		var t = function(t) {
				var n = {
						x: t.clientX,
						y: t.clientY
					},
					r = function(t) {
						t = t.type == "touchmove" ? t.originalEvent.touches[0] : t;
						var r = {
								x: t.clientX,
								y: t.clientY
							},
							i = {
								x: r.x - n.x,
								y: r.y - n.y
							};
						e.publish("slider", [i]), n = {
							x: t.clientX,
							y: t.clientY
						}
					},
					i = function() {
						e(document).off("mousemove", r), e(document).off("mouseup", i), e(document).off("mouseleave", i), e(document).off("touchmove", r), e(document).off("touchend", i), e.publish("sliderend")
					};
				e(document).on("mousemove", r), e(document).on("mouseup", i), e(document).on("touchmove", r), e(document).on("touchend", i), e(document).on("mouseleave", i), e.publish("sliderstart")
			},
			n = function(e) {
				e.on("mousedown", t)
			};
		return n
	}), define("app/cameraAnimation", ["jquery", "three", "app/pubsub"], function(e) {
		var t = function(t) {
			var n = this;
			n.currentAnimation = !1;
			var r = t.camera,
				i = t.controls;
			this.animate = function(t) {
				var s = t.position,
					o = t.target,
					u = t.duration ? t.duration : 100,
					a = t.restartControl ? t.restartControl : !1,
					f = t.ease ? t.ease : "easeInOutExpo",
					l = t.id ? t.id : "all",
					c = t.spin ? t.spin : !1;
				i.paused = !0, i.enabled = !1;
				var h = r.position.clone(),
					p = s,
					d = r.target.clone(),
					v = o;
				n.currentAnimation = !n.currentAnimation;
				var m = n.currentAnimation,
					g = -1,
					y = u,
					b = function() {
						g++;
						if (m != n.currentAnimation) return;
						if (g >= y) {
							a && (i.paused = !1, i.enabled = !0), e.publish("cameraAnimEnd", [l]);
							return
						}
						requestAnimationFrame(b), r.position.x = easing[f](g, h.x, p.x - h.x, y), r.position.y = easing[f](g, h.y, p.y - h.y, y), r.position.z = easing[f](g, h.z, p.z - h.z, y), r.target.x = easing[f](g, d.x, v.x - d.x, y), r.target.y = easing[f](g, d.y, v.y - d.y, y), r.target.z = easing[f](g, d.z, v.z - d.z, y), r.lookAt(r.target)
					};
				b()
			}
		};
		return t
	}), define("app/expVinyl", ["jquery", "app/winder", "three", "app/pubsub"], function(e, t) {
		var n = undefined,
			r = undefined,
			i = !1,
			s = 0,
			o = ["/txt-vinyl-001.jpg", "/txt-vinyl-002.jpg", "/txt-vinyl-003.jpg", "/txt-vinyl-004.jpg", "/txt-vinyl-005.jpg", "/txt-vinyl-006.jpg"],
			u = [],
			a = undefined;
		a = document.createElement("canvas"), a.width = 1024, a.height = 1024;
		var f = new THREE.Texture(a),
			l = new THREE.MeshPhongMaterial({
				map: f,
				bumpMap: THREE.ImageUtils.loadTexture("/txt-vinyl_bump.jpg"),
				specularMap: THREE.ImageUtils.loadTexture("/txt-vinyl_spec.jpg"),
				bumpScale: .2,
				specular: 4473924,
				shininess: 100
			}),
			c = function(e, t) {
				var n = a.getContext("2d");
				n.save(), n.beginPath(), n.arc(512, 512, t, 0, 2 * Math.PI, !1), n.clip(), n.drawImage(u[e], 0, 0, 1024, 1024), n.restore(), f.needsUpdate = !0
			},
			h = function(e) {
				var t = new Image;
				t.onload = function() {
					u.push(t), u.length == o.length && c(0, 730)
				}, t.src = e
			};
		for (var p = 0; p < o.length; p++) h(o[p]);
		var d = function(e) {
				E = !0;
				var t = 0,
					n = 724.0773439350247,
					r = function() {
						if (t > n) return;
						requestAnimationFrame(r), t += 10, c(e, t)
					};
				r()
			},
			v = -Math.PI / 180 * 10,
			m = function(t, n) {
				r.rotation.y += n * Math.PI / 180, v = n * Math.PI / 180;
				var i = Math.abs(n / 10);
				i == 0 && (i = .001), audio.source.playbackRate.value = i, audio.beatSource.playbackRate.value = audio.source.playbackRate.value;
				if (n < -50 || n > 50) e(document).trigger("mouseup"), s++, s >= u.length && (s = 0), d(s)
			};
		e.subscribe("vinyl", m);
		var g = !0;
		e.subscribe("vinylstart", function() {
			g = !1, e(".gramophone").css("cursor", "url(/cur-scratch2.png) 20 110, auto")
		}), e.subscribe("vinylend", function() {
			g = !0, e(".gramophone").css("cursor", "url(/cur-scratch.png) 20 110, auto")
		});
		var y = function(r) {
				i = !0, e(".exp-vinyl")[0].style.display = "block", e(".interface .menu-prompt")[0].style.display = "none", e(".exp-vinyl .close-prompt").on("click", b), new t(n, "vinyl")
			},
			b = function() {
				clearTimeout(w), i = !1, e(".exp-vinyl")[0].style.display = "none", e(".interface .menu-prompt")[0].style.display = "block", e.publish("resetViewport", []), n.off(), n.on("mousedown", S), audio.source.playbackRate.value = 1, audio.beatSource.playbackRate.value = 1
			},
			w, E = !1,
			S = function(t) {
				i || (E || (w = setTimeout(function() {
					E || e.publish("messageOn", ["Spin faster!!<br />Goddammit!", "img-char_003.png", 200])
				}, 6e3)), y(t), v = -Math.PI / 180 * 10)
			},
			x = function() {
				if (!audio) return;
				if (i) {
					if (!g) return;
					r.rotation.y += v *= .9, audio.source.playbackRate.value = 1, audio.beatSource.playbackRate.value = 1;
					return
				}
				if (!r) return;
				r.rotation.y -= audio.source.playbackRate.value * Math.PI / 180 * 10
			},
			T = function() {
				x()
			};
		return {
			vinyl: function(e, t) {
				e.on("mousedown", S), r = t, n = e, r.children[0].material = l
			},
			update: T
		}
	}), (window._gsQueue || (window._gsQueue = [])).push(function() {
		window._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, n) {
				var r = [].slice,
					i = function(e, t, r) {
						n.call(this, e, t, r), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = i.prototype.render
					},
					s = 1e-10,
					o = n._internals,
					u = o.isSelector,
					a = o.isArray,
					f = i.prototype = n.to({}, .1, {}),
					l = [];
				i.version = "1.12.1", f.constructor = i, f.kill()._gc = !1, i.killTweensOf = i.killDelayedCallsTo = n.killTweensOf, i.getTweensOf = n.getTweensOf, i.lagSmoothing = n.lagSmoothing, i.ticker = n.ticker, i.render = n.render, f.invalidate = function() {
					return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), n.prototype.invalidate.call(this)
				}, f.updateTo = function(e, t) {
					var r, i = this.ratio;
					t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
					for (r in e) this.vars[r] = e[r];
					if (this._initted)
						if (t) this._initted = !1;
						else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
						var s = this._time;
						this.render(0, !0, !1), this._initted = !1, this.render(s, !0, !1)
					} else if (this._time > 0) {
						this._initted = !1, this._init();
						for (var o, u = 1 / (1 - i), a = this._firstPT; a;) o = a.s + a.c, a.c *= u, a.s = o - a.c, a = a._next
					}
					return this
				}, f.render = function(e, t, n) {
					this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
					var r, i, u, a, f, c, h, p, d = this._dirty ? this.totalDuration() : this._totalDuration,
						v = this._time,
						m = this._totalTime,
						g = this._cycle,
						y = this._duration,
						b = this._rawPrevTime;
					if (e >= d ? (this._totalTime = d, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, i = "onComplete"), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > b || b === s) && b !== e && (n = !0, b > s && (i = "onReverseComplete")), this._rawPrevTime = p = !t || e || b === e ? e : s)) : 1e-7 > e ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === y && b > 0 && b !== s) && (i = "onReverseComplete", r = this._reversed), 0 > e ? (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (b >= 0 && (n = !0), this._rawPrevTime = p = !t || e || b === e ? e : s)) : this._initted || (n = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (a = y + this._repeatDelay, this._cycle = this._totalTime / a >> 0, 0 !== this._cycle && this._cycle === this._totalTime / a && this._cycle--, this._time = this._totalTime - this._cycle * a, this._yoyo && 0 !== (1 & this._cycle) && (this._time = y - this._time), this._time > y ? this._time = y : 0 > this._time && (this._time = 0)), this._easeType ? (f = this._time / y, c = this._easeType, h = this._easePower, (1 === c || 3 === c && f >= .5) && (f = 1 - f), 3 === c && (f *= 2), 1 === h ? f *= f : 2 === h ? f *= f * f : 3 === h ? f *= f * f * f : 4 === h && (f *= f * f * f * f), this.ratio = 1 === c ? 1 - f : 2 === c ? f : .5 > this._time / y ? f / 2 : 1 - f / 2) : this.ratio = this._ease.getRatio(this._time / y)), v === this._time && !n && g === this._cycle) return m !== this._totalTime && this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)), void 0;
					if (!this._initted) {
						if (this._init(), !this._initted || this._gc) return;
						if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = v, this._totalTime = m, this._rawPrevTime = b, this._cycle = g, o.lazyTweens.push(this), this._lazy = e, void 0;
						this._time && !r ? this.ratio = this._ease.getRatio(this._time / y) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
					}
					for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== v && e >= 0 && (this._active = !0), 0 === m && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === y) && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || l))), u = this._firstPT; u;) u.f ? u.t[u.p](u.c * this.ratio + u.s) : u.t[u.p] = u.c * this.ratio + u.s, u = u._next;
					this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, n), t || (this._totalTime !== m || r) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)), this._cycle !== g && (t || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || l)), i && (this._gc || (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this.vars[i].apply(this.vars[i + "Scope"] || this, this.vars[i + "Params"] || l), 0 === y && this._rawPrevTime === s && p !== s && (this._rawPrevTime = 0)))
				}, i.to = function(e, t, n) {
					return new i(e, t, n)
				}, i.from = function(e, t, n) {
					return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new i(e, t, n)
				}, i.fromTo = function(e, t, n, r) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new i(e, t, r)
				}, i.staggerTo = i.allTo = function(e, t, s, o, f, c, h) {
					o = o || 0;
					var p, d, v, m, g = s.delay || 0,
						y = [],
						b = function() {
							s.onComplete && s.onComplete.apply(s.onCompleteScope || this, arguments), f.apply(h || this, c || l)
						};
					for (a(e) || ("string" == typeof e && (e = n.selector(e) || e), u(e) && (e = r.call(e, 0))), p = e.length, v = 0; p > v; v++) {
						d = {};
						for (m in s) d[m] = s[m];
						d.delay = g, v === p - 1 && f && (d.onComplete = b), y[v] = new i(e[v], t, d), g += o
					}
					return y
				}, i.staggerFrom = i.allFrom = function(e, t, n, r, s, o, u) {
					return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, i.staggerTo(e, t, n, r, s, o, u)
				}, i.staggerFromTo = i.allFromTo = function(e, t, n, r, s, o, u, a) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, i.staggerTo(e, t, r, s, o, u, a)
				}, i.delayedCall = function(e, t, n, r, s) {
					return new i(t, 0, {
						delay: e,
						onComplete: t,
						onCompleteParams: n,
						onCompleteScope: r,
						onReverseComplete: t,
						onReverseCompleteParams: n,
						onReverseCompleteScope: r,
						immediateRender: !1,
						useFrames: s,
						overwrite: 0
					})
				}, i.set = function(e, t) {
					return new i(e, 0, t)
				}, i.isTweening = function(e) {
					return n.getTweensOf(e, !0).length > 0
				};
				var c = function(e, t) {
						for (var r = [], i = 0, s = e._first; s;) s instanceof n ? r[i++] = s : (t && (r[i++] = s), r = r.concat(c(s, t)), i = r.length), s = s._next;
						return r
					},
					h = i.getAllTweens = function(t) {
						return c(e._rootTimeline, t).concat(c(e._rootFramesTimeline, t))
					};
				i.killAll = function(e, n, r, i) {
					null == n && (n = !0), null == r && (r = !0);
					var s, o, u, a = h(0 != i),
						f = a.length,
						l = n && r && i;
					for (u = 0; f > u; u++) o = a[u], (l || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && (e ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
				}, i.killChildTweensOf = function(e, t) {
					if (null != e) {
						var s, f, l, c, h, p = o.tweenLookup;
						if ("string" == typeof e && (e = n.selector(e) || e), u(e) && (e = r.call(e, 0)), a(e))
							for (c = e.length; --c > -1;) i.killChildTweensOf(e[c], t);
						else {
							s = [];
							for (l in p)
								for (f = p[l].target.parentNode; f;) f === e && (s = s.concat(p[l].tweens)), f = f.parentNode;
							for (h = s.length, c = 0; h > c; c++) t && s[c].totalTime(s[c].totalDuration()), s[c]._enabled(!1, !1)
						}
					}
				};
				var p = function(e, n, r, i) {
					n = n !== !1, r = r !== !1, i = i !== !1;
					for (var s, o, u = h(i), a = n && r && i, f = u.length; --f > -1;) o = u[f], (a || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && o.paused(e)
				};
				return i.pauseAll = function(e, t, n) {
					p(!0, e, t, n)
				}, i.resumeAll = function(e, t, n) {
					p(!1, e, t, n)
				}, i.globalTimeScale = function(t) {
					var r = e._rootTimeline,
						i = n.ticker.time;
					return arguments.length ? (t = t || s, r._startTime = i - (i - r._startTime) * r._timeScale / t, r = e._rootFramesTimeline, i = n.ticker.frame, r._startTime = i - (i - r._startTime) * r._timeScale / t, r._timeScale = e._rootTimeline._timeScale = t, t) : r._timeScale
				}, f.progress = function(e) {
					return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
				}, f.totalProgress = function(e) {
					return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
				}, f.time = function(e, t) {
					return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
				}, f.duration = function(t) {
					return arguments.length ? e.prototype.duration.call(this, t) : this._duration
				}, f.totalDuration = function(e) {
					return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
				}, f.repeat = function(e) {
					return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
				}, f.repeatDelay = function(e) {
					return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
				}, f.yoyo = function(e) {
					return arguments.length ? (this._yoyo = e, this) : this._yoyo
				}, i
			}, !0), window._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, n) {
				var r = function(e) {
						t.call(this, e), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
						var n, r, i = this.vars;
						for (r in i) n = i[r], o(n) && -1 !== n.join("").indexOf("{self}") && (i[r] = this._swapSelfInParams(n));
						o(i.tweens) && this.add(i.tweens, 0, i.align, i.stagger)
					},
					i = 1e-10,
					s = n._internals.isSelector,
					o = n._internals.isArray,
					u = [],
					a = window._gsDefine.globals,
					f = function(e) {
						var t, n = {};
						for (t in e) n[t] = e[t];
						return n
					},
					l = function(e, t, n, r) {
						e._timeline.pause(e._startTime), t && t.apply(r || e._timeline, n || u)
					},
					c = u.slice,
					h = r.prototype = new t;
				return r.version = "1.12.1", h.constructor = r, h.kill()._gc = !1, h.to = function(e, t, r, i) {
					var s = r.repeat && a.TweenMax || n;
					return t ? this.add(new s(e, t, r), i) : this.set(e, r, i)
				}, h.from = function(e, t, r, i) {
					return this.add((r.repeat && a.TweenMax || n).from(e, t, r), i)
				}, h.fromTo = function(e, t, r, i, s) {
					var o = i.repeat && a.TweenMax || n;
					return t ? this.add(o.fromTo(e, t, r, i), s) : this.set(e, i, s)
				}, h.staggerTo = function(e, t, i, o, u, a, l, h) {
					var p, d = new r({
						onComplete: a,
						onCompleteParams: l,
						onCompleteScope: h,
						smoothChildTiming: this.smoothChildTiming
					});
					for ("string" == typeof e && (e = n.selector(e) || e), s(e) && (e = c.call(e, 0)), o = o || 0, p = 0; e.length > p; p++) i.startAt && (i.startAt = f(i.startAt)), d.to(e[p], t, f(i), p * o);
					return this.add(d, u)
				}, h.staggerFrom = function(e, t, n, r, i, s, o, u) {
					return n.immediateRender = 0 != n.immediateRender, n.runBackwards = !0, this.staggerTo(e, t, n, r, i, s, o, u)
				}, h.staggerFromTo = function(e, t, n, r, i, s, o, u, a) {
					return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, this.staggerTo(e, t, r, i, s, o, u, a)
				}, h.call = function(e, t, r, i) {
					return this.add(n.delayedCall(0, e, t, r), i)
				}, h.set = function(e, t, r) {
					return r = this._parseTimeOrLabel(r, 0, !0), null == t.immediateRender && (t.immediateRender = r === this._time && !this._paused), this.add(new n(e, 0, t), r)
				}, r.exportRoot = function(e, t) {
					e = e || {}, null == e.smoothChildTiming && (e.smoothChildTiming = !0);
					var i, s, o = new r(e),
						u = o._timeline;
					for (null == t && (t = !0), u._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = u._time, i = u._first; i;) s = i._next, t && i instanceof n && i.target === i.vars.onComplete || o.add(i, i._startTime - i._delay), i = s;
					return u.add(o, 0), o
				}, h.add = function(i, s, u, a) {
					var f, l, c, h, p, d;
					if ("number" != typeof s && (s = this._parseTimeOrLabel(s, 0, !0, i)), !(i instanceof e)) {
						if (i instanceof Array || i && i.push && o(i)) {
							for (u = u || "normal", a = a || 0, f = s, l = i.length, c = 0; l > c; c++) o(h = i[c]) && (h = new r({
								tweens: h
							})), this.add(h, f), "string" != typeof h && "function" != typeof h && ("sequence" === u ? f = h._startTime + h.totalDuration() / h._timeScale : "start" === u && (h._startTime -= h.delay())), f += a;
							return this._uncache(!0)
						}
						if ("string" == typeof i) return this.addLabel(i, s);
						if ("function" != typeof i) throw "Cannot add " + i + " into the timeline; it is not a tween, timeline, function, or string.";
						i = n.delayedCall(0, i)
					}
					if (t.prototype.add.call(this, i, s), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
						for (p = this, d = p.rawTime() > i._startTime; p._timeline;) d && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
					return this
				}, h.remove = function(t) {
					if (t instanceof e) return this._remove(t, !1);
					if (t instanceof Array || t && t.push && o(t)) {
						for (var n = t.length; --n > -1;) this.remove(t[n]);
						return this
					}
					return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
				}, h._remove = function(e, n) {
					t.prototype._remove.call(this, e, n);
					var r = this._last;
					return r ? this._time > r._startTime + r._totalDuration / r._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
				}, h.append = function(e, t) {
					return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
				}, h.insert = h.insertMultiple = function(e, t, n, r) {
					return this.add(e, t || 0, n, r)
				}, h.appendMultiple = function(e, t, n, r) {
					return this.add(e, this._parseTimeOrLabel(null, t, !0, e), n, r)
				}, h.addLabel = function(e, t) {
					return this._labels[e] = this._parseTimeOrLabel(t), this
				}, h.addPause = function(e, t, n, r) {
					return this.call(l, ["{self}", t, n, r], this, e)
				}, h.removeLabel = function(e) {
					return delete this._labels[e], this
				}, h.getLabelTime = function(e) {
					return null != this._labels[e] ? this._labels[e] : -1
				}, h._parseTimeOrLabel = function(t, n, r, i) {
					var s;
					if (i instanceof e && i.timeline === this) this.remove(i);
					else if (i && (i instanceof Array || i.push && o(i)))
						for (s = i.length; --s > -1;) i[s] instanceof e && i[s].timeline === this && this.remove(i[s]);
					if ("string" == typeof n) return this._parseTimeOrLabel(n, r && "number" == typeof t && null == this._labels[n] ? t - this.duration() : 0, r);
					if (n = n || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
					else {
						if (s = t.indexOf("="), -1 === s) return null == this._labels[t] ? r ? this._labels[t] = this.duration() + n : n : this._labels[t] + n;
						n = parseInt(t.charAt(s - 1) + "1", 10) * Number(t.substr(s + 1)), t = s > 1 ? this._parseTimeOrLabel(t.substr(0, s - 1), 0, r) : this.duration()
					}
					return Number(t) + n
				}, h.seek = function(e, t) {
					return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), t !== !1)
				}, h.stop = function() {
					return this.paused(!0)
				}, h.gotoAndPlay = function(e, t) {
					return this.play(e, t)
				}, h.gotoAndStop = function(e, t) {
					return this.pause(e, t)
				}, h.render = function(e, t, n) {
					this._gc && this._enabled(!0, !1);
					var r, s, o, a, f, l = this._dirty ? this.totalDuration() : this._totalDuration,
						c = this._time,
						h = this._startTime,
						p = this._timeScale,
						d = this._paused;
					if (e >= l ? (this._totalTime = this._time = l, this._reversed || this._hasPausedChild() || (s = !0, a = "onComplete", 0 === this._duration && (0 === e || 0 > this._rawPrevTime || this._rawPrevTime === i) && this._rawPrevTime !== e && this._first && (f = !0, this._rawPrevTime > i && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, e = l + 1e-4) : 1e-7 > e ? (this._totalTime = this._time = 0, (0 !== c || 0 === this._duration && this._rawPrevTime !== i && (this._rawPrevTime > 0 || 0 > e && this._rawPrevTime >= 0)) && (a = "onReverseComplete", s = this._reversed), 0 > e ? (this._active = !1, 0 === this._duration && this._rawPrevTime >= 0 && this._first && (f = !0), this._rawPrevTime = e) : (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, e = 0, this._initted || (f = !0))) : this._totalTime = this._time = this._rawPrevTime = e, this._time !== c && this._first || n || f) {
						if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && e > 0 && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || u)), this._time >= c)
							for (r = this._first; r && (o = r._next, !this._paused || d);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o;
						else
							for (r = this._last; r && (o = r._prev, !this._paused || d);)(r._active || c >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o;
						this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || u)), a && (this._gc || (h === this._startTime || p !== this._timeScale) && (0 === this._time || l >= this.totalDuration()) && (s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[a] && this.vars[a].apply(this.vars[a + "Scope"] || this, this.vars[a + "Params"] || u)))
					}
				}, h._hasPausedChild = function() {
					for (var e = this._first; e;) {
						if (e._paused || e instanceof r && e._hasPausedChild()) return !0;
						e = e._next
					}
					return !1
				}, h.getChildren = function(e, t, r, i) {
					i = i || -9999999999;
					for (var s = [], o = this._first, u = 0; o;) i > o._startTime || (o instanceof n ? t !== !1 && (s[u++] = o) : (r !== !1 && (s[u++] = o), e !== !1 && (s = s.concat(o.getChildren(!0, t, r)), u = s.length))), o = o._next;
					return s
				}, h.getTweensOf = function(e, t) {
					var r, i, s = this._gc,
						o = [],
						u = 0;
					for (s && this._enabled(!0, !0), r = n.getTweensOf(e), i = r.length; --i > -1;)(r[i].timeline === this || t && this._contains(r[i])) && (o[u++] = r[i]);
					return s && this._enabled(!1, !0), o
				}, h._contains = function(e) {
					for (var t = e.timeline; t;) {
						if (t === this) return !0;
						t = t.timeline
					}
					return !1
				}, h.shiftChildren = function(e, t, n) {
					n = n || 0;
					for (var r, i = this._first, s = this._labels; i;) i._startTime >= n && (i._startTime += e), i = i._next;
					if (t)
						for (r in s) s[r] >= n && (s[r] += e);
					return this._uncache(!0)
				}, h._kill = function(e, t) {
					if (!e && !t) return this._enabled(!1, !1);
					for (var n = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = n.length, i = !1; --r > -1;) n[r]._kill(e, t) && (i = !0);
					return i
				}, h.clear = function(e) {
					var t = this.getChildren(!1, !0, !0),
						n = t.length;
					for (this._time = this._totalTime = 0; --n > -1;) t[n]._enabled(!1, !1);
					return e !== !1 && (this._labels = {}), this._uncache(!0)
				}, h.invalidate = function() {
					for (var e = this._first; e;) e.invalidate(), e = e._next;
					return this
				}, h._enabled = function(e, n) {
					if (e === this._gc)
						for (var r = this._first; r;) r._enabled(e, !0), r = r._next;
					return t.prototype._enabled.call(this, e, n)
				}, h.duration = function(e) {
					return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
				}, h.totalDuration = function(e) {
					if (!arguments.length) {
						if (this._dirty) {
							for (var t, n, r = 0, i = this._last, s = 999999999999; i;) t = i._prev, i._dirty && i.totalDuration(), i._startTime > s && this._sortChildren && !i._paused ? this.add(i, i._startTime - i._delay) : s = i._startTime, 0 > i._startTime && !i._paused && (r -= i._startTime, this._timeline.smoothChildTiming && (this._startTime += i._startTime / this._timeScale), this.shiftChildren(-i._startTime, !1, -9999999999), s = 0), n = i._startTime + i._totalDuration / i._timeScale, n > r && (r = n), i = t;
							this._duration = this._totalDuration = r, this._dirty = !1
						}
						return this._totalDuration
					}
					return 0 !== this.totalDuration() && 0 !== e && this.timeScale(this._totalDuration / e), this
				}, h.usesFrames = function() {
					for (var t = this._timeline; t._timeline;) t = t._timeline;
					return t === e._rootFramesTimeline
				}, h.rawTime = function() {
					return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
				}, r
			}, !0), window._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, t, n) {
				var r = function(t) {
						e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
					},
					i = 1e-10,
					s = [],
					o = new n(null, null, 1, 0),
					u = r.prototype = new e;
				return u.constructor = r, u.kill()._gc = !1, r.version = "1.12.1", u.invalidate = function() {
					return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
				}, u.addCallback = function(e, n, r, i) {
					return this.add(t.delayedCall(0, e, r, i), n)
				}, u.removeCallback = function(e, t) {
					if (e)
						if (null == t) this._kill(null, e);
						else
							for (var n = this.getTweensOf(e, !1), r = n.length, i = this._parseTimeOrLabel(t); --r > -1;) n[r]._startTime === i && n[r]._enabled(!1, !1);
					return this
				}, u.tweenTo = function(e, n) {
					n = n || {};
					var r, i, u, f = {
						ease: o,
						overwrite: n.delay ? 2 : 1,
						useFrames: this.usesFrames(),
						immediateRender: !1
					};
					for (i in n) f[i] = n[i];
					return f.time = this._parseTimeOrLabel(e), r = Math.abs(Number(f.time) - this._time) / this._timeScale || .001, u = new t(this, r, f), f.onStart = function() {
						u.target.paused(!0), u.vars.time !== u.target.time() && r === u.duration() && u.duration(Math.abs(u.vars.time - u.target.time()) / u.target._timeScale), n.onStart && n.onStart.apply(n.onStartScope || u, n.onStartParams || s)
					}, u
				}, u.tweenFromTo = function(e, t, n) {
					n = n || {}, e = this._parseTimeOrLabel(e), n.startAt = {
						onComplete: this.seek,
						onCompleteParams: [e],
						onCompleteScope: this
					}, n.immediateRender = n.immediateRender !== !1;
					var r = this.tweenTo(t, n);
					return r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
				}, u.render = function(e, t, n) {
					this._gc && this._enabled(!0, !1);
					var r, o, u, a, f, l, c = this._dirty ? this.totalDuration() : this._totalDuration,
						h = this._duration,
						p = this._time,
						d = this._totalTime,
						v = this._startTime,
						m = this._timeScale,
						g = this._rawPrevTime,
						y = this._paused,
						b = this._cycle;
					if (e >= c ? (this._locked || (this._totalTime = c, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, a = "onComplete", 0 === this._duration && (0 === e || 0 > g || g === i) && g !== e && this._first && (f = !0, g > i && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : i, this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = h, e = h + 1e-4)) : 1e-7 > e ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === h && g !== i && (g > 0 || 0 > e && g >= 0) && !this._locked) && (a = "onReverseComplete", o = this._reversed), 0 > e ? (this._active = !1, 0 === h && g >= 0 && this._first && (f = !0), this._rawPrevTime = e) : (this._rawPrevTime = h || !t || e || this._rawPrevTime === e ? e : i, e = 0, this._initted || (f = !0))) : (0 === h && 0 > g && (f = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (l = h + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = h - this._time), this._time > h ? (this._time = h, e = h + 1e-4) : 0 > this._time ? this._time = e = 0 : e = this._time))), this._cycle !== b && !this._locked) {
						var w = this._yoyo && 0 !== (1 & b),
							E = w === (this._yoyo && 0 !== (1 & this._cycle)),
							S = this._totalTime,
							x = this._cycle,
							T = this._rawPrevTime,
							N = this._time;
						if (this._totalTime = b * h, b > this._cycle ? w = !w : this._totalTime += h, this._time = p, this._rawPrevTime = 0 === h ? g - 1e-4 : g, this._cycle = b, this._locked = !0, p = w ? 0 : h, this.render(p, t, 0 === h), t || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || s), E && (p = w ? h + 1e-4 : -0.0001, this.render(p, !0, !1)), this._locked = !1, this._paused && !y) return;
						this._time = N, this._totalTime = S, this._cycle = x, this._rawPrevTime = T
					}
					if (!(this._time !== p && this._first || n || f)) return d !== this._totalTime && this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || s)), void 0;
					if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== d && e > 0 && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._totalTime && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || s)), this._time >= p)
						for (r = this._first; r && (u = r._next, !this._paused || y);)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = u;
					else
						for (r = this._last; r && (u = r._prev, !this._paused || y);)(r._active || p >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = u;
					this._onUpdate && (t || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || s)), a && (this._locked || this._gc || (v === this._startTime || m !== this._timeScale) && (0 === this._time || c >= this.totalDuration()) && (o && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[a] && this.vars[a].apply(this.vars[a + "Scope"] || this, this.vars[a + "Params"] || s)))
				}, u.getActive = function(e, t, n) {
					null == e && (e = !0), null == t && (t = !0), null == n && (n = !1);
					var r, i, s = [],
						o = this.getChildren(e, t, n),
						u = 0,
						a = o.length;
					for (r = 0; a > r; r++) i = o[r], i.isActive() && (s[u++] = i);
					return s
				}, u.getLabelAfter = function(e) {
					e || 0 !== e && (e = this._time);
					var t, n = this.getLabelsArray(),
						r = n.length;
					for (t = 0; r > t; t++)
						if (n[t].time > e) return n[t].name;
					return null
				}, u.getLabelBefore = function(e) {
					null == e && (e = this._time);
					for (var t = this.getLabelsArray(), n = t.length; --n > -1;)
						if (e > t[n].time) return t[n].name;
					return null
				}, u.getLabelsArray = function() {
					var e, t = [],
						n = 0;
					for (e in this._labels) t[n++] = {
						time: this._labels[e],
						name: e
					};
					return t.sort(function(e, t) {
						return e.time - t.time
					}), t
				}, u.progress = function(e) {
					return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
				}, u.totalProgress = function(e) {
					return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
				}, u.totalDuration = function(t) {
					return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
				}, u.time = function(e, t) {
					return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
				}, u.repeat = function(e) {
					return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
				}, u.repeatDelay = function(e) {
					return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
				}, u.yoyo = function(e) {
					return arguments.length ? (this._yoyo = e, this) : this._yoyo
				}, u.currentLabel = function(e) {
					return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
				}, r
			}, !0),
			function() {
				var e = 180 / Math.PI,
					t = [],
					n = [],
					r = [],
					i = {},
					s = function(e, t, n, r) {
						this.a = e, this.b = t, this.c = n, this.d = r, this.da = r - e, this.ca = n - e, this.ba = t - e
					},
					o = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
					u = function(e, t, n, r) {
						var i = {
								a: e
							},
							s = {},
							o = {},
							u = {
								c: r
							},
							a = (e + t) / 2,
							f = (t + n) / 2,
							l = (n + r) / 2,
							c = (a + f) / 2,
							h = (f + l) / 2,
							p = (h - c) / 8;
						return i.b = a + (e - a) / 4, s.b = c + p, i.c = s.a = (i.b + s.b) / 2, s.c = o.a = (c + h) / 2, o.b = h - p, u.b = l + (r - l) / 4, o.c = u.a = (o.b + u.b) / 2, [i, s, o, u]
					},
					a = function(e, i, s, o, a) {
						var f, l, c, h, p, d, v, m, g, y, b, w, E, S = e.length - 1,
							x = 0,
							T = e[0].a;
						for (f = 0; S > f; f++) p = e[x], l = p.a, c = p.d, h = e[x + 1].d, a ? (b = t[f], w = n[f], E = .25 * (w + b) * i / (o ? .5 : r[f] || .5), d = c - (c - l) * (o ? .5 * i : 0 !== b ? E / b : 0), v = c + (h - c) * (o ? .5 * i : 0 !== w ? E / w : 0), m = c - (d + ((v - d) * (3 * b / (b + w) + .5) / 4 || 0))) : (d = c - .5 * (c - l) * i, v = c + .5 * (h - c) * i, m = c - (d + v) / 2), d += m, v += m, p.c = g = d, p.b = 0 !== f ? T : T = p.a + .6 * (p.c - p.a), p.da = c - l, p.ca = g - l, p.ba = T - l, s ? (y = u(l, T, g, c), e.splice(x, 1, y[0], y[1], y[2], y[3]), x += 4) : x++, T = v;
						p = e[x], p.b = T, p.c = T + .4 * (p.d - T), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = T - p.a, s && (y = u(p.a, T, p.c, p.d), e.splice(x, 1, y[0], y[1], y[2], y[3]))
					},
					f = function(e, r, i, o) {
						var u, a, f, l, c, h, p = [];
						if (o)
							for (e = [o].concat(e), a = e.length; --a > -1;) "string" == typeof(h = e[a][r]) && "=" === h.charAt(1) && (e[a][r] = o[r] + Number(h.charAt(0) + h.substr(2)));
						if (u = e.length - 2, 0 > u) return p[0] = new s(e[0][r], 0, 0, e[-1 > u ? 0 : 1][r]), p;
						for (a = 0; u > a; a++) f = e[a][r], l = e[a + 1][r], p[a] = new s(f, 0, 0, l), i && (c = e[a + 2][r], t[a] = (t[a] || 0) + (l - f) * (l - f), n[a] = (n[a] || 0) + (c - l) * (c - l));
						return p[a] = new s(e[a][r], 0, 0, e[a + 1][r]), p
					},
					l = function(e, s, u, l, c, h) {
						var p, d, v, m, g, y, b, w, E = {},
							S = [],
							x = h || e[0];
						c = "string" == typeof c ? "," + c + "," : o, null == s && (s = 1);
						for (d in e[0]) S.push(d);
						if (e.length > 1) {
							for (w = e[e.length - 1], b = !0, p = S.length; --p > -1;)
								if (d = S[p], Math.abs(x[d] - w[d]) > .05) {
									b = !1;
									break
								} b && (e = e.concat(), h && e.unshift(h), e.push(e[1]), h = e[e.length - 3])
						}
						for (t.length = n.length = r.length = 0, p = S.length; --p > -1;) d = S[p], i[d] = -1 !== c.indexOf("," + d + ","), E[d] = f(e, d, i[d], h);
						for (p = t.length; --p > -1;) t[p] = Math.sqrt(t[p]), n[p] = Math.sqrt(n[p]);
						if (!l) {
							for (p = S.length; --p > -1;)
								if (i[d])
									for (v = E[S[p]], y = v.length - 1, m = 0; y > m; m++) g = v[m + 1].da / n[m] + v[m].da / t[m], r[m] = (r[m] || 0) + g * g;
							for (p = r.length; --p > -1;) r[p] = Math.sqrt(r[p])
						}
						for (p = S.length, m = u ? 4 : 1; --p > -1;) d = S[p], v = E[d], a(v, s, u, l, i[d]), b && (v.splice(0, m), v.splice(v.length - m, m));
						return E
					},
					c = function(e, t, n) {
						t = t || "soft";
						var r, i, o, u, a, f, l, c, h, p, d, v = {},
							m = "cubic" === t ? 3 : 2,
							g = "soft" === t,
							y = [];
						if (g && n && (e = [n].concat(e)), null == e || m + 1 > e.length) throw "invalid Bezier data";
						for (h in e[0]) y.push(h);
						for (f = y.length; --f > -1;) {
							for (h = y[f], v[h] = a = [], p = 0, c = e.length, l = 0; c > l; l++) r = null == n ? e[l][h] : "string" == typeof(d = e[l][h]) && "=" === d.charAt(1) ? n[h] + Number(d.charAt(0) + d.substr(2)) : Number(d), g && l > 1 && c - 1 > l && (a[p++] = (r + a[p - 2]) / 2), a[p++] = r;
							for (c = p - m + 1, p = 0, l = 0; c > l; l += m) r = a[l], i = a[l + 1], o = a[l + 2], u = 2 === m ? 0 : a[l + 3], a[p++] = d = 3 === m ? new s(r, i, o, u) : new s(r, (2 * i + r) / 3, (2 * i + o) / 3, o);
							a.length = p
						}
						return v
					},
					h = function(e, t, n) {
						for (var r, i, s, o, u, a, f, l, c, h, p, d = 1 / n, v = e.length; --v > -1;)
							for (h = e[v], s = h.a, o = h.d - s, u = h.c - s, a = h.b - s, r = i = 0, l = 1; n >= l; l++) f = d * l, c = 1 - f, r = i - (i = (f * f * o + 3 * c * (f * u + c * a)) * f), p = v * n + l - 1, t[p] = (t[p] || 0) + r * r
					},
					p = function(e, t) {
						t = t >> 0 || 6;
						var n, r, i, s, o = [],
							u = [],
							a = 0,
							f = 0,
							l = t - 1,
							c = [],
							p = [];
						for (n in e) h(e[n], o, t);
						for (i = o.length, r = 0; i > r; r++) a += Math.sqrt(o[r]), s = r % t, p[s] = a, s === l && (f += a, s = r / t >> 0, c[s] = p, u[s] = f, a = 0, p = []);
						return {
							length: f,
							lengths: u,
							segments: c
						}
					},
					d = window._gsDefine.plugin({
						propName: "bezier",
						priority: -1,
						version: "1.3.2",
						API: 2,
						global: !0,
						init: function(e, t, n) {
							this._target = e, t instanceof Array && (t = {
								values: t
							}), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
							var r, i, s, o, u, a = t.values || [],
								f = {},
								h = a[0],
								d = t.autoRotate || n.vars.orientToBezier;
							this._autoRotate = d ? d instanceof Array ? d : [
								["x", "y", "rotation", d === !0 ? 0 : Number(d) || 0]
							] : null;
							for (r in h) this._props.push(r);
							for (s = this._props.length; --s > -1;) r = this._props[s], this._overwriteProps.push(r), i = this._func[r] = "function" == typeof e[r], f[r] = i ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), u || f[r] !== a[0][r] && (u = f);
							if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? l(a, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, u) : c(a, t.type, f), this._segCount = this._beziers[r].length, this._timeRes) {
								var v = p(this._beziers, this._timeRes);
								this._length = v.length, this._lengths = v.lengths, this._segments = v.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
							}
							if (d = this._autoRotate)
								for (this._initialRotations = [], d[0] instanceof Array || (this._autoRotate = d = [d]), s = d.length; --s > -1;) {
									for (o = 0; 3 > o; o++) r = d[s][o], this._func[r] = "function" == typeof e[r] ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)] : !1;
									r = d[s][2], this._initialRotations[s] = this._func[r] ? this._func[r].call(this._target) : this._target[r]
								}
							return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
						},
						set: function(t) {
							var n, r, i, s, o, u, a, f, l, c, h = this._segCount,
								p = this._func,
								d = this._target,
								v = t !== this._startRatio;
							if (this._timeRes) {
								if (l = this._lengths, c = this._curSeg, t *= this._length, i = this._li, t > this._l2 && h - 1 > i) {
									for (f = h - 1; f > i && t >= (this._l2 = l[++i]););
									this._l1 = l[i - 1], this._li = i, this._curSeg = c = this._segments[i], this._s2 = c[this._s1 = this._si = 0]
								} else if (this._l1 > t && i > 0) {
									for (; i > 0 && (this._l1 = l[--i]) >= t;);
									0 === i && this._l1 > t ? this._l1 = 0 : i++, this._l2 = l[i], this._li = i, this._curSeg = c = this._segments[i], this._s1 = c[(this._si = c.length - 1) - 1] || 0, this._s2 = c[this._si]
								}
								if (n = i, t -= this._l1, i = this._si, t > this._s2 && c.length - 1 > i) {
									for (f = c.length - 1; f > i && t >= (this._s2 = c[++i]););
									this._s1 = c[i - 1], this._si = i
								} else if (this._s1 > t && i > 0) {
									for (; i > 0 && (this._s1 = c[--i]) >= t;);
									0 === i && this._s1 > t ? this._s1 = 0 : i++, this._s2 = c[i], this._si = i
								}
								u = (i + (t - this._s1) / (this._s2 - this._s1)) * this._prec
							} else n = 0 > t ? 0 : t >= 1 ? h - 1 : h * t >> 0, u = (t - n * (1 / h)) * h;
							for (r = 1 - u, i = this._props.length; --i > -1;) s = this._props[i], o = this._beziers[s][n], a = (u * u * o.da + 3 * r * (u * o.ca + r * o.ba)) * u + o.a, this._round[s] && (a = Math.round(a)), p[s] ? d[s](a) : d[s] = a;
							if (this._autoRotate) {
								var m, g, y, b, w, E, S, x = this._autoRotate;
								for (i = x.length; --i > -1;) s = x[i][2], E = x[i][3] || 0, S = x[i][4] === !0 ? 1 : e, o = this._beziers[x[i][0]], m = this._beziers[x[i][1]], o && m && (o = o[n], m = m[n], g = o.a + (o.b - o.a) * u, b = o.b + (o.c - o.b) * u, g += (b - g) * u, b += (o.c + (o.d - o.c) * u - b) * u, y = m.a + (m.b - m.a) * u, w = m.b + (m.c - m.b) * u, y += (w - y) * u, w += (m.c + (m.d - m.c) * u - w) * u, a = v ? Math.atan2(w - y, b - g) * S + E : this._initialRotations[i], p[s] ? d[s](a) : d[s] = a)
							}
						}
					}),
					v = d.prototype;
				d.bezierThrough = l, d.cubicToQuadratic = u, d._autoCSS = !0, d.quadraticToCubic = function(e, t, n) {
					return new s(e, (2 * t + e) / 3, (2 * t + n) / 3, n)
				}, d._cssRegister = function() {
					var e = window._gsDefine.globals.CSSPlugin;
					if (e) {
						var t = e._internals,
							n = t._parseToProxy,
							r = t._setPluginRatio,
							i = t.CSSPropTween;
						t._registerComplexSpecialProp("bezier", {
							parser: function(e, t, s, o, u, a) {
								t instanceof Array && (t = {
									values: t
								}), a = new d;
								var f, l, c, h = t.values,
									p = h.length - 1,
									v = [],
									m = {};
								if (0 > p) return u;
								for (f = 0; p >= f; f++) c = n(e, h[f], o, u, a, p !== f), v[f] = c.end;
								for (l in t) m[l] = t[l];
								return m.values = v, u = new i(e, "bezier", 0, 0, c.pt, 2), u.data = c, u.plugin = a, u.setRatio = r, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (f = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != c.end.left ? [
									["left", "top", "rotation", f, !1]
								] : null != c.end.x ? [
									["x", "y", "rotation", f, !1]
								] : !1), m.autoRotate && (o._transform || o._enableTransforms(!1), c.autoRotate = o._target._gsTransform), a._onInitTween(c.proxy, m, o._tween), u
							}
						})
					}
				}, v._roundProps = function(e, t) {
					for (var n = this._overwriteProps, r = n.length; --r > -1;)(e[n[r]] || e.bezier || e.bezierThrough) && (this._round[n[r]] = t)
				}, v._kill = function(e) {
					var t, n, r = this._props;
					for (t in this._beziers)
						if (t in e)
							for (delete this._beziers[t], delete this._func[t], n = r.length; --n > -1;) r[n] === t && r.splice(n, 1);
					return this._super._kill.call(this, e)
				}
			}(), window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(e, t) {
				var n, r, i, s, o = function() {
						e.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
					},
					u = {},
					a = o.prototype = new e("css");
				a.constructor = o, o.version = "1.12.1", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", a = "px", o.suffixMap = {
					top: a,
					right: a,
					bottom: a,
					left: a,
					width: a,
					height: a,
					fontSize: a,
					padding: a,
					margin: a,
					perspective: a,
					lineHeight: ""
				};
				var f, l, c, h, p, d, v = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
					m = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
					g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
					y = /[^\d\-\.]/g,
					b = /(?:\d|\-|\+|=|#|\.)*/g,
					w = /opacity *= *([^)]*)/i,
					E = /opacity:([^;]*)/i,
					S = /alpha\(opacity *=.+?\)/i,
					x = /^(rgb|hsl)/,
					T = /([A-Z])/g,
					N = /-([a-z])/gi,
					C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
					k = function(e, t) {
						return t.toUpperCase()
					},
					L = /(?:Left|Right|Width)/i,
					A = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
					O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
					M = /,(?=[^\)]*(?:\(|$))/gi,
					_ = Math.PI / 180,
					D = 180 / Math.PI,
					P = {},
					H = document,
					B = H.createElement("div"),
					j = H.createElement("img"),
					F = o._internals = {
						_specialProps: u
					},
					I = navigator.userAgent,
					q = function() {
						var e, t = I.indexOf("Android"),
							n = H.createElement("div");
						return c = -1 !== I.indexOf("Safari") && -1 === I.indexOf("Chrome") && (-1 === t || Number(I.substr(t + 8, 1)) > 3), p = c && 6 > Number(I.substr(I.indexOf("Version/") + 8, 1)), h = -1 !== I.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(I) && (d = parseFloat(RegExp.$1)), n.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", e = n.getElementsByTagName("a")[0], e ? /^0.55/.test(e.style.opacity) : !1
					}(),
					R = function(e) {
						return w.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
					},
					U = function(e) {
						window.console && console.log(e)
					},
					z = "",
					W = "",
					X = function(e, t) {
						t = t || B;
						var n, r, i = t.style;
						if (void 0 !== i[e]) return e;
						for (e = e.charAt(0).toUpperCase() + e.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === i[n[r] + e];);
						return r >= 0 ? (W = 3 === r ? "ms" : n[r], z = "-" + W.toLowerCase() + "-", W + e) : null
					},
					V = H.defaultView ? H.defaultView.getComputedStyle : function() {},
					$ = o.getStyle = function(e, t, n, r, i) {
						var s;
						return q || "opacity" !== t ? (!r && e.style[t] ? s = e.style[t] : (n = n || V(e)) ? s = n[t] || n.getPropertyValue(t) || n.getPropertyValue(t.replace(T, "-$1").toLowerCase()) : e.currentStyle && (s = e.currentStyle[t]), null == i || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : i) : R(e)
					},
					J = F.convertToPixels = function(e, n, r, i, s) {
						if ("px" === i || !i) return r;
						if ("auto" === i || !r) return 0;
						var u, a, f, l = L.test(n),
							c = e,
							h = B.style,
							p = 0 > r;
						if (p && (r = -r), "%" === i && -1 !== n.indexOf("border")) u = r / 100 * (l ? e.clientWidth : e.clientHeight);
						else {
							if (h.cssText = "border:0 solid red;position:" + $(e, "position") + ";line-height:0;", "%" !== i && c.appendChild) h[l ? "borderLeftWidth" : "borderTopWidth"] = r + i;
							else {
								if (c = e.parentNode || H.body, a = c._gsCache, f = t.ticker.frame, a && l && a.time === f) return a.width * r / 100;
								h[l ? "width" : "height"] = r + i
							}
							c.appendChild(B), u = parseFloat(B[l ? "offsetWidth" : "offsetHeight"]), c.removeChild(B), l && "%" === i && o.cacheWidths !== !1 && (a = c._gsCache = c._gsCache || {}, a.time = f, a.width = 100 * (u / r)), 0 !== u || s || (u = J(e, n, r, i, !0))
						}
						return p ? -u : u
					},
					K = F.calculateOffset = function(e, t, n) {
						if ("absolute" !== $(e, "position", n)) return 0;
						var r = "left" === t ? "Left" : "Top",
							i = $(e, "margin" + r, n);
						return e["offset" + r] - (J(e, t, parseFloat(i), i.replace(b, "")) || 0)
					},
					Q = function(e, t) {
						var n, r, i = {};
						if (t = t || V(e, null))
							if (n = t.length)
								for (; --n > -1;) i[t[n].replace(N, k)] = t.getPropertyValue(t[n]);
							else
								for (n in t) i[n] = t[n];
						else if (t = e.currentStyle || e.style)
							for (n in t) "string" == typeof n && void 0 === i[n] && (i[n.replace(N, k)] = t[n]);
						return q || (i.opacity = R(e)), r = Tt(e, t, !1), i.rotation = r.rotation, i.skewX = r.skewX, i.scaleX = r.scaleX, i.scaleY = r.scaleY, i.x = r.x, i.y = r.y, St && (i.z = r.z, i.rotationX = r.rotationX, i.rotationY = r.rotationY, i.scaleZ = r.scaleZ), i.filters && delete i.filters, i
					},
					G = function(e, t, n, r, i) {
						var s, o, u, a = {},
							f = e.style;
						for (o in n) "cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (s = n[o]) || i && i[o]) && -1 === o.indexOf("Origin") && ("number" == typeof s || "string" == typeof s) && (a[o] = "auto" !== s || "left" !== o && "top" !== o ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof t[o] || "" === t[o].replace(y, "") ? s : 0 : K(e, o), void 0 !== f[o] && (u = new ct(f, o, f[o], u)));
						if (r)
							for (o in r) "className" !== o && (a[o] = r[o]);
						return {
							difs: a,
							firstMPT: u
						}
					},
					Y = {
						width: ["Left", "Right"],
						height: ["Top", "Bottom"]
					},
					Z = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
					et = function(e, t, n) {
						var r = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
							i = Y[t],
							s = i.length;
						for (n = n || V(e, null); --s > -1;) r -= parseFloat($(e, "padding" + i[s], n, !0)) || 0, r -= parseFloat($(e, "border" + i[s] + "Width", n, !0)) || 0;
						return r
					},
					tt = function(e, t) {
						(null == e || "" === e || "auto" === e || "auto auto" === e) && (e = "0 0");
						var n = e.split(" "),
							r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : n[0],
							i = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : n[1];
						return null == i ? i = "0" : "center" === i && (i = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== i.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === i.charAt(1), t.ox = parseFloat(r.replace(y, "")), t.oy = parseFloat(i.replace(y, ""))), r + " " + i + (n.length > 2 ? " " + n[2] : "")
					},
					nt = function(e, t) {
						return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t)
					},
					rt = function(e, t) {
						return null == e ? t : "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * Number(e.substr(2)) + t : parseFloat(e)
					},
					it = function(e, t, n, r) {
						var i, s, o, u, a = 1e-6;
						return null == e ? u = t : "number" == typeof e ? u = e : (i = 360, s = e.split("_"), o = Number(s[0].replace(y, "")) * (-1 === e.indexOf("rad") ? 1 : D) - ("=" === e.charAt(1) ? 0 : t), s.length && (r && (r[n] = t + o), -1 !== e.indexOf("short") && (o %= i, o !== o % (i / 2) && (o = 0 > o ? o + i : o - i)), -1 !== e.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * i) % i - (0 | o / i) * i : -1 !== e.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * i) % i - (0 | o / i) * i)), u = t + o), a > u && u > -a && (u = 0), u
					},
					st = {
						aqua: [0, 255, 255],
						lime: [0, 255, 0],
						silver: [192, 192, 192],
						black: [0, 0, 0],
						maroon: [128, 0, 0],
						teal: [0, 128, 128],
						blue: [0, 0, 255],
						navy: [0, 0, 128],
						white: [255, 255, 255],
						fuchsia: [255, 0, 255],
						olive: [128, 128, 0],
						yellow: [255, 255, 0],
						orange: [255, 165, 0],
						gray: [128, 128, 128],
						purple: [128, 0, 128],
						green: [0, 128, 0],
						red: [255, 0, 0],
						pink: [255, 192, 203],
						cyan: [0, 255, 255],
						transparent: [255, 255, 255, 0]
					},
					ot = function(e, t, n) {
						return e = 0 > e ? e + 1 : e > 1 ? e - 1 : e, 0 | 255 * (1 > 6 * e ? t + 6 * (n - t) * e : .5 > e ? n : 2 > 3 * e ? t + 6 * (n - t) * (2 / 3 - e) : t) + .5
					},
					ut = function(e) {
						var t, n, r, i, s, o;
						return e && "" !== e ? "number" == typeof e ? [e >> 16, 255 & e >> 8, 255 & e] : ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), st[e] ? st[e] : "#" === e.charAt(0) ? (4 === e.length && (t = e.charAt(1), n = e.charAt(2), r = e.charAt(3), e = "#" + t + t + n + n + r + r), e = parseInt(e.substr(1), 16), [e >> 16, 255 & e >> 8, 255 & e]) : "hsl" === e.substr(0, 3) ? (e = e.match(v), i = Number(e[0]) % 360 / 360, s = Number(e[1]) / 100, o = Number(e[2]) / 100, n = .5 >= o ? o * (s + 1) : o + s - o * s, t = 2 * o - n, e.length > 3 && (e[3] = Number(e[3])), e[0] = ot(i + 1 / 3, t, n), e[1] = ot(i, t, n), e[2] = ot(i - 1 / 3, t, n), e) : (e = e.match(v) || st.transparent, e[0] = Number(e[0]), e[1] = Number(e[1]), e[2] = Number(e[2]), e.length > 3 && (e[3] = Number(e[3])), e)) : st.black
					},
					at = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
				for (a in st) at += "|" + a + "\\b";
				at = RegExp(at + ")", "gi");
				var ft = function(e, t, n, r) {
						if (null == e) return function(e) {
							return e
						};
						var i, s = t ? (e.match(at) || [""])[0] : "",
							o = e.split(s).join("").match(g) || [],
							u = e.substr(0, e.indexOf(o[0])),
							a = ")" === e.charAt(e.length - 1) ? ")" : "",
							f = -1 !== e.indexOf(" ") ? " " : ",",
							l = o.length,
							c = l > 0 ? o[0].replace(v, "") : "";
						return l ? i = t ? function(e) {
							var t, h, p, d;
							if ("number" == typeof e) e += c;
							else if (r && M.test(e)) {
								for (d = e.replace(M, "|").split("|"), p = 0; d.length > p; p++) d[p] = i(d[p]);
								return d.join(",")
							}
							if (t = (e.match(at) || [s])[0], h = e.split(t).join("").match(g) || [], p = h.length, l > p--)
								for (; l > ++p;) h[p] = n ? h[0 | (p - 1) / 2] : o[p];
							return u + h.join(f) + f + t + a + (-1 !== e.indexOf("inset") ? " inset" : "")
						} : function(e) {
							var t, s, h;
							if ("number" == typeof e) e += c;
							else if (r && M.test(e)) {
								for (s = e.replace(M, "|").split("|"), h = 0; s.length > h; h++) s[h] = i(s[h]);
								return s.join(",")
							}
							if (t = e.match(g) || [], h = t.length, l > h--)
								for (; l > ++h;) t[h] = n ? t[0 | (h - 1) / 2] : o[h];
							return u + t.join(f) + a
						} : function(e) {
							return e
						}
					},
					lt = function(e) {
						return e = e.split(","),
							function(t, n, r, i, s, o, u) {
								var a, f = (n + "").split(" ");
								for (u = {}, a = 0; 4 > a; a++) u[e[a]] = f[a] = f[a] || f[(a - 1) / 2 >> 0];
								return i.parse(t, u, s, o)
							}
					},
					ct = (F._setPluginRatio = function(e) {
						this.plugin.setRatio(e);
						for (var t, n, r, i, s = this.data, o = s.proxy, u = s.firstMPT, a = 1e-6; u;) t = o[u.v], u.r ? t = Math.round(t) : a > t && t > -a && (t = 0), u.t[u.p] = t, u = u._next;
						if (s.autoRotate && (s.autoRotate.rotation = o.rotation), 1 === e)
							for (u = s.firstMPT; u;) {
								if (n = u.t, n.type) {
									if (1 === n.type) {
										for (i = n.xs0 + n.s + n.xs1, r = 1; n.l > r; r++) i += n["xn" + r] + n["xs" + (r + 1)];
										n.e = i
									}
								} else n.e = n.s + n.xs0;
								u = u._next
							}
					}, function(e, t, n, r, i) {
						this.t = e, this.p = t, this.v = n, this.r = i, r && (r._prev = this, this._next = r)
					}),
					ht = (F._parseToProxy = function(e, t, n, r, i, s) {
						var o, u, a, f, l, c = r,
							h = {},
							p = {},
							d = n._transform,
							v = P;
						for (n._transform = null, P = t, r = l = n.parse(e, t, r, i), P = v, s && (n._transform = d, c && (c._prev = null, c._prev && (c._prev._next = null))); r && r !== c;) {
							if (1 >= r.type && (u = r.p, p[u] = r.s + r.c, h[u] = r.s, s || (f = new ct(r, "s", u, f, r.r), r.c = 0), 1 === r.type))
								for (o = r.l; --o > 0;) a = "xn" + o, u = r.p + "_" + a, p[u] = r.data[a], h[u] = r[a], s || (f = new ct(r, a, u, f, r.rxp[a]));
							r = r._next
						}
						return {
							proxy: h,
							end: p,
							firstMPT: f,
							pt: l
						}
					}, F.CSSPropTween = function(e, t, r, i, o, u, a, f, l, c, h) {
						this.t = e, this.p = t, this.s = r, this.c = i, this.n = a || t, e instanceof ht || s.push(this.n), this.r = f, this.type = u || 0, l && (this.pr = l, n = !0), this.b = void 0 === c ? r : c, this.e = void 0 === h ? r + i : h, o && (this._next = o, o._prev = this)
					}),
					pt = o.parseComplex = function(e, t, n, r, i, s, o, u, a, l) {
						n = n || s || "", o = new ht(e, t, 0, 0, o, l ? 2 : 1, null, !1, u, n, r), r += "";
						var c, h, p, d, g, y, b, w, E, S, T, N, C = n.split(", ").join(",").split(" "),
							k = r.split(", ").join(",").split(" "),
							L = C.length,
							A = f !== !1;
						for ((-1 !== r.indexOf(",") || -1 !== n.indexOf(",")) && (C = C.join(" ").replace(M, ", ").split(" "), k = k.join(" ").replace(M, ", ").split(" "), L = C.length), L !== k.length && (C = (s || "").split(" "), L = C.length), o.plugin = a, o.setRatio = l, c = 0; L > c; c++)
							if (d = C[c], g = k[c], w = parseFloat(d), w || 0 === w) o.appendXtra("", w, nt(g, w), g.replace(m, ""), A && -1 !== g.indexOf("px"), !0);
							else if (i && ("#" === d.charAt(0) || st[d] || x.test(d))) N = "," === g.charAt(g.length - 1) ? ")," : ")", d = ut(d), g = ut(g), E = d.length + g.length > 6, E && !q && 0 === g[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(k[c]).join("transparent")) : (q || (E = !1), o.appendXtra(E ? "rgba(" : "rgb(", d[0], g[0] - d[0], ",", !0, !0).appendXtra("", d[1], g[1] - d[1], ",", !0).appendXtra("", d[2], g[2] - d[2], E ? "," : N, !0), E && (d = 4 > d.length ? 1 : d[3], o.appendXtra("", d, (4 > g.length ? 1 : g[3]) - d, N, !1)));
						else if (y = d.match(v)) {
							if (b = g.match(m), !b || b.length !== y.length) return o;
							for (p = 0, h = 0; y.length > h; h++) T = y[h], S = d.indexOf(T, p), o.appendXtra(d.substr(p, S - p), Number(T), nt(b[h], T), "", A && "px" === d.substr(S + T.length, 2), 0 === h), p = S + T.length;
							o["xs" + o.l] += d.substr(p)
						} else o["xs" + o.l] += o.l ? " " + d : d;
						if (-1 !== r.indexOf("=") && o.data) {
							for (N = o.xs0 + o.data.s, c = 1; o.l > c; c++) N += o["xs" + c] + o.data["xn" + c];
							o.e = N + o["xs" + c]
						}
						return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o
					},
					dt = 9;
				for (a = ht.prototype, a.l = a.pr = 0; --dt > 0;) a["xn" + dt] = 0, a["xs" + dt] = "";
				a.xs0 = "", a._next = a._prev = a.xfirst = a.data = a.plugin = a.setRatio = a.rxp = null, a.appendXtra = function(e, t, n, r, i, s) {
					var o = this,
						u = o.l;
					return o["xs" + u] += s && u ? " " + e : e || "", n || 0 === u || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = r || "", u > 0 ? (o.data["xn" + u] = t + n, o.rxp["xn" + u] = i, o["xn" + u] = t, o.plugin || (o.xfirst = new ht(o, "xn" + u, t, n, o.xfirst || o, 0, o.n, i, o.pr), o.xfirst.xs0 = 0), o) : (o.data = {
						s: t + n
					}, o.rxp = {}, o.s = t, o.c = n, o.r = i, o)) : (o["xs" + u] += t + (r || ""), o)
				};
				var vt = function(e, t) {
						t = t || {}, this.p = t.prefix ? X(e) || e : e, u[e] = u[this.p] = this, this.format = t.formatter || ft(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
					},
					mt = F._registerComplexSpecialProp = function(e, t, n) {
						"object" != typeof t && (t = {
							parser: n
						});
						var r, i, s = e.split(","),
							o = t.defaultValue;
						for (n = n || [o], r = 0; s.length > r; r++) t.prefix = 0 === r && t.prefix, t.defaultValue = n[r] || o, i = new vt(s[r], t)
					},
					gt = function(e) {
						if (!u[e]) {
							var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
							mt(e, {
								parser: function(e, n, r, i, s, o, a) {
									var f = (window.GreenSockGlobals || window).com.greensock.plugins[t];
									return f ? (f._cssRegister(), u[r].parse(e, n, r, i, s, o, a)) : (U("Error: " + t + " js file not loaded."), s)
								}
							})
						}
					};
				a = vt.prototype, a.parseComplex = function(e, t, n, r, i, s) {
					var o, u, a, f, l, c, h = this.keyword;
					if (this.multi && (M.test(n) || M.test(t) ? (u = t.replace(M, "|").split("|"), a = n.replace(M, "|").split("|")) : h && (u = [t], a = [n])), a) {
						for (f = a.length > u.length ? a.length : u.length, o = 0; f > o; o++) t = u[o] = u[o] || this.dflt, n = a[o] = a[o] || this.dflt, h && (l = t.indexOf(h), c = n.indexOf(h), l !== c && (n = -1 === c ? a : u, n[o] += " " + h));
						t = u.join(", "), n = a.join(", ")
					}
					return pt(e, this.p, t, n, this.clrs, this.dflt, r, this.pr, i, s)
				}, a.parse = function(e, t, n, r, s, o) {
					return this.parseComplex(e.style, this.format($(e, this.p, i, !1, this.dflt)), this.format(t), s, o)
				}, o.registerSpecialProp = function(e, t, n) {
					mt(e, {
						parser: function(e, r, i, s, o, u) {
							var a = new ht(e, i, 0, 0, o, 2, i, !1, n);
							return a.plugin = u, a.setRatio = t(e, r, s._tween, i), a
						},
						priority: n
					})
				};
				var yt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective".split(","),
					bt = X("transform"),
					wt = z + "transform",
					Et = X("transformOrigin"),
					St = null !== X("perspective"),
					xt = F.Transform = function() {
						this.skewY = 0
					},
					Tt = F.getTransform = function(e, t, n, r) {
						if (e._gsTransform && n && !r) return e._gsTransform;
						var i, s, u, a, f, l, c, h, p, d, v, m, g, y = n ? e._gsTransform || new xt : new xt,
							b = 0 > y.scaleX,
							w = 2e-5,
							E = 1e5,
							S = 179.99,
							x = S * _,
							T = St ? parseFloat($(e, Et, t, !1, "0 0 0").split(" ")[2]) || y.zOrigin || 0 : 0;
						for (bt ? i = $(e, wt, t, !0) : e.currentStyle && (i = e.currentStyle.filter.match(A), i = i && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), y.x || 0, y.y || 0].join(",") : ""), s = (i || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], u = s.length; --u > -1;) a = Number(s[u]), s[u] = (f = a - (a |= 0)) ? (0 | f * E + (0 > f ? -0.5 : .5)) / E + a : a;
						if (16 === s.length) {
							var N = s[8],
								C = s[9],
								k = s[10],
								L = s[12],
								O = s[13],
								M = s[14];
							if (y.zOrigin && (M = -y.zOrigin, L = N * M - s[12], O = C * M - s[13], M = k * M + y.zOrigin - s[14]), !n || r || null == y.rotationX) {
								var P, H, B, j, F, I, q, R = s[0],
									U = s[1],
									z = s[2],
									W = s[3],
									X = s[4],
									V = s[5],
									J = s[6],
									K = s[7],
									Q = s[11],
									G = Math.atan2(J, k),
									Y = -x > G || G > x;
								y.rotationX = G * D, G && (j = Math.cos(-G), F = Math.sin(-G), P = X * j + N * F, H = V * j + C * F, B = J * j + k * F, N = X * -F + N * j, C = V * -F + C * j, k = J * -F + k * j, Q = K * -F + Q * j, X = P, V = H, J = B), G = Math.atan2(N, R), y.rotationY = G * D, G && (I = -x > G || G > x, j = Math.cos(-G), F = Math.sin(-G), P = R * j - N * F, H = U * j - C * F, B = z * j - k * F, C = U * F + C * j, k = z * F + k * j, Q = W * F + Q * j, R = P, U = H, z = B), G = Math.atan2(U, V), y.rotation = G * D, G && (q = -x > G || G > x, j = Math.cos(-G), F = Math.sin(-G), R = R * j + X * F, H = U * j + V * F, V = U * -F + V * j, J = z * -F + J * j, U = H), q && Y ? y.rotation = y.rotationX = 0 : q && I ? y.rotation = y.rotationY = 0 : I && Y && (y.rotationY = y.rotationX = 0), y.scaleX = (0 | Math.sqrt(R * R + U * U) * E + .5) / E, y.scaleY = (0 | Math.sqrt(V * V + C * C) * E + .5) / E, y.scaleZ = (0 | Math.sqrt(J * J + k * k) * E + .5) / E, y.skewX = 0, y.perspective = Q ? 1 / (0 > Q ? -Q : Q) : 0, y.x = L, y.y = O, y.z = M
							}
						} else if (!(St && !r && s.length && y.x === s[4] && y.y === s[5] && (y.rotationX || y.rotationY) || void 0 !== y.x && "none" === $(e, "display", t))) {
							var Z = s.length >= 6,
								et = Z ? s[0] : 1,
								tt = s[1] || 0,
								nt = s[2] || 0,
								rt = Z ? s[3] : 1;
							y.x = s[4] || 0, y.y = s[5] || 0, l = Math.sqrt(et * et + tt * tt), c = Math.sqrt(rt * rt + nt * nt), h = et || tt ? Math.atan2(tt, et) * D : y.rotation || 0, p = nt || rt ? Math.atan2(nt, rt) * D + h : y.skewX || 0, d = l - Math.abs(y.scaleX || 0), v = c - Math.abs(y.scaleY || 0), Math.abs(p) > 90 && 270 > Math.abs(p) && (b ? (l *= -1, p += 0 >= h ? 180 : -180, h += 0 >= h ? 180 : -180) : (c *= -1, p += 0 >= p ? 180 : -180)), m = (h - y.rotation) % 180, g = (p - y.skewX) % 180, (void 0 === y.skewX || d > w || -w > d || v > w || -w > v || m > -S && S > m && !1 | m * E || g > -S && S > g && !1 | g * E) && (y.scaleX = l, y.scaleY = c, y.rotation = h, y.skewX = p), St && (y.rotationX = y.rotationY = y.z = 0, y.perspective = parseFloat(o.defaultTransformPerspective) || 0, y.scaleZ = 1)
						}
						y.zOrigin = T;
						for (u in y) w > y[u] && y[u] > -w && (y[u] = 0);
						return n && (e._gsTransform = y), y
					},
					Nt = function(e) {
						var t, n, r = this.data,
							i = -r.rotation * _,
							s = i + r.skewX * _,
							o = 1e5,
							u = (0 | Math.cos(i) * r.scaleX * o) / o,
							a = (0 | Math.sin(i) * r.scaleX * o) / o,
							f = (0 | Math.sin(s) * -r.scaleY * o) / o,
							l = (0 | Math.cos(s) * r.scaleY * o) / o,
							c = this.t.style,
							h = this.t.currentStyle;
						if (h) {
							n = a, a = -f, f = -n, t = h.filter, c.filter = "";
							var p, v, m = this.t.offsetWidth,
								g = this.t.offsetHeight,
								y = "absolute" !== h.position,
								E = "progid:DXImageTransform.Microsoft.Matrix(M11=" + u + ", M12=" + a + ", M21=" + f + ", M22=" + l,
								S = r.x,
								x = r.y;
							if (null != r.ox && (p = (r.oxp ? .01 * m * r.ox : r.ox) - m / 2, v = (r.oyp ? .01 * g * r.oy : r.oy) - g / 2, S += p - (p * u + v * a), x += v - (p * f + v * l)), y ? (p = m / 2, v = g / 2, E += ", Dx=" + (p - (p * u + v * a) + S) + ", Dy=" + (v - (p * f + v * l) + x) + ")") : E += ", sizingMethod='auto expand')", c.filter = -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? t.replace(O, E) : E + " " + t, (0 === e || 1 === e) && 1 === u && 0 === a && 0 === f && 1 === l && (y && -1 === E.indexOf("Dx=0, Dy=0") || w.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && c.removeAttribute("filter")), !y) {
								var T, N, C, k = 8 > d ? 1 : -1;
								for (p = r.ieOffsetX || 0, v = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > u ? -u : u) * m + (0 > a ? -a : a) * g)) / 2 + S), r.ieOffsetY = Math.round((g - ((0 > l ? -l : l) * g + (0 > f ? -f : f) * m)) / 2 + x), dt = 0; 4 > dt; dt++) N = Z[dt], T = h[N], n = -1 !== T.indexOf("px") ? parseFloat(T) : J(this.t, N, parseFloat(T), T.replace(b, "")) || 0, C = n !== r[N] ? 2 > dt ? -r.ieOffsetX : -r.ieOffsetY : 2 > dt ? p - r.ieOffsetX : v - r.ieOffsetY, c[N] = (r[N] = Math.round(n - C * (0 === dt || 2 === dt ? 1 : k))) + "px"
							}
						}
					},
					Ct = F.set3DTransformRatio = function(e) {
						var t, n, r, i, s, o, u, a, f, l, c, p, d, v, m, g, y, b, w, E, S, x, T, N = this.data,
							C = this.t.style,
							k = N.rotation * _,
							L = N.scaleX,
							A = N.scaleY,
							O = N.scaleZ,
							M = N.perspective;
						if (!(1 !== e && 0 !== e || "auto" !== N.force3D || N.rotationY || N.rotationX || 1 !== O || M || N.z)) return kt.call(this, e), void 0;
						if (h) {
							var D = 1e-4;
							D > L && L > -D && (L = O = 2e-5), D > A && A > -D && (A = O = 2e-5), !M || N.z || N.rotationX || N.rotationY || (M = 0)
						}
						if (k || N.skewX) b = Math.cos(k), w = Math.sin(k), t = b, s = w, N.skewX && (k -= N.skewX * _, b = Math.cos(k), w = Math.sin(k), "simple" === N.skewType && (E = Math.tan(N.skewX * _), E = Math.sqrt(1 + E * E), b *= E, w *= E)), n = -w, o = b;
						else {
							if (!(N.rotationY || N.rotationX || 1 !== O || M)) return C[bt] = "translate3d(" + N.x + "px," + N.y + "px," + N.z + "px)" + (1 !== L || 1 !== A ? " scale(" + L + "," + A + ")" : ""), void 0;
							t = o = 1, n = s = 0
						}
						c = 1, r = i = u = a = f = l = p = d = v = 0, m = M ? -1 / M : 0, g = N.zOrigin, y = 1e5, k = N.rotationY * _, k && (b = Math.cos(k), w = Math.sin(k), f = c * -w, d = m * -w, r = t * w, u = s * w, c *= b, m *= b, t *= b, s *= b), k = N.rotationX * _, k && (b = Math.cos(k), w = Math.sin(k), E = n * b + r * w, S = o * b + u * w, x = l * b + c * w, T = v * b + m * w, r = n * -w + r * b, u = o * -w + u * b, c = l * -w + c * b, m = v * -w + m * b, n = E, o = S, l = x, v = T), 1 !== O && (r *= O, u *= O, c *= O, m *= O), 1 !== A && (n *= A, o *= A, l *= A, v *= A), 1 !== L && (t *= L, s *= L, f *= L, d *= L), g && (p -= g, i = r * p, a = u * p, p = c * p + g), i = (E = (i += N.x) - (i |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + i : i, a = (E = (a += N.y) - (a |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + a : a, p = (E = (p += N.z) - (p |= 0)) ? (0 | E * y + (0 > E ? -0.5 : .5)) / y + p : p, C[bt] = "matrix3d(" + [(0 | t * y) / y, (0 | s * y) / y, (0 | f * y) / y, (0 | d * y) / y, (0 | n * y) / y, (0 | o * y) / y, (0 | l * y) / y, (0 | v * y) / y, (0 | r * y) / y, (0 | u * y) / y, (0 | c * y) / y, (0 | m * y) / y, i, a, p, M ? 1 + -p / M : 1].join(",") + ")"
					},
					kt = F.set2DTransformRatio = function(e) {
						var t, n, r, i, s, o = this.data,
							u = this.t,
							a = u.style;
						return o.rotationX || o.rotationY || o.z || o.force3D === !0 || "auto" === o.force3D && 1 !== e && 0 !== e ? (this.setRatio = Ct, Ct.call(this, e), void 0) : (o.rotation || o.skewX ? (t = o.rotation * _, n = t - o.skewX * _, r = 1e5, i = o.scaleX * r, s = o.scaleY * r, a[bt] = "matrix(" + (0 | Math.cos(t) * i) / r + "," + (0 | Math.sin(t) * i) / r + "," + (0 | Math.sin(n) * -s) / r + "," + (0 | Math.cos(n) * s) / r + "," + o.x + "," + o.y + ")") : a[bt] = "matrix(" + o.scaleX + ",0,0," + o.scaleY + "," + o.x + "," + o.y + ")", void 0)
					};
				mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType", {
					parser: function(e, t, n, r, s, u, a) {
						if (r._transform) return s;
						var f, l, c, h, p, d, v, m = r._transform = Tt(e, i, !0, a.parseTransform),
							g = e.style,
							y = 1e-6,
							b = yt.length,
							w = a,
							E = {};
						if ("string" == typeof w.transform && bt) c = B.style, c[bt] = w.transform, c.display = "block", c.position = "absolute", H.body.appendChild(B), f = Tt(B, null, !1), H.body.removeChild(B);
						else if ("object" == typeof w) {
							if (f = {
									scaleX: rt(null != w.scaleX ? w.scaleX : w.scale, m.scaleX),
									scaleY: rt(null != w.scaleY ? w.scaleY : w.scale, m.scaleY),
									scaleZ: rt(w.scaleZ, m.scaleZ),
									x: rt(w.x, m.x),
									y: rt(w.y, m.y),
									z: rt(w.z, m.z),
									perspective: rt(w.transformPerspective, m.perspective)
								}, v = w.directionalRotation, null != v)
								if ("object" == typeof v)
									for (c in v) w[c] = v[c];
								else w.rotation = v;
							f.rotation = it("rotation" in w ? w.rotation : "shortRotation" in w ? w.shortRotation + "_short" : "rotationZ" in w ? w.rotationZ : m.rotation, m.rotation, "rotation", E), St && (f.rotationX = it("rotationX" in w ? w.rotationX : "shortRotationX" in w ? w.shortRotationX + "_short" : m.rotationX || 0, m.rotationX, "rotationX", E), f.rotationY = it("rotationY" in w ? w.rotationY : "shortRotationY" in w ? w.shortRotationY + "_short" : m.rotationY || 0, m.rotationY, "rotationY", E)), f.skewX = null == w.skewX ? m.skewX : it(w.skewX, m.skewX), f.skewY = null == w.skewY ? m.skewY : it(w.skewY, m.skewY), (l = f.skewY - m.skewY) && (f.skewX += l, f.rotation += l)
						}
						for (St && null != w.force3D && (m.force3D = w.force3D, d = !0), m.skewType = w.skewType || m.skewType || o.defaultSkewType, p = m.force3D || m.z || m.rotationX || m.rotationY || f.z || f.rotationX || f.rotationY || f.perspective, p || null == w.scale || (f.scaleZ = 1); --b > -1;) n = yt[b], h = f[n] - m[n], (h > y || -y > h || null != P[n]) && (d = !0, s = new ht(m, n, m[n], h, s), n in E && (s.e = E[n]), s.xs0 = 0, s.plugin = u, r._overwriteProps.push(s.n));
						return h = w.transformOrigin, (h || St && p && m.zOrigin) && (bt ? (d = !0, n = Et, h = (h || $(e, n, i, !1, "50% 50%")) + "", s = new ht(g, n, 0, 0, s, -1, "transformOrigin"), s.b = g[n], s.plugin = u, St ? (c = m.zOrigin, h = h.split(" "), m.zOrigin = (h.length > 2 && (0 === c || "0px" !== h[2]) ? parseFloat(h[2]) : c) || 0, s.xs0 = s.e = h[0] + " " + (h[1] || "50%") + " 0px", s = new ht(m, "zOrigin", 0, 0, s, -1, s.n), s.b = c, s.xs0 = s.e = m.zOrigin) : s.xs0 = s.e = h) : tt(h + "", m)), d && (r._transformType = p || 3 === this._transformType ? 3 : 2), s
					},
					prefix: !0
				}), mt("boxShadow", {
					defaultValue: "0px 0px 0px 0px #999",
					prefix: !0,
					color: !0,
					multi: !0,
					keyword: "inset"
				}), mt("borderRadius", {
					defaultValue: "0px",
					parser: function(e, t, n, s, o) {
						t = this.format(t);
						var u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
							T = e.style;
						for (v = parseFloat(e.offsetWidth), m = parseFloat(e.offsetHeight), u = t.split(" "), a = 0; x.length > a; a++) this.p.indexOf("border") && (x[a] = X(x[a])), c = l = $(e, x[a], i, !1, "0px"), -1 !== c.indexOf(" ") && (l = c.split(" "), c = l[0], l = l[1]), h = f = u[a], p = parseFloat(c), y = c.substr((p + "").length), b = "=" === h.charAt(1), b ? (d = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), d *= parseFloat(h), g = h.substr((d + "").length - (0 > d ? 1 : 0)) || "") : (d = parseFloat(h), g = h.substr((d + "").length)), "" === g && (g = r[n] || y), g !== y && (w = J(e, "borderLeft", p, y), E = J(e, "borderTop", p, y), "%" === g ? (c = 100 * (w / v) + "%", l = 100 * (E / m) + "%") : "em" === g ? (S = J(e, "borderLeft", 1, "em"), c = w / S + "em", l = E / S + "em") : (c = w + "px", l = E + "px"), b && (h = parseFloat(c) + d + g, f = parseFloat(l) + d + g)), o = pt(T, x[a], c + " " + l, h + " " + f, !1, "0px", o);
						return o
					},
					prefix: !0,
					formatter: ft("0px 0px 0px 0px", !1, !0)
				}), mt("backgroundPosition", {
					defaultValue: "0 0",
					parser: function(e, t, n, r, s, o) {
						var u, a, f, l, c, h, p = "background-position",
							v = i || V(e, null),
							m = this.format((v ? d ? v.getPropertyValue(p + "-x") + " " + v.getPropertyValue(p + "-y") : v.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
							g = this.format(t);
						if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && (h = $(e, "backgroundImage").replace(C, ""), h && "none" !== h)) {
							for (u = m.split(" "), a = g.split(" "), j.setAttribute("src", h), f = 2; --f > -1;) m = u[f], l = -1 !== m.indexOf("%"), l !== (-1 !== a[f].indexOf("%")) && (c = 0 === f ? e.offsetWidth - j.width : e.offsetHeight - j.height, u[f] = l ? parseFloat(m) / 100 * c + "px" : 100 * (parseFloat(m) / c) + "%");
							m = u.join(" ")
						}
						return this.parseComplex(e.style, m, g, s, o)
					},
					formatter: tt
				}), mt("backgroundSize", {
					defaultValue: "0 0",
					formatter: tt
				}), mt("perspective", {
					defaultValue: "0px",
					prefix: !0
				}), mt("perspectiveOrigin", {
					defaultValue: "50% 50%",
					prefix: !0
				}), mt("transformStyle", {
					prefix: !0
				}), mt("backfaceVisibility", {
					prefix: !0
				}), mt("userSelect", {
					prefix: !0
				}), mt("margin", {
					parser: lt("marginTop,marginRight,marginBottom,marginLeft")
				}), mt("padding", {
					parser: lt("paddingTop,paddingRight,paddingBottom,paddingLeft")
				}), mt("clip", {
					defaultValue: "rect(0px,0px,0px,0px)",
					parser: function(e, t, n, r, s, o) {
						var u, a, f;
						return 9 > d ? (a = e.currentStyle, f = 8 > d ? " " : ",", u = "rect(" + a.clipTop + f + a.clipRight + f + a.clipBottom + f + a.clipLeft + ")", t = this.format(t).split(",").join(f)) : (u = this.format($(e, this.p, i, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, u, t, s, o)
					}
				}), mt("textShadow", {
					defaultValue: "0px 0px 0px #999",
					color: !0,
					multi: !0
				}), mt("autoRound,strictUnits", {
					parser: function(e, t, n, r, i) {
						return i
					}
				}), mt("border", {
					defaultValue: "0px solid #000",
					parser: function(e, t, n, r, s, o) {
						return this.parseComplex(e.style, this.format($(e, "borderTopWidth", i, !1, "0px") + " " + $(e, "borderTopStyle", i, !1, "solid") + " " + $(e, "borderTopColor", i, !1, "#000")), this.format(t), s, o)
					},
					color: !0,
					formatter: function(e) {
						var t = e.split(" ");
						return t[0] + " " + (t[1] || "solid") + " " + (e.match(at) || ["#000"])[0]
					}
				}), mt("borderWidth", {
					parser: lt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
				}), mt("float,cssFloat,styleFloat", {
					parser: function(e, t, n, r, i) {
						var s = e.style,
							o = "cssFloat" in s ? "cssFloat" : "styleFloat";
						return new ht(s, o, 0, 0, i, -1, n, !1, 0, s[o], t)
					}
				});
				var Lt = function(e) {
					var t, n = this.t,
						r = n.filter || $(this.data, "filter"),
						i = 0 | this.s + this.c * e;
					100 === i && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (n.removeAttribute("filter"), t = !$(this.data, "filter")) : (n.filter = r.replace(S, ""), t = !0)), t || (this.xn1 && (n.filter = r = r || "alpha(opacity=" + i + ")"), -1 === r.indexOf("pacity") ? 0 === i && this.xn1 || (n.filter = r + " alpha(opacity=" + i + ")") : n.filter = r.replace(w, "opacity=" + i))
				};
				mt("opacity,alpha,autoAlpha", {
					defaultValue: "1",
					parser: function(e, t, n, r, s, o) {
						var u = parseFloat($(e, "opacity", i, !1, "1")),
							a = e.style,
							f = "autoAlpha" === n;
						return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + u), f && 1 === u && "hidden" === $(e, "visibility", i) && 0 !== t && (u = 0), q ? s = new ht(a, "opacity", u, t - u, s) : (s = new ht(a, "opacity", 100 * u, 100 * (t - u), s), s.xn1 = f ? 1 : 0, a.zoom = 1, s.type = 2, s.b = "alpha(opacity=" + s.s + ")", s.e = "alpha(opacity=" + (s.s + s.c) + ")", s.data = e, s.plugin = o, s.setRatio = Lt), f && (s = new ht(a, "visibility", 0, 0, s, -1, null, !1, 0, 0 !== u ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit"), s.xs0 = "inherit", r._overwriteProps.push(s.n), r._overwriteProps.push(n)), s
					}
				});
				var At = function(e, t) {
						t && (e.removeProperty ? ("ms" === t.substr(0, 2) && (t = "M" + t.substr(1)), e.removeProperty(t.replace(T, "-$1").toLowerCase())) : e.removeAttribute(t))
					},
					Ot = function(e) {
						if (this.t._gsClassPT = this, 1 === e || 0 === e) {
							this.t.setAttribute("class", 0 === e ? this.b : this.e);
							for (var t = this.data, n = this.t.style; t;) t.v ? n[t.p] = t.v : At(n, t.p), t = t._next;
							1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
						} else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
					};
				mt("className", {
					parser: function(e, t, r, s, o, u, a) {
						var f, l, c, h, p, d = e.getAttribute("class") || "",
							v = e.style.cssText;
						if (o = s._classNamePT = new ht(e, r, 0, 0, o, 2), o.setRatio = Ot, o.pr = -11, n = !0, o.b = d, l = Q(e, i), c = e._gsClassPT) {
							for (h = {}, p = c.data; p;) h[p.p] = 1, p = p._next;
							c.setRatio(1)
						}
						return e._gsClassPT = o, o.e = "=" !== t.charAt(1) ? t : d.replace(RegExp("\\s*\\b" + t.substr(2) + "\\b"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), s._tween._duration && (e.setAttribute("class", o.e), f = G(e, l, Q(e), a, h), e.setAttribute("class", d), o.data = f.firstMPT, e.style.cssText = v, o = o.xfirst = s.parse(e, f.difs, o, u)), o
					}
				});
				var Mt = function(e) {
					if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
						var t, n, r, i, s = this.t.style,
							o = u.transform.parse;
						if ("all" === this.e) s.cssText = "", i = !0;
						else
							for (t = this.e.split(","), r = t.length; --r > -1;) n = t[r], u[n] && (u[n].parse === o ? i = !0 : n = "transformOrigin" === n ? Et : u[n].p), At(s, n);
						i && (At(s, bt), this.t._gsTransform && delete this.t._gsTransform)
					}
				};
				for (mt("clearProps", {
						parser: function(e, t, r, i, s) {
							return s = new ht(e, r, 0, 0, s, 2), s.setRatio = Mt, s.e = t, s.pr = -10, s.data = i._tween, n = !0, s
						}
					}), a = "bezier,throwProps,physicsProps,physics2D".split(","), dt = a.length; dt--;) gt(a[dt]);
				a = o.prototype, a._firstPT = null, a._onInitTween = function(e, t, u) {
					if (!e.nodeType) return !1;
					this._target = e, this._tween = u, this._vars = t, f = t.autoRound, n = !1, r = t.suffixMap || o.suffixMap, i = V(e, ""), s = this._overwriteProps;
					var a, h, d, v, m, g, y, b, w, S = e.style;
					if (l && "" === S.zIndex && (a = $(e, "zIndex", i), ("auto" === a || "" === a) && this._addLazySet(S, "zIndex", 0)), "string" == typeof t && (v = S.cssText, a = Q(e, i), S.cssText = v + ";" + t, a = G(e, a, Q(e)).difs, !q && E.test(t) && (a.opacity = parseFloat(RegExp.$1)), t = a, S.cssText = v), this._firstPT = h = this.parse(e, t, null), this._transformType) {
						for (w = 3 === this._transformType, bt ? c && (l = !0, "" === S.zIndex && (y = $(e, "zIndex", i), ("auto" === y || "" === y) && this._addLazySet(S, "zIndex", 0)), p && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (w ? "visible" : "hidden"))) : S.zoom = 1, d = h; d && d._next;) d = d._next;
						b = new ht(e, "transform", 0, 0, null, 2), this._linkCSSP(b, null, d), b.setRatio = w && St ? Ct : bt ? kt : Nt, b.data = this._transform || Tt(e, i, !0), s.pop()
					}
					if (n) {
						for (; h;) {
							for (g = h._next, d = v; d && d.pr > h.pr;) d = d._next;
							(h._prev = d ? d._prev : m) ? h._prev._next = h: v = h, (h._next = d) ? d._prev = h : m = h, h = g
						}
						this._firstPT = v
					}
					return !0
				}, a.parse = function(e, t, n, s) {
					var o, a, l, c, h, p, d, v, m, g, y = e.style;
					for (o in t) p = t[o], a = u[o], a ? n = a.parse(e, p, o, this, n, s, t) : (h = $(e, o, i) + "", m = "string" == typeof p, "color" === o || "fill" === o || "stroke" === o || -1 !== o.indexOf("Color") || m && x.test(p) ? (m || (p = ut(p), p = (p.length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), n = pt(y, o, h, p, !0, "transparent", n, 0, s)) : !m || -1 === p.indexOf(" ") && -1 === p.indexOf(",") ? (l = parseFloat(h), d = l || 0 === l ? h.substr((l + "").length) : "", ("" === h || "auto" === h) && ("width" === o || "height" === o ? (l = et(e, o, i), d = "px") : "left" === o || "top" === o ? (l = K(e, o, i), d = "px") : (l = "opacity" !== o ? 0 : 1, d = "")), g = m && "=" === p.charAt(1), g ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), v = p.replace(b, "")) : (c = parseFloat(p), v = m ? p.substr((c + "").length) || "" : ""), "" === v && (v = o in r ? r[o] : d), p = c || 0 === c ? (g ? c + l : c) + v : t[o], d !== v && "" !== v && (c || 0 === c) && l && (l = J(e, o, l, d), "%" === v ? (l /= J(e, o, 100, "%") / 100, t.strictUnits !== !0 && (h = l + "%")) : "em" === v ? l /= J(e, o, 1, "em") : "px" !== v && (c = J(e, o, c, v), v = "px"), g && (c || 0 === c) && (p = c + l + v)), g && (c += l), !l && 0 !== l || !c && 0 !== c ? void 0 !== y[o] && (p || "NaN" != p + "" && null != p) ? (n = new ht(y, o, c || l || 0, 0, n, -1, o, !1, 0, h, p), n.xs0 = "none" !== p || "display" !== o && -1 === o.indexOf("Style") ? p : h) : U("invalid " + o + " tween value: " + t[o]) : (n = new ht(y, o, l, c - l, n, 0, o, f !== !1 && ("px" === v || "zIndex" === o), 0, h, p), n.xs0 = v)) : n = pt(y, o, h, p, !0, null, n, 0, s)), s && n && !n.plugin && (n.plugin = s);
					return n
				}, a.setRatio = function(e) {
					var t, n, r, i = this._firstPT,
						s = 1e-6;
					if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
						if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -0.000001)
							for (; i;) {
								if (t = i.c * e + i.s, i.r ? t = Math.round(t) : s > t && t > -s && (t = 0), i.type)
									if (1 === i.type)
										if (r = i.l, 2 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2;
										else if (3 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3;
								else if (4 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4;
								else if (5 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4 + i.xn4 + i.xs5;
								else {
									for (n = i.xs0 + t + i.xs1, r = 1; i.l > r; r++) n += i["xn" + r] + i["xs" + (r + 1)];
									i.t[i.p] = n
								} else - 1 === i.type ? i.t[i.p] = i.xs0 : i.setRatio && i.setRatio(e);
								else i.t[i.p] = t + i.xs0;
								i = i._next
							} else
								for (; i;) 2 !== i.type ? i.t[i.p] = i.b : i.setRatio(e), i = i._next;
						else
							for (; i;) 2 !== i.type ? i.t[i.p] = i.e : i.setRatio(e), i = i._next
				}, a._enableTransforms = function(e) {
					this._transformType = e || 3 === this._transformType ? 3 : 2, this._transform = this._transform || Tt(this._target, i, !0)
				};
				var _t = function() {
					this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
				};
				a._addLazySet = function(e, t, n) {
					var r = this._firstPT = new ht(e, t, 0, 0, this._firstPT, 2);
					r.e = n, r.setRatio = _t, r.data = this
				}, a._linkCSSP = function(e, t, n, r) {
					return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, r = !0), n ? n._next = e : r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = n), e
				}, a._kill = function(t) {
					var n, r, i, s = t;
					if (t.autoAlpha || t.alpha) {
						s = {};
						for (r in t) s[r] = t[r];
						s.opacity = 1, s.autoAlpha && (s.visibility = 1)
					}
					return t.className && (n = this._classNamePT) && (i = n.xfirst, i && i._prev ? this._linkCSSP(i._prev, n._next, i._prev._prev) : i === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, i._prev), this._classNamePT = null), e.prototype._kill.call(this, s)
				};
				var Dt = function(e, t, n) {
					var r, i, s, o;
					if (e.slice)
						for (i = e.length; --i > -1;) Dt(e[i], t, n);
					else
						for (r = e.childNodes, i = r.length; --i > -1;) s = r[i], o = s.type, s.style && (t.push(Q(s)), n && n.push(s)), 1 !== o && 9 !== o && 11 !== o || !s.childNodes.length || Dt(s, t, n)
				};
				return o.cascadeTo = function(e, n, r) {
					var i, s, o, u = t.to(e, n, r),
						a = [u],
						f = [],
						l = [],
						c = [],
						h = t._internals.reservedProps;
					for (e = u._targets || u.target, Dt(e, f, c), u.render(n, !0), Dt(e, l), u.render(0, !0), u._enabled(!0), i = c.length; --i > -1;)
						if (s = G(c[i], f[i], l[i]), s.firstMPT) {
							s = s.difs;
							for (o in r) h[o] && (s[o] = r[o]);
							a.push(t.to(c[i], n, s))
						} return a
				}, e.activate([o]), o
			}, !0),
			function() {
				var e = window._gsDefine.plugin({
						propName: "roundProps",
						priority: -1,
						API: 2,
						init: function(e, t, n) {
							return this._tween = n, !0
						}
					}),
					t = e.prototype;
				t._onInitAllProps = function() {
					for (var e, t, n, r = this._tween, i = r.vars.roundProps instanceof Array ? r.vars.roundProps : r.vars.roundProps.split(","), s = i.length, o = {}, u = r._propLookup.roundProps; --s > -1;) o[i[s]] = 1;
					for (s = i.length; --s > -1;)
						for (e = i[s], t = r._firstPT; t;) n = t._next, t.pg ? t.t._roundProps(o, !0) : t.n === e && (this._add(t.t, e, t.s, t.c), n && (n._prev = t._prev), t._prev ? t._prev._next = n : r._firstPT === t && (r._firstPT = n), t._next = t._prev = null, r._propLookup[e] = u), t = n;
					return !1
				}, t._add = function(e, t, n, r) {
					this._addTween(e, t, n, n + r, t, !0), this._overwriteProps.push(t)
				}
			}(), window._gsDefine.plugin({
				propName: "attr",
				API: 2,
				version: "0.3.2",
				init: function(e, t) {
					var n, r, i;
					if ("function" != typeof e.setAttribute) return !1;
					this._target = e, this._proxy = {}, this._start = {}, this._end = {};
					for (n in t) this._start[n] = this._proxy[n] = r = e.getAttribute(n), i = this._addTween(this._proxy, n, parseFloat(r), t[n], n), this._end[n] = i ? i.s + i.c : t[n], this._overwriteProps.push(n);
					return !0
				},
				set: function(e) {
					this._super.setRatio.call(this, e);
					for (var t, n = this._overwriteProps, r = n.length, i = 1 === e ? this._end : e ? this._proxy : this._start; --r > -1;) t = n[r], this._target.setAttribute(t, i[t] + "")
				}
			}), window._gsDefine.plugin({
				propName: "directionalRotation",
				API: 2,
				version: "0.2.0",
				init: function(e, t) {
					"object" != typeof t && (t = {
						rotation: t
					}), this.finals = {};
					var n, r, i, s, o, u, a = t.useRadians === !0 ? 2 * Math.PI : 360,
						f = 1e-6;
					for (n in t) "useRadians" !== n && (u = (t[n] + "").split("_"), r = u[0], i = parseFloat("function" != typeof e[n] ? e[n] : e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), s = this.finals[n] = "string" == typeof r && "=" === r.charAt(1) ? i + parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2)) : Number(r) || 0, o = s - i, u.length && (r = u.join("_"), -1 !== r.indexOf("short") && (o %= a, o !== o % (a / 2) && (o = 0 > o ? o + a : o - a)), -1 !== r.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * a) % a - (0 | o / a) * a : -1 !== r.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * a) % a - (0 | o / a) * a)), (o > f || -f > o) && (this._addTween(e, n, i, i + o, n), this._overwriteProps.push(n)));
					return !0
				},
				set: function(e) {
					var t;
					if (1 !== e) this._super.setRatio.call(this, e);
					else
						for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
				}
			})._autoCSS = !0, window._gsDefine("easing.Back", ["easing.Ease"], function(e) {
				var t, n, r, i = window.GreenSockGlobals || window,
					s = i.com.greensock,
					o = 2 * Math.PI,
					u = Math.PI / 2,
					a = s._class,
					f = function(t, n) {
						var r = a("easing." + t, function() {}, !0),
							i = r.prototype = new e;
						return i.constructor = r, i.getRatio = n, r
					},
					l = e.register || function() {},
					c = function(e, t, n, r) {
						var i = a("easing." + e, {
							easeOut: new t,
							easeIn: new n,
							easeInOut: new r
						}, !0);
						return l(i, e), i
					},
					h = function(e, t, n) {
						this.t = e, this.v = t, n && (this.next = n, n.prev = this, this.c = n.v - t, this.gap = n.t - e)
					},
					p = function(t, n) {
						var r = a("easing." + t, function(e) {
								this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
							}, !0),
							i = r.prototype = new e;
						return i.constructor = r, i.getRatio = n, i.config = function(e) {
							return new r(e)
						}, r
					},
					d = c("Back", p("BackOut", function(e) {
						return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
					}), p("BackIn", function(e) {
						return e * e * ((this._p1 + 1) * e - this._p1)
					}), p("BackInOut", function(e) {
						return 1 > (e *= 2) ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
					})),
					v = a("easing.SlowMo", function(e, t, n) {
						t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = n === !0
					}, !0),
					m = v.prototype = new e;
				return m.constructor = v, m.getRatio = function(e) {
					var t = e + (.5 - e) * this._p;
					return this._p1 > e ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
				}, v.ease = new v(.7, .7), m.config = v.config = function(e, t, n) {
					return new v(e, t, n)
				}, t = a("easing.SteppedEase", function(e) {
					e = e || 1, this._p1 = 1 / e, this._p2 = e + 1
				}, !0), m = t.prototype = new e, m.constructor = t, m.getRatio = function(e) {
					return 0 > e ? e = 0 : e >= 1 && (e = .999999999), (this._p2 * e >> 0) * this._p1
				}, m.config = t.config = function(e) {
					return new t(e)
				}, n = a("easing.RoughEase", function(t) {
					t = t || {};
					for (var n, r, i, s, o, u, a = t.taper || "none", f = [], l = 0, c = 0 | (t.points || 20), p = c, d = t.randomize !== !1, v = t.clamp === !0, m = t.template instanceof e ? t.template : null, g = "number" == typeof t.strength ? .4 * t.strength : .4; --p > -1;) n = d ? Math.random() : 1 / c * p, r = m ? m.getRatio(n) : n, "none" === a ? i = g : "out" === a ? (s = 1 - n, i = s * s * g) : "in" === a ? i = n * n * g : .5 > n ? (s = 2 * n, i = .5 * s * s * g) : (s = 2 * (1 - n), i = .5 * s * s * g), d ? r += Math.random() * i - .5 * i : p % 2 ? r += .5 * i : r -= .5 * i, v && (r > 1 ? r = 1 : 0 > r && (r = 0)), f[l++] = {
						x: n,
						y: r
					};
					for (f.sort(function(e, t) {
							return e.x - t.x
						}), u = new h(1, 1, null), p = c; --p > -1;) o = f[p], u = new h(o.x, o.y, u);
					this._prev = new h(0, 0, 0 !== u.t ? u : u.next)
				}, !0), m = n.prototype = new e, m.constructor = n, m.getRatio = function(e) {
					var t = this._prev;
					if (e > t.t) {
						for (; t.next && e >= t.t;) t = t.next;
						t = t.prev
					} else
						for (; t.prev && t.t >= e;) t = t.prev;
					return this._prev = t, t.v + (e - t.t) / t.gap * t.c
				}, m.config = function(e) {
					return new n(e)
				}, n.ease = new n, c("Bounce", f("BounceOut", function(e) {
					return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
				}), f("BounceIn", function(e) {
					return 1 / 2.75 > (e = 1 - e) ? 1 - 7.5625 * e * e : 2 / 2.75 > e ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
				}), f("BounceInOut", function(e) {
					var t = .5 > e;
					return e = t ? 1 - 2 * e : 2 * e - 1, e = 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
				})), c("Circ", f("CircOut", function(e) {
					return Math.sqrt(1 - (e -= 1) * e)
				}), f("CircIn", function(e) {
					return -(Math.sqrt(1 - e * e) - 1)
				}), f("CircInOut", function(e) {
					return 1 > (e *= 2) ? -0.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
				})), r = function(t, n, r) {
					var i = a("easing." + t, function(e, t) {
							this._p1 = e || 1, this._p2 = t || r, this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0)
						}, !0),
						s = i.prototype = new e;
					return s.constructor = i, s.getRatio = n, s.config = function(e, t) {
						return new i(e, t)
					}, i
				}, c("Elastic", r("ElasticOut", function(e) {
					return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * o / this._p2) + 1
				}, .3), r("ElasticIn", function(e) {
					return -(this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2))
				}, .3), r("ElasticInOut", function(e) {
					return 1 > (e *= 2) ? -0.5 * this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * o / this._p2) + 1
				}, .45)), c("Expo", f("ExpoOut", function(e) {
					return 1 - Math.pow(2, -10 * e)
				}), f("ExpoIn", function(e) {
					return Math.pow(2, 10 * (e - 1)) - .001
				}), f("ExpoInOut", function(e) {
					return 1 > (e *= 2) ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
				})), c("Sine", f("SineOut", function(e) {
					return Math.sin(e * u)
				}), f("SineIn", function(e) {
					return -Math.cos(e * u) + 1
				}), f("SineInOut", function(e) {
					return -0.5 * (Math.cos(Math.PI * e) - 1)
				})), a("easing.EaseLookup", {
					find: function(t) {
						return e.map[t]
					}
				}, !0), l(i.SlowMo, "SlowMo", "ease,"), l(n, "RoughEase", "ease,"), l(t, "SteppedEase", "ease,"), d
			}, !0)
	}),
	function(e) {
		var t = e.GreenSockGlobals || e;
		if (!t.TweenLite) {
			var n, r, i, s, o, u = function(e) {
					var n, r = e.split("."),
						i = t;
					for (n = 0; r.length > n; n++) i[r[n]] = i = i[r[n]] || {};
					return i
				},
				a = u("com.greensock"),
				f = 1e-10,
				l = [].slice,
				c = function() {},
				h = function() {
					var e = Object.prototype.toString,
						t = e.call([]);
					return function(n) {
						return null != n && (n instanceof Array || "object" == typeof n && !!n.push && e.call(n) === t)
					}
				}(),
				p = {},
				d = function(n, r, i, s) {
					this.sc = p[n] ? p[n].sc : [], p[n] = this, this.gsClass = null, this.func = i;
					var o = [];
					this.check = function(a) {
						for (var f, l, c, h, v = r.length, m = v; --v > -1;)(f = p[r[v]] || new d(r[v], [])).gsClass ? (o[v] = f.gsClass, m--) : a && f.sc.push(this);
						if (0 === m && i)
							for (l = ("com.greensock." + n).split("."), c = l.pop(), h = u(l.join("."))[c] = this.gsClass = i.apply(i, o), s && (t[c] = h, "function" == typeof define && define.amd ? define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/" : "") + n.split(".").join("/"), [], function() {
									return h
								}) : "undefined" != typeof module && module.exports && (module.exports = h)), v = 0; this.sc.length > v; v++) this.sc[v].check()
					}, this.check(!0)
				},
				v = e._gsDefine = function(e, t, n, r) {
					return new d(e, t, n, r)
				},
				m = a._class = function(e, t, n) {
					return t = t || function() {}, v(e, [], function() {
						return t
					}, n), t
				};
			v.globals = t;
			var g = [0, 0, 1, 1],
				y = [],
				b = m("easing.Ease", function(e, t, n, r) {
					this._func = e, this._type = n || 0, this._power = r || 0, this._params = t ? g.concat(t) : g
				}, !0),
				w = b.map = {},
				E = b.register = function(e, t, n, r) {
					for (var i, s, o, u, f = t.split(","), l = f.length, c = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
						for (s = f[l], i = r ? m("easing." + s, null, !0) : a.easing[s] || {}, o = c.length; --o > -1;) u = c[o], w[s + "." + u] = w[u + s] = i[u] = e.getRatio ? e : e[u] || new e
				};
			for (i = b.prototype, i._calcEnd = !1, i.getRatio = function(e) {
					if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
					var t = this._type,
						n = this._power,
						r = 1 === t ? 1 - e : 2 === t ? e : .5 > e ? 2 * e : 2 * (1 - e);
					return 1 === n ? r *= r : 2 === n ? r *= r * r : 3 === n ? r *= r * r * r : 4 === n && (r *= r * r * r * r), 1 === t ? 1 - r : 2 === t ? r : .5 > e ? r / 2 : 1 - r / 2
				}, n = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], r = n.length; --r > -1;) i = n[r] + ",Power" + r, E(new b(null, null, 1, r), i, "easeOut", !0), E(new b(null, null, 2, r), i, "easeIn" + (0 === r ? ",easeNone" : "")), E(new b(null, null, 3, r), i, "easeInOut");
			w.linear = a.easing.Linear.easeIn, w.swing = a.easing.Quad.easeInOut;
			var S = m("events.EventDispatcher", function(e) {
				this._listeners = {}, this._eventTarget = e || this
			});
			i = S.prototype, i.addEventListener = function(e, t, n, r, i) {
				i = i || 0;
				var u, a, f = this._listeners[e],
					l = 0;
				for (null == f && (this._listeners[e] = f = []), a = f.length; --a > -1;) u = f[a], u.c === t && u.s === n ? f.splice(a, 1) : 0 === l && i > u.pr && (l = a + 1);
				f.splice(l, 0, {
					c: t,
					s: n,
					up: r,
					pr: i
				}), this !== s || o || s.wake()
			}, i.removeEventListener = function(e, t) {
				var n, r = this._listeners[e];
				if (r)
					for (n = r.length; --n > -1;)
						if (r[n].c === t) return r.splice(n, 1), void 0
			}, i.dispatchEvent = function(e) {
				var t, n, r, i = this._listeners[e];
				if (i)
					for (t = i.length, n = this._eventTarget; --t > -1;) r = i[t], r.up ? r.c.call(r.s || n, {
						type: e,
						target: n
					}) : r.c.call(r.s || n)
			};
			var x = e.requestAnimationFrame,
				T = e.cancelAnimationFrame,
				N = Date.now || function() {
					return (new Date).getTime()
				},
				C = N();
			for (n = ["ms", "moz", "webkit", "o"], r = n.length; --r > -1 && !x;) x = e[n[r] + "RequestAnimationFrame"], T = e[n[r] + "CancelAnimationFrame"] || e[n[r] + "CancelRequestAnimationFrame"];
			m("Ticker", function(e, t) {
				var n, r, i, u, a, l = this,
					h = N(),
					p = t !== !1 && x,
					d = 500,
					v = 33,
					m = function(e) {
						var t, s, o = N() - C;
						o > d && (h += o - v), C += o, l.time = (C - h) / 1e3, t = l.time - a, (!n || t > 0 || e === !0) && (l.frame++, a += t + (t >= u ? .004 : u - t), s = !0), e !== !0 && (i = r(m)), s && l.dispatchEvent("tick")
					};
				S.call(l), l.time = l.frame = 0, l.tick = function() {
					m(!0)
				}, l.lagSmoothing = function(e, t) {
					d = e || 1 / f, v = Math.min(t, d, 0)
				}, l.sleep = function() {
					null != i && (p && T ? T(i) : clearTimeout(i), r = c, i = null, l === s && (o = !1))
				}, l.wake = function() {
					null !== i ? l.sleep() : l.frame > 10 && (C = N() - d + 5), r = 0 === n ? c : p && x ? x : function(e) {
						return setTimeout(e, 0 | 1e3 * (a - l.time) + 1)
					}, l === s && (o = !0), m(2)
				}, l.fps = function(e) {
					return arguments.length ? (n = e, u = 1 / (n || 60), a = this.time + u, l.wake(), void 0) : n
				}, l.useRAF = function(e) {
					return arguments.length ? (l.sleep(), p = e, l.fps(n), void 0) : p
				}, l.fps(e), setTimeout(function() {
					p && (!i || 5 > l.frame) && l.useRAF(!1)
				}, 1500)
			}), i = a.Ticker.prototype = new a.events.EventDispatcher, i.constructor = a.Ticker;
			var k = m("core.Animation", function(e, t) {
				if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, U) {
					o || s.wake();
					var n = this.vars.useFrames ? R : U;
					n.add(this, n._time), this.vars.paused && this.paused(!0)
				}
			});
			s = k.ticker = new a.Ticker, i = k.prototype, i._dirty = i._gc = i._initted = i._paused = !1, i._totalTime = i._time = 0, i._rawPrevTime = -1, i._next = i._last = i._onUpdate = i._timeline = i.timeline = null, i._paused = !1;
			var L = function() {
				o && N() - C > 2e3 && s.wake(), setTimeout(L, 2e3)
			};
			L(), i.play = function(e, t) {
				return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
			}, i.pause = function(e, t) {
				return null != e && this.seek(e, t), this.paused(!0)
			}, i.resume = function(e, t) {
				return null != e && this.seek(e, t), this.paused(!1)
			}, i.seek = function(e, t) {
				return this.totalTime(Number(e), t !== !1)
			}, i.restart = function(e, t) {
				return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, t !== !1, !0)
			}, i.reverse = function(e, t) {
				return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
			}, i.render = function() {}, i.invalidate = function() {
				return this
			}, i.isActive = function() {
				var e, t = this._timeline,
					n = this._startTime;
				return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime()) >= n && n + this.totalDuration() / this._timeScale > e
			}, i._enabled = function(e, t) {
				return o || s.wake(), this._gc = !e, this._active = this.isActive(), t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
			}, i._kill = function() {
				return this._enabled(!1, !1)
			}, i.kill = function(e, t) {
				return this._kill(e, t), this
			}, i._uncache = function(e) {
				for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
				return this
			}, i._swapSelfInParams = function(e) {
				for (var t = e.length, n = e.concat(); --t > -1;) "{self}" === e[t] && (n[t] = this);
				return n
			}, i.eventCallback = function(e, t, n, r) {
				if ("on" === (e || "").substr(0, 2)) {
					var i = this.vars;
					if (1 === arguments.length) return i[e];
					null == t ? delete i[e] : (i[e] = t, i[e + "Params"] = h(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, i[e + "Scope"] = r), "onUpdate" === e && (this._onUpdate = t)
				}
				return this
			}, i.delay = function(e) {
				return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
			}, i.duration = function(e) {
				return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
			}, i.totalDuration = function(e) {
				return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
			}, i.time = function(e, t) {
				return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
			}, i.totalTime = function(e, t, n) {
				if (o || s.wake(), !arguments.length) return this._totalTime;
				if (this._timeline) {
					if (0 > e && !n && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
						this._dirty && this.totalDuration();
						var r = this._totalDuration,
							i = this._timeline;
						if (e > r && !n && (e = r), this._startTime = (this._paused ? this._pauseTime : i._time) - (this._reversed ? r - e : e) / this._timeScale, i._dirty || this._uncache(!1), i._timeline)
							for (; i._timeline;) i._timeline._time !== (i._startTime + i._totalTime) / i._timeScale && i.totalTime(i._totalTime, !0), i = i._timeline
					}
					this._gc && this._enabled(!0, !1), (this._totalTime !== e || 0 === this._duration) && (this.render(e, t, !1), D.length && z())
				}
				return this
			}, i.progress = i.totalProgress = function(e, t) {
				return arguments.length ? this.totalTime(this.duration() * e, t) : this._time / this.duration()
			}, i.startTime = function(e) {
				return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
			}, i.timeScale = function(e) {
				if (!arguments.length) return this._timeScale;
				if (e = e || f, this._timeline && this._timeline.smoothChildTiming) {
					var t = this._pauseTime,
						n = t || 0 === t ? t : this._timeline.totalTime();
					this._startTime = n - (n - this._startTime) * this._timeScale / e
				}
				return this._timeScale = e, this._uncache(!1)
			}, i.reversed = function(e) {
				return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
			}, i.paused = function(e) {
				if (!arguments.length) return this._paused;
				if (e != this._paused && this._timeline) {
					o || e || s.wake();
					var t = this._timeline,
						n = t.rawTime(),
						r = n - this._pauseTime;
					!e && t.smoothChildTiming && (this._startTime += r, this._uncache(!1)), this._pauseTime = e ? n : null, this._paused = e, this._active = this.isActive(), !e && 0 !== r && this._initted && this.duration() && this.render(t.smoothChildTiming ? this._totalTime : (n - this._startTime) / this._timeScale, !0, !0)
				}
				return this._gc && !e && this._enabled(!0, !1), this
			};
			var A = m("core.SimpleTimeline", function(e) {
				k.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
			});
			i = A.prototype = new k, i.constructor = A, i.kill()._gc = !1, i._first = i._last = null, i._sortChildren = !1, i.add = i.insert = function(e, t) {
				var n, r;
				if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = e._startTime + (this.rawTime() - e._startTime) / e._timeScale), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), n = this._last, this._sortChildren)
					for (r = e._startTime; n && n._startTime > r;) n = n._prev;
				return n ? (e._next = n._next, n._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = n, this._timeline && this._uncache(!0), this
			}, i._remove = function(e, t) {
				return e.timeline === this && (t || e._enabled(!1, !0), e.timeline = null, e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), this._timeline && this._uncache(!0)), this
			}, i.render = function(e, t, n) {
				var r, i = this._first;
				for (this._totalTime = this._time = this._rawPrevTime = e; i;) r = i._next, (i._active || e >= i._startTime && !i._paused) && (i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)), i = r
			}, i.rawTime = function() {
				return o || s.wake(), this._totalTime
			};
			var O = m("TweenLite", function(t, n, r) {
					if (k.call(this, n, r), this.render = O.prototype.render, null == t) throw "Cannot tween a null target.";
					this.target = t = "string" != typeof t ? t : O.selector(t) || t;
					var i, s, o, u = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
						a = this.vars.overwrite;
					if (this._overwrite = a = null == a ? q[O.defaultOverwrite] : "number" == typeof a ? a >> 0 : q[a], (u || t instanceof Array || t.push && h(t)) && "number" != typeof t[0])
						for (this._targets = o = l.call(t, 0), this._propLookup = [], this._siblings = [], i = 0; o.length > i; i++) s = o[i], s ? "string" != typeof s ? s.length && s !== e && s[0] && (s[0] === e || s[0].nodeType && s[0].style && !s.nodeType) ? (o.splice(i--, 1), this._targets = o = o.concat(l.call(s, 0))) : (this._siblings[i] = W(s, this, !1), 1 === a && this._siblings[i].length > 1 && X(s, this, null, 1, this._siblings[i])) : (s = o[i--] = O.selector(s), "string" == typeof s && o.splice(i + 1, 1)) : o.splice(i--, 1);
					else this._propLookup = {}, this._siblings = W(t, this, !1), 1 === a && this._siblings.length > 1 && X(t, this, null, 1, this._siblings);
					(this.vars.immediateRender || 0 === n && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -f, this.render(-this._delay))
				}, !0),
				M = function(t) {
					return t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
				},
				_ = function(e, t) {
					var n, r = {};
					for (n in e) I[n] || n in t && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!B[n] || B[n] && B[n]._autoCSS) || (r[n] = e[n], delete e[n]);
					e.css = r
				};
			i = O.prototype = new k, i.constructor = O, i.kill()._gc = !1, i.ratio = 0, i._firstPT = i._targets = i._overwrittenProps = i._startAt = null, i._notifyPluginsOfEnabled = i._lazy = !1, O.version = "1.12.1", O.defaultEase = i._ease = new b(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = s, O.autoSleep = !0, O.lagSmoothing = function(e, t) {
				s.lagSmoothing(e, t)
			}, O.selector = e.$ || e.jQuery || function(t) {
				return e.$ ? (O.selector = e.$, e.$(t)) : e.document ? e.document.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t
			};
			var D = [],
				P = {},
				H = O._internals = {
					isArray: h,
					isSelector: M,
					lazyTweens: D
				},
				B = O._plugins = {},
				j = H.tweenLookup = {},
				F = 0,
				I = H.reservedProps = {
					ease: 1,
					delay: 1,
					overwrite: 1,
					onComplete: 1,
					onCompleteParams: 1,
					onCompleteScope: 1,
					useFrames: 1,
					runBackwards: 1,
					startAt: 1,
					onUpdate: 1,
					onUpdateParams: 1,
					onUpdateScope: 1,
					onStart: 1,
					onStartParams: 1,
					onStartScope: 1,
					onReverseComplete: 1,
					onReverseCompleteParams: 1,
					onReverseCompleteScope: 1,
					onRepeat: 1,
					onRepeatParams: 1,
					onRepeatScope: 1,
					easeParams: 1,
					yoyo: 1,
					immediateRender: 1,
					repeat: 1,
					repeatDelay: 1,
					data: 1,
					paused: 1,
					reversed: 1,
					autoCSS: 1,
					lazy: 1
				},
				q = {
					none: 0,
					all: 1,
					auto: 2,
					concurrent: 3,
					allOnStart: 4,
					preexisting: 5,
					"true": 1,
					"false": 0
				},
				R = k._rootFramesTimeline = new A,
				U = k._rootTimeline = new A,
				z = function() {
					var e = D.length;
					for (P = {}; --e > -1;) n = D[e], n && n._lazy !== !1 && (n.render(n._lazy, !1, !0), n._lazy = !1);
					D.length = 0
				};
			U._startTime = s.time, R._startTime = s.frame, U._active = R._active = !0, setTimeout(z, 1), k._updateRoot = O.render = function() {
				var e, t, n;
				if (D.length && z(), U.render((s.time - U._startTime) * U._timeScale, !1, !1), R.render((s.frame - R._startTime) * R._timeScale, !1, !1), D.length && z(), !(s.frame % 120)) {
					for (n in j) {
						for (t = j[n].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
						0 === t.length && delete j[n]
					}
					if (n = U._first, (!n || n._paused) && O.autoSleep && !R._first && 1 === s._listeners.tick.length) {
						for (; n && n._paused;) n = n._next;
						n || s.sleep()
					}
				}
			}, s.addEventListener("tick", k._updateRoot);
			var W = function(e, t, n) {
					var r, i, s = e._gsTweenID;
					if (j[s || (e._gsTweenID = s = "t" + F++)] || (j[s] = {
							target: e,
							tweens: []
						}), t && (r = j[s].tweens, r[i = r.length] = t, n))
						for (; --i > -1;) r[i] === t && r.splice(i, 1);
					return j[s].tweens
				},
				X = function(e, t, n, r, i) {
					var s, o, u, a;
					if (1 === r || r >= 4) {
						for (a = i.length, s = 0; a > s; s++)
							if ((u = i[s]) !== t) u._gc || u._enabled(!1, !1) && (o = !0);
							else if (5 === r) break;
						return o
					}
					var l, c = t._startTime + f,
						h = [],
						p = 0,
						d = 0 === t._duration;
					for (s = i.length; --s > -1;)(u = i[s]) === t || u._gc || u._paused || (u._timeline !== t._timeline ? (l = l || V(t, 0, d), 0 === V(u, l, d) && (h[p++] = u)) : c >= u._startTime && u._startTime + u.totalDuration() / u._timeScale > c && ((d || !u._initted) && 2e-10 >= c - u._startTime || (h[p++] = u)));
					for (s = p; --s > -1;) u = h[s], 2 === r && u._kill(n, e) && (o = !0), (2 !== r || !u._firstPT && u._initted) && u._enabled(!1, !1) && (o = !0);
					return o
				},
				V = function(e, t, n) {
					for (var r = e._timeline, i = r._timeScale, s = e._startTime; r._timeline;) {
						if (s += r._startTime, i *= r._timeScale, r._paused) return -100;
						r = r._timeline
					}
					return s /= i, s > t ? s - t : n && s === t || !e._initted && 2 * f > s - t ? f : (s += e.totalDuration() / e._timeScale / i) > t + f ? 0 : s - t - f
				};
			i._init = function() {
				var e, t, n, r, i, s = this.vars,
					o = this._overwrittenProps,
					u = this._duration,
					a = !!s.immediateRender,
					f = s.ease;
				if (s.startAt) {
					this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), i = {};
					for (r in s.startAt) i[r] = s.startAt[r];
					if (i.overwrite = !1, i.immediateRender = !0, i.lazy = a && s.lazy !== !1, i.startAt = i.delay = null, this._startAt = O.to(this.target, 0, i), a)
						if (this._time > 0) this._startAt = null;
						else if (0 !== u) return
				} else if (s.runBackwards && 0 !== u)
					if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
					else {
						n = {};
						for (r in s) I[r] && "autoCSS" !== r || (n[r] = s[r]);
						if (n.overwrite = 0, n.data = "isFromStart", n.lazy = a && s.lazy !== !1, n.immediateRender = a, this._startAt = O.to(this.target, 0, n), a) {
							if (0 === this._time) return
						} else this._startAt._init(), this._startAt._enabled(!1)
					} if (this._ease = f ? f instanceof b ? s.easeParams instanceof Array ? f.config.apply(f, s.easeParams) : f : "function" == typeof f ? new b(f, s.easeParams) : w[f] || O.defaultEase : O.defaultEase, this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
					for (e = this._targets.length; --e > -1;) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], o ? o[e] : null) && (t = !0);
				else t = this._initProps(this.target, this._propLookup, this._siblings, o);
				if (t && O._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
					for (n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
				this._onUpdate = s.onUpdate, this._initted = !0
			}, i._initProps = function(t, n, r, i) {
				var s, o, u, a, f, l;
				if (null == t) return !1;
				P[t._gsTweenID] && z(), this.vars.css || t.style && t !== e && t.nodeType && B.css && this.vars.autoCSS !== !1 && _(this.vars, t);
				for (s in this.vars) {
					if (l = this.vars[s], I[s]) l && (l instanceof Array || l.push && h(l)) && -1 !== l.join("").indexOf("{self}") && (this.vars[s] = l = this._swapSelfInParams(l, this));
					else if (B[s] && (a = new B[s])._onInitTween(t, this.vars[s], this)) {
						for (this._firstPT = f = {
								_next: this._firstPT,
								t: a,
								p: "setRatio",
								s: 0,
								c: 1,
								f: !0,
								n: s,
								pg: !0,
								pr: a._priority
							}, o = a._overwriteProps.length; --o > -1;) n[a._overwriteProps[o]] = this._firstPT;
						(a._priority || a._onInitAllProps) && (u = !0), (a._onDisable || a._onEnable) && (this._notifyPluginsOfEnabled = !0)
					} else this._firstPT = n[s] = f = {
						_next: this._firstPT,
						t: t,
						p: s,
						f: "function" == typeof t[s],
						n: s,
						pg: !1,
						pr: 0
					}, f.s = f.f ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), f.c = "string" == typeof l && "=" === l.charAt(1) ? parseInt(l.charAt(0) + "1", 10) * Number(l.substr(2)) : Number(l) - f.s || 0;
					f && f._next && (f._next._prev = f)
				}
				return i && this._kill(i, t) ? this._initProps(t, n, r, i) : this._overwrite > 1 && this._firstPT && r.length > 1 && X(t, this, n, this._overwrite, r) ? (this._kill(n, t), this._initProps(t, n, r, i)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (P[t._gsTweenID] = !0), u)
			}, i.render = function(e, t, n) {
				var r, i, s, o, u = this._time,
					a = this._duration,
					l = this._rawPrevTime;
				if (e >= a) this._totalTime = this._time = a, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, i = "onComplete"), 0 === a && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 === e || 0 > l || l === f) && l !== e && (n = !0, l > f && (i = "onReverseComplete")), this._rawPrevTime = o = !t || e || l === e ? e : f);
				else if (1e-7 > e) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== u || 0 === a && l > 0 && l !== f) && (i = "onReverseComplete", r = this._reversed), 0 > e ? (this._active = !1, 0 === a && (this._initted || !this.vars.lazy || n) && (l >= 0 && (n = !0), this._rawPrevTime = o = !t || e || l === e ? e : f)) : this._initted || (n = !0);
				else if (this._totalTime = this._time = e, this._easeType) {
					var c = e / a,
						h = this._easeType,
						p = this._easePower;
					(1 === h || 3 === h && c >= .5) && (c = 1 - c), 3 === h && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), this.ratio = 1 === h ? 1 - c : 2 === h ? c : .5 > e / a ? c / 2 : 1 - c / 2
				} else this.ratio = this._ease.getRatio(e / a);
				if (this._time !== u || n) {
					if (!this._initted) {
						if (this._init(), !this._initted || this._gc) return;
						if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = u, this._rawPrevTime = l, D.push(this), this._lazy = e, void 0;
						this._time && !r ? this.ratio = this._ease.getRatio(this._time / a) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
					}
					for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== u && e >= 0 && (this._active = !0), 0 === u && (this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === a) && (t || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || y))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
					this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, n), t || (this._time !== u || r) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || y)), i && (this._gc || (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this.vars[i].apply(this.vars[i + "Scope"] || this, this.vars[i + "Params"] || y), 0 === a && this._rawPrevTime === f && o !== f && (this._rawPrevTime = 0)))
				}
			}, i._kill = function(e, t) {
				if ("all" === e && (e = null), null != e || null != t && t !== this.target) {
					t = "string" != typeof t ? t || this._targets || this.target : O.selector(t) || t;
					var n, r, i, s, o, u, a, f;
					if ((h(t) || M(t)) && "number" != typeof t[0])
						for (n = t.length; --n > -1;) this._kill(e, t[n]) && (u = !0);
					else {
						if (this._targets) {
							for (n = this._targets.length; --n > -1;)
								if (t === this._targets[n]) {
									o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = e ? this._overwrittenProps[n] || {} : "all";
									break
								}
						} else {
							if (t !== this.target) return !1;
							o = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
						}
						if (o) {
							a = e || o, f = e !== r && "all" !== r && e !== o && ("object" != typeof e || !e._tempKill);
							for (i in a)(s = o[i]) && (s.pg && s.t._kill(a) && (u = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete o[i]), f && (r[i] = 1);
							!this._firstPT && this._initted && this._enabled(!1, !1)
						}
					}
					return u
				}
				return this._lazy = !1, this._enabled(!1, !1)
			}, i.invalidate = function() {
				return this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = this._lazy = !1, this._propLookup = this._targets ? {} : [], this
			}, i._enabled = function(e, t) {
				if (o || s.wake(), e && this._gc) {
					var n, r = this._targets;
					if (r)
						for (n = r.length; --n > -1;) this._siblings[n] = W(r[n], this, !0);
					else this._siblings = W(this.target, this, !0)
				}
				return k.prototype._enabled.call(this, e, t), this._notifyPluginsOfEnabled && this._firstPT ? O._onPluginEvent(e ? "_onEnable" : "_onDisable", this) : !1
			}, O.to = function(e, t, n) {
				return new O(e, t, n)
			}, O.from = function(e, t, n) {
				return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new O(e, t, n)
			}, O.fromTo = function(e, t, n, r) {
				return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new O(e, t, r)
			}, O.delayedCall = function(e, t, n, r, i) {
				return new O(t, 0, {
					delay: e,
					onComplete: t,
					onCompleteParams: n,
					onCompleteScope: r,
					onReverseComplete: t,
					onReverseCompleteParams: n,
					onReverseCompleteScope: r,
					immediateRender: !1,
					useFrames: i,
					overwrite: 0
				})
			}, O.set = function(e, t) {
				return new O(e, 0, t)
			}, O.getTweensOf = function(e, t) {
				if (null == e) return [];
				e = "string" != typeof e ? e : O.selector(e) || e;
				var n, r, i, s;
				if ((h(e) || M(e)) && "number" != typeof e[0]) {
					for (n = e.length, r = []; --n > -1;) r = r.concat(O.getTweensOf(e[n], t));
					for (n = r.length; --n > -1;)
						for (s = r[n], i = n; --i > -1;) s === r[i] && r.splice(n, 1)
				} else
					for (r = W(e).concat(), n = r.length; --n > -1;)(r[n]._gc || t && !r[n].isActive()) && r.splice(n, 1);
				return r
			}, O.killTweensOf = O.killDelayedCallsTo = function(e, t, n) {
				"object" == typeof t && (n = t, t = !1);
				for (var r = O.getTweensOf(e, t), i = r.length; --i > -1;) r[i]._kill(n, e)
			};
			var $ = m("plugins.TweenPlugin", function(e, t) {
				this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = $.prototype
			}, !0);
			if (i = $.prototype, $.version = "1.10.1", $.API = 2, i._firstPT = null, i._addTween = function(e, t, n, r, i, s) {
					var o, u;
					return null != r && (o = "number" == typeof r || "=" !== r.charAt(1) ? Number(r) - n : parseInt(r.charAt(0) + "1", 10) * Number(r.substr(2))) ? (this._firstPT = u = {
						_next: this._firstPT,
						t: e,
						p: t,
						s: n,
						c: o,
						f: "function" == typeof e[t],
						n: i || t,
						r: s
					}, u._next && (u._next._prev = u), u) : void 0
				}, i.setRatio = function(e) {
					for (var t, n = this._firstPT, r = 1e-6; n;) t = n.c * e + n.s, n.r ? t = Math.round(t) : r > t && t > -r && (t = 0), n.f ? n.t[n.p](t) : n.t[n.p] = t, n = n._next
				}, i._kill = function(e) {
					var t, n = this._overwriteProps,
						r = this._firstPT;
					if (null != e[this._propName]) this._overwriteProps = [];
					else
						for (t = n.length; --t > -1;) null != e[n[t]] && n.splice(t, 1);
					for (; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
					return !1
				}, i._roundProps = function(e, t) {
					for (var n = this._firstPT; n;)(e[this._propName] || null != n.n && e[n.n.split(this._propName + "_").join("")]) && (n.r = t), n = n._next
				}, O._onPluginEvent = function(e, t) {
					var n, r, i, s, o, u = t._firstPT;
					if ("_onInitAllProps" === e) {
						for (; u;) {
							for (o = u._next, r = i; r && r.pr > u.pr;) r = r._next;
							(u._prev = r ? r._prev : s) ? u._prev._next = u: i = u, (u._next = r) ? r._prev = u : s = u, u = o
						}
						u = t._firstPT = i
					}
					for (; u;) u.pg && "function" == typeof u.t[e] && u.t[e]() && (n = !0), u = u._next;
					return n
				}, $.activate = function(e) {
					for (var t = e.length; --t > -1;) e[t].API === $.API && (B[(new e[t])._propName] = e[t]);
					return !0
				}, v.plugin = function(e) {
					if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
					var t, n = e.propName,
						r = e.priority || 0,
						i = e.overwriteProps,
						s = {
							init: "_onInitTween",
							set: "setRatio",
							kill: "_kill",
							round: "_roundProps",
							initAll: "_onInitAllProps"
						},
						o = m("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function() {
							$.call(this, n, r), this._overwriteProps = i || []
						}, e.global === !0),
						u = o.prototype = new $(n);
					u.constructor = o, o.API = e.API;
					for (t in s) "function" == typeof e[t] && (u[s[t]] = e[t]);
					return o.version = e.version, $.activate([o]), o
				}, n = e._gsQueue) {
				for (r = 0; n.length > r; r++) n[r]();
				for (i in p) p[i].func || e.console.log("GSAP encountered missing dependency: com.greensock." + i)
			}
			o = !1
		}
	}(window), define("gsap", function() {}), define("app/expManivelle", ["app/scene", "app/sfx", "app/pubsub", "jquery", "gsap", "three"], function(e, t) {
		var n = e.camera,
			r = undefined,
			i = undefined,
			s = undefined,
			o = function() {
				var e = $('<img src="/img-curtain.png" class="bottom-curtain">')[0],
					t = $('<img src="/img-curtain.png" class="top-curtain">')[0];
				$(".exp-manivelle").append(t), $(".exp-manivelle").append(e);
				var n = function() {
						if (!r) return;
						var n = 100 - Math.round(audio.source.playbackRate.value * 100);
						t.style.webkitTransform = "translate3d(0px, -" + n + "%, 0px) scaleY(-1)", t.style.transform = "translate3d(0px, -" + n + "%, 0px) scaleY(-1)", e.style.webkitTransform = "translate3d(0px,  " + n + "%, 0px)", e.style.transform = "translate3d(0px,  " + n + "%, 0px)"
					},
					i = function() {
						t.style.webkitTransform = "translate3d(0px, -100%, 0px) scaleY(-1)", t.style.transform = "translate3d(0px, -100%, 0px) scaleY(-1)", e.style.webkitTransform = "translate3d(0px, 100%, 0px)", e.style.transform = "translate3d(0px, 100%, 0px)", TweenLite.set([t, e], {
							opacity: 1,
							display: "block"
						})
					},
					s = function() {
						TweenLite.to([t, e], 1, {
							opacity: 0,
							onComplete: function() {
								$(t).hide(), $(e).hide()
							}
						})
					},
					o = !1,
					u = function() {
						if (o) return;
						requestAnimationFrame(u);
						if (!audio) return;
						audio.source.playbackRate.value -= audio.source.playbackRate.value > 0 ? .005 : 0, audio.source.playbackRate.value < .001 && (audio.source.playbackRate.value = .001), audio.beatSource.playbackRate.value = audio.source.playbackRate.value, n()
					};
				u();
				var a = function(e, t) {
					if (!audio) return;
					audio.source.playbackRate.value -= t / 1e3, audio.source.playbackRate.value < .001 && (audio.source.playbackRate.value = .001), audio.source.playbackRate.value >= 1 && ($.unsubscribe("wind", a), o = !0, audio.source.playbackRate.value = 1, s(), $.publish("freeMode"), $.publish("messageOn", ["Click here if you're lost", "img-char_005.png", 200, "menu", 50])), audio.beatSource.playbackRate.value = audio.source.playbackRate.value, $.publish("speedChange", [audio.source.playbackRate.value])
				};
				$.subscribe("wind", a);
				var f = function(e, t) {
					r.rotation.x += t * Math.PI / 180, r.rotation.x += r.rotation.x > Math.PI / 2 ? -Math.PI * 2 : r.rotation.x < -Math.PI * 3 / 2 ? Math.PI * 2 : 0
				};
				$.subscribe("wind", f), $.subscribe("reset", function() {
					$.subscribe("wind", a), o = !1, i(), u()
				})
			},
			u = !0;
		$.subscribe("windstart", function() {
			u = !1
		}), $.subscribe("windend", function() {
			u = !0
		});
		var a = 0,
			f = function() {
				if (!r) return;
				if (!u) {
					a = 0;
					return
				}
				var e = -Math.PI / 2 - r.rotation.x,
					t = Math.PI / 3;
				e = e < -t ? -t : e > t ? t : e, a += e * .03, a *= .95, r.rotation.x += a
			},
			l = function() {
				i.rotation.y = Math.PI / 5, i.children[1].rotation.z = Math.PI / 5;
				var e = function(e, t) {
					i.rotation.y += t.x * Math.PI / 180 * .5, i.rotation.y = i.rotation.y < -Math.PI / 2 ? -Math.PI / 2 : i.rotation.y > Math.PI / 5 ? Math.PI / 5 : i.rotation.y, i.children[1].rotation.z -= t.y * Math.PI / 180 * .5, i.children[1].rotation.z = i.children[1].rotation.z < 0 ? 0 : i.children[1].rotation.z > Math.PI / 5 ? Math.PI / 5 : i.children[1].rotation.z
				};
				$.subscribe("slider", e)
			},
			c = !1;
		$.subscribe("sliderstart", function() {
			c = !1
		}), $.subscribe("sliderend", function() {
			c = !0, t.squeak()
		});
		var h = 0,
			p = 0,
			d = 0,
			v = 0,
			m = 0,
			g = 0,
			y = function() {
				if (!i) return;
				if (!c) {
					h = 0, p = i.rotation.y, d = 5 + Math.abs(Math.round(i.rotation.y * 180 / Math.PI / 2)), v = 0, m = i.children[1].rotation.z, g = Math.abs(Math.round(i.children[1].rotation.z * 180 / Math.PI));
					return
				}
				i.rotation.y != 0 && (i.rotation.y = easing.easeInOutCubic(h, p, -p, d), h++, h > d && (i.rotation.y = 0)), Math.abs(i.rotation.y) < Math.PI / 6 && i.children[1].rotation.z != 0 && (i.children[1].rotation.z = easing.easeInOutCubic(v, m, -m, g), v++, v > g && (i.children[1].rotation.z = 0))
			};
		$.subscribe("reset", function() {
			c = !1, i.rotation.y = Math.PI / 5, i.children[1].rotation.z = Math.PI / 5
		});
		var b = function() {
			f(), y()
		};
		return {
			manivelle: function(e) {
				r = e, o()
			},
			arm: function(e) {
				i = e, l()
			},
			update: b
		}
	}), define("app/expKeyboard", ["app/sfx", "app/scene", "jquery", "three", "app/pubsub", "easing"], function(e, t) {
		var n = t.camera,
			r = t.scene,
			i = t.renderer,
			s = undefined,
			o = undefined,
			u = undefined,
			a = !1,
			f = 0,
			l = !1,
			c = function(e, t) {
				l = !l;
				var n = l,
					r = 180,
					i = 0,
					u = 0;
				t != undefined && (f += t);
				var a = function() {
					if (n !== l) return;
					if (f > r) {
						f = r;
						return
					}
					if (f < 0) {
						f = 0;
						return
					}
					t == undefined && requestAnimationFrame(a), i = 0, u = 50, f >= i && f <= i + u && (e ? s.rotation.x = easing.easeInBounce(f - i, 0, -Math.PI / 2, u) : s.rotation.x = easing.easeOutBounce(f - i, 0, -Math.PI / 2, u)), i = 35, u = 70, f >= i && f <= i + u && (o.position.z = easing.easeInOutSine(f - i, 0, -65, u)), i = 105, u = 40, f >= i && f <= i + u && (o.position.z = easing.easeInOutSine(f - i, -65, 5, u)), i = 60, u = 60, f >= i && f <= i + u && (o.children[1].rotation.x = easing.easeOutBack(f - i, 0, .26, u), o.children[2].rotation.x = easing.easeOutBack(f - i, 0, .26, u)), i = 70, u = 50, f >= i && f <= i + u && (o.children[2].position.y = easing.easeOutBack(f - i, 25.5, 7, u), o.children[2].position.z = easing.easeOutBack(f - i, -16.5, -23.5, u)), i = 120, u = 60, f >= i && f <= i + u && (o.children[1].rotation.x = easing.easeInOutBack(f - i, .26, .42, u), o.children[2].rotation.x = easing.easeInOutBack(f - i, .26, -0.26, u), o.children[2].position.y = easing.easeInOutBack(f - i, 32.5, 10, u), o.children[2].position.z = easing.easeInOutBack(f - i, -40, -1.5, u));
					if (t != undefined) return;
					f += e ? -1 : 1
				};
				a()
			},
			h = function(e) {
				e.stopPropagation();
				var t = e.clientX,
					n = function(e) {
						e.preventDefault();
						var n = Math.round((e.clientX - t) * .5);
						t = e.clientX, c(!1, n), f < 90 && ($(document).trigger("mouseup"), A())
					},
					r = function() {
						$(document).off("mousemove", n), $(document).off("mouseup", r), $(document).off("mouseleave", r), f >= 90 && c()
					};
				$(document).on("mousemove", n), $(document).on("mouseup", r), $(document).on("mouseleave", r)
			},
			p = [],
			d = [];
		d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-meat.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-meat2.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-mountain.jpg"),
			morphTargets: !0
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-mountain_2.jpg"),
			morphTargets: !0
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-cat.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_01.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_02.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_03.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_04.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_05.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-spark_06.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-tree.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-rainbow2.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-rainbow.png"),
			transparent: !0,
			morphTargets: !0,
			side: THREE.DoubleSide,
			shading: THREE.SmoothShading
		})), d.push(new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("/txt-drum.jpg"),
			morphTargets: !0,
			shading: THREE.SmoothShading
		}));
		for (var v = 0; v < d.length; v++) d[v].index0AttributeName = "position";
		var m = new THREE.ObjectLoader;
		m.load("/anims.js", function(e) {
			p = e.children
		});
		var g = function(e, t) {
				var n = e.duration / e.length;
				e.time += e.direction * t;
				if (e.time > e.duration) return !0;
				t = e.startKeyframe + THREE.Math.clamp(Math.floor(e.time / n), 0, e.length - 1), t !== e.currentKeyframe && (e.morphTargetInfluences[e.lastKeyframe] = 0, e.morphTargetInfluences[e.currentKeyframe] = 1, e.morphTargetInfluences[t] = 0, e.lastKeyframe = e.currentKeyframe, e.currentKeyframe = t), n = e.time % n / n, e.directionBackwards && (n = 1 - n), e.morphTargetInfluences[e.currentKeyframe] = n, e.morphTargetInfluences[e.lastKeyframe] = 1 - n
			},
			y = !1,
			b = function(e) {
				y || (y = !0, $.publish("messageOn", ["You can press and hold to<br />play longer notes too!!", "img-char_004.png", 300]));
				switch (e) {
					case 0:
						if (Math.round(Math.random() * 3) == 0) {
							b("0b");
							return
						}
						var t = new THREE.MorphAnimMesh(p[0].geometry, d[Math.round(Math.random())]),
							n = Math.random() * 1 + 1;
						t.scale.set(n, n, n), t.position.set(10, 120, 110), t.quaternion.setFromAxisAngle(new THREE.Vector3(Math.random(), Math.random(), Math.random()), Math.PI * Math.random() * .5 - .25), t.rotation.y -= .5, t.duration = 3e3;
						break;
					case "0b":
						var t = new THREE.MorphAnimMesh(p[2].geometry, d[4]),
							n = Math.random() * .2 + .4;
						t.scale.set(n, n, n), t.position.set(15, 130, 125), t.rotation.x += Math.random() * 4 - Math.PI / 2, t.rotation.y += .5, t.duration = 3e3;
						break;
					case 1:
						var t = new THREE.MorphAnimMesh(p[1].geometry, d[Math.round(Math.random() + 2)]);
						t.position.set(-100 + Math.random() * -500, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * .7 + .3;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 2e3, b("1b");
						break;
					case "1b":
						var t = new THREE.MorphAnimMesh(p[1].geometry, d[Math.round(Math.random() + 2)]);
						t.position.set(100 + Math.random() * 500, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * .7 + .3;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 2e3;
						break;
					case 2:
						var i = Math.round(Math.random() * 10),
							s = i == 0 ? 5 : i == 1 ? 6 : i == 2 ? 8 : i > 5 ? 10 : i > 4 ? 9 : 7,
							t = new THREE.MorphAnimMesh(p[3].geometry, d[s]),
							n = Math.random() * .6 + .3;
						t.scale.set(n, n, n), t.rotation.x = Math.random() * 2.5 - 1.25, t.rotation.z = Math.random() * 2.5 - 1.25, t.rotation.y = Math.random() * Math.PI * 2, t.duration = Math.random() * 500 + 800;
						break;
					case 3:
						var t = new THREE.MorphAnimMesh(p[4].geometry, d[11]);
						t.position.set(-100 + Math.random() * -500, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * 5 + 4;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 2e3, b("3b");
						break;
					case "3b":
						var t = new THREE.MorphAnimMesh(p[4].geometry, d[11]);
						t.position.set(100 + Math.random() * 500, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * 5 + 4;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 2e3;
						break;
					case 4:
						var t = new THREE.MorphAnimMesh(p[5].geometry, d[Math.round(Math.random() * .6 + 12)]);
						t.position.set(-500 + Math.random() * 1e3, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * 15 + 7;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 1e3;
						break;
					case 5:
						var t = new THREE.MorphAnimMesh(p[6].geometry, d[14]);
						t.position.set(-500 + Math.random() * 1e3, 0, -500 + Math.random() * 1e3);
						var n = Math.random() * 5 + 2;
						t.scale.set(n, n, n), t.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI), t.duration = 1500
				}
				r.add(t);
				var o = new THREE.Clock,
					u = !1,
					a = function() {
						if (u) return;
						requestAnimationFrame(a);
						var e = o.getDelta();
						g(t, 1e3 * e) && (r.remove(t), t.remove(), u = !0)
					};
				a()
			},
			w = function(t) {
				var n = function() {};
				switch (t) {
					case 0:
						n = e.keyS();
						break;
					case 1:
						n = e.keyD();
						break;
					case 2:
						n = e.keyF();
						break;
					case 3:
						n = e.keyG();
						break;
					case 4:
						n = e.keyH();
						break;
					case 5:
						n = e.keyJ();
						break;
					case 6:
						n = e.keyK()
				}
				return n
			},
			E = $(".exp-keyboard .keys .key"),
			S = function(e) {
				e.type == "touchstart" && e.preventDefault();
				var t = w(e.key),
					n = function() {
						$(document).off("mouseup", n), $(document).off("mouseleave", n), $(document).off("touchend", n), t(), u[e.key].pressed = !1, E.eq(e.key).removeClass("active"), e.key == 6 && $.publish("dotRenderOff");
						for (var r = 0; r < u.length; r++)
							if (u[r].pressed) return;
						x = !1
					};
				$(document).on("mouseup", n), $(document).on("mouseleave", n), $(document).on("touchend", n), u[e.key].pressed = !0, E.eq(e.key).addClass("active"), e.key == 6 && $.publish("dotRenderOn"), x || T()
			};
		E.on("mousedown", function(e) {
			e.key = $.inArray(this, E), S(e)
		}), E.on("touchstart", function(e) {
			e.key = $.inArray(this, E), S(e)
		});
		var x = !1,
			T = function() {
				x = !0;
				var e = 0,
					t = 3,
					n = function(r) {
						if (!x) return;
						requestAnimationFrame(n);
						if (!r || r - e < 1e3 / t) return;
						e = r, u[0].pressed && b(0), u[1].pressed && b(1);
						if (u[2].pressed)
							for (var i = 0; i < 20; i++) b(2);
						u[3].pressed && b(3), u[4].pressed && b(4), u[5].pressed && b(5)
					};
				n()
			},
			N = [null, null, null, null, null, null, null],
			C = function(e) {
				var t = -1;
				switch (e.which) {
					case 83:
						t = 0;
						break;
					case 68:
						t = 1;
						break;
					case 70:
						t = 2;
						break;
					case 71:
						t = 3;
						break;
					case 72:
						t = 4;
						break;
					case 74:
						t = 5;
						break;
					case 75:
						t = 6
				}
				if (t == -1) return;
				e.preventDefault(), u[t].pressed || (N[t] = w(t), E.eq(t).addClass("active"), t == 6 && $.publish("dotRenderOn")), u[t].pressed = !0, x || T()
			},
			k = function(e) {
				var t = -1;
				switch (e.which) {
					case 83:
						t = 0;
						break;
					case 68:
						t = 1;
						break;
					case 70:
						t = 2;
						break;
					case 71:
						t = 3;
						break;
					case 72:
						t = 4;
						break;
					case 74:
						t = 5;
						break;
					case 75:
						t = 6
				}
				if (t == -1) return;
				N[t](), u[t].pressed = !1, E.eq(t).removeClass("active"), t == 6 && $.publish("dotRenderOff");
				for (var n = 0; n < u.length; n++)
					if (u[n].pressed) return;
				x = !1
			},
			L = function(e) {
				a = !0, $(".exp-keyboard")[0].style.display = "block", $(".interface .menu-prompt")[0].style.display = "none", $(".exp-keyboard .close-prompt").on("click", A), $(document).on("keydown", C), $(document).on("keyup", k), c()
			},
			A = function() {
				a = !1, $(".exp-keyboard")[0].style.display = "none", $(".interface .menu-prompt")[0].style.display = "block", $(".exp-keyboard .close-prompt").off("click", A), $(document).off("keydown", C), $(document).off("keyup", k);
				for (var e = 0; e < 7; e++) u[e].pressed = !1;
				$.publish("resetViewport", []), c(!0), $.publish("dotRenderOff")
			},
			O = function(e) {
				a || L(e)
			},
			M = function() {
				if (!a) return;
				for (var e = 0; e < u.length; e++) u[e].rotation.x = u[e].pressed ? -0.1 : 0
			};
		return {
			porte: function(e, t) {
				e.on("mousedown", O), s = t
			},
			keyboard: function(e, t) {
				e.on("mousedown", h), o = t
			},
			keys: function(e, t) {
				e.on("mousedown", S), u = t
			},
			update: M
		}
	}), define("app/messages", ["jquery", "app/scene", "app/pubsub", "three", "easing"], function(e, t) {
		var n = t.camera,
			r = e(".interface .message"),
			i = e(".interface .message .content"),
			s = e(".interface .message .char")[0],
			o = e(".interface .pointer"),
			u = "",
			a = !1,
			f = undefined,
			l = undefined,
			c = function(e, t) {
				l = t
			};
		e.subscribe("loadedObjects", c);
		var h = 0,
			p = !1,
			d = function(e) {
				p = !p;
				var t = p,
					n = 140,
					s = 0,
					o = 0,
					a = function() {
						if (t !== p) return;
						h += e ? -1 : 1;
						if (h > n) {
							h = n, i.html(u), d(!0);
							return
						}
						if (h < 0) {
							h = 0;
							return
						}
						if (h == 90) return;
						requestAnimationFrame(a), s = 0, o = 70, h >= s && h <= s + o && (r[0].style.webkitTransform = "translate3d(0px, " + easing.easeInOutExpo(h - s, 200, -200, o) + "px, 0px)", r[0].style.transform = "translate3d(0px, " + easing.easeInOutExpo(h - s, 200, -200, o) + "px, 0px)"), s = 20, o = 70, h >= s && h <= s + o && (i[0].style.webkitTransform = "translate3d(" + easing.easeInOutExpo(h - s, -100, 100, o) + "%, 0px, 0px)", i[0].style.transform = "translate3d(" + easing.easeInOutExpo(h - s, -100, 100, o) + "%, 0px, 0px)"), s = 90, o = 50, h >= s && h <= s + o && (i[0].style.webkitTransform = "translate3d(" + easing.easeInOutExpo(h - s, 0, -100, o) + "%, 0px, 0px)", i[0].style.transform = "translate3d(" + easing.easeInOutExpo(h - s, 0, -100, o) + "%, 0px, 0px)")
					};
				a()
			},
			v = 0,
			m = !1,
			g = function(e, t, n) {
				m = !m;
				var r = m,
					i = 70,
					s = 0,
					u = 0,
					a = function() {
						if (r !== m) return;
						v += e ? -1 : 1;
						if (v > i) {
							v = i;
							return
						}
						if (v < 0) {
							v = 0, t !== undefined ? w(t, n) : o[0].style.display = "none";
							return
						}
						requestAnimationFrame(a), s = 0, u = 70, v >= s && v <= s + u && (o[0].style.opacity = easing.easeInOutExpo(v - s, 0, 1, u))
					};
				a()
			},
			y = !1,
			b = function(e) {
				y = !y;
				var t = y,
					n = 0,
					r = function() {
						if (t !== y) return;
						n++;
						if (n > e) {
							x();
							return
						}
						requestAnimationFrame(r)
					};
				e !== !1 && r()
			},
			w = function(e, t) {
				a = !0, f = l[e], f || (f = e), TweenLite.set(o, {
					rotationZ: t
				}), o[0].style.display = "block", g()
			},
			E = function(e, t, n, r, o, u) {
				if (h !== 0) {
					S(e, t, n, r, o, u);
					return
				}
				i.html(t), s.src = "/" + n, o !== undefined && w(o, u), d(), b(r)
			},
			S = function(e, t, n, r, o, f) {
				u = t, o !== undefined ? g(!0, o, f) : a && (a = !1, g(!0)), h < 90 && (s.src = "/" + n, i.html(u), h = 0), d(), b(r)
			},
			x = function(e, t) {
				d(!0), a && (a = !1, g(!0))
			};
		e.subscribe("messageOn", E), e.subscribe("messageOff", x);
		var T = new THREE.Projector,
			N = function() {
				if (!a) return;
				if (!f) return;
				if (f == "menu") {
					TweenLite.set(o, {
						left: WIDTH - 50,
						top: 50
					});
					return
				}
				var e = f.position.clone();
				T.projectVector(e, n);
				var t = {
					x: (e.x + 1) / 2 * WIDTH,
					y: -((e.y - 1) / 2) * HEIGHT
				};
				TweenLite.set(o, {
					left: t.x,
					top: t.y
				})
			};
		return {
			update: N
		}
	}), define("app/interaction", ["jquery", "app/scene", "app/objects", "app/winder", "app/slider", "app/cameraAnimation", "app/expVinyl", "app/expVortex", "app/expManivelle", "app/expKeyboard", "app/messages", "app/sfx", "app/pubsub", "three", "AudioContextMonkeyPatch"], function(e, t, n, r, i, s, o, u, a, f, l, c) {
		var h = t.camera,
			p = t.scene,
			d = t.renderer,
			v = "arm";
		e.subscribe("freeMode", function() {
			v = "free", R.turntable = !0, R.porte = !0, R.cone = !0, setTimeout(function() {
				R.turntable = !1, R.porte = !1, R.cone = !1
			}, 2e3)
		});
		var m = e({}),
			g = e({}),
			y = e({}),
			b = e({}),
			w = e({}),
			E = e({}),
			S = e({}),
			x = new s(t);
		new r(m), i(g);
		var T = undefined,
			N = undefined,
			C = undefined,
			k = undefined,
			L = undefined,
			A = undefined,
			O = [],
			M = undefined,
			_ = undefined,
			D = function(e, t, n, r) {
				T = t.manivelle, N = t.porte, C = t.cone, k = t.arm, L = t.turntable, A = t.keyboard;
				for (var i = 0; i < 7; i++) A.children[2].children[i].pressed = !1, O.push(A.children[2].children[i]);
				a.manivelle(T), a.arm(k), o.vinyl(b, L), u.cone(w, x), f.porte(y, N), f.keyboard(E, A), f.keys(S, O), M = n, _ = r
			};
		e.subscribe("loadedObjects", D);
		var P = new THREE.Projector,
			H = function(e) {
				e = e.type == "touchstart" ? e.originalEvent.touches[0] : e;
				var t = {
						x: e.clientX / WIDTH * 2 - 1,
						y: -(e.clientY / HEIGHT) * 2 + 1
					},
					n = new THREE.Vector3(t.x, t.y, .5);
				h.updateMatrixWorld(), h.updateProjectionMatrix(), P.unprojectVector(n, h);
				var r = new THREE.Raycaster(h.position, n.sub(h.position).normalize()),
					i = v == "keyboard" ? O.concat(A.children) : v == "vinyl" ? L.children : v == "arm" ? k.children[1].children.concat(k.children[0]) : v == "manivelle" ? k.children[1].children.concat(k.children[0], T.children) : v == "free" ? k.children[1].children.concat(k.children[0], T.children, C.children, N.children, L.children) : [],
					s = r.intersectObjects(i);
				return s
			},
			B = function(n, r) {
				n.stopPropagation(), n = n.type == "touchstart" ? n.originalEvent.touches[0] : n;
				var i = e.Event("mousedown");
				i.clientX = n.clientX, i.clientY = n.clientY;
				var s = undefined,
					o = r[0].object.parent.name;
				switch (o) {
					case "turntable":
						s = b, i.object = L, i.stage = t;
						if (v == "vinyl") {
							var u = L.position.clone();
							P.projectVector(u, h);
							var a = {
								x: (u.x + 1) / 2 * WIDTH,
								y: -((u.y - 1) / 2) * HEIGHT
							};
							i.objectX = a.x, i.objectY = a.y
						} else x.animate({
							position: new THREE.Vector3(130, 295, -51),
							target: new THREE.Vector3(0, 50, 0),
							duration: 100,
							restartControl: !0
						}), v = "vinyl", e.publish("messageOn", ["Spin it like you mean it!", "img-char_002.png", 150]), V && at(), q(), U(n);
						break;
					case "porte":
						s = y, x.animate({
							position: new THREE.Vector3(640, 480, -640),
							target: new THREE.Vector3(0, 80, 0),
							duration: 100,
							restartControl: !0
						}), v = "keyboard", e.publish("messageOn", ["Play like Georgio!<br />Smash those keys", "img-char_006.png", 150]), V && at();
						break;
					case "cone":
						s = w, i.object = C, i.stage = t, x.animate({
							position: new THREE.Vector3(380, 260, 180),
							target: new THREE.Vector3(-40, 110, 100),
							duration: 100,
							ease: "easeInOutSine",
							id: "vortex"
						}), v = "vortex", e.publish("messageOn", ["Please Be gentle", "img-char_008.png", 150]), V && at();
						break;
					case "manivelle":
						s = m;
						var u = T.position.clone();
						P.projectVector(u, h);
						var a = {
							x: (u.x + 1) / 2 * WIDTH,
							y: -((u.y - 1) / 2) * HEIGHT
						};
						i.objectX = a.x, i.objectY = a.y;
						if (audio.source.playbackState == 0 || audio.source.playbackState == undefined) audio.source.start(0), audio.beatSource.start(0), audio.source.playbackRate.value = .001, audio.beatSource.playbackRate.value = audio.source.playbackRate.value, audio.source.playbackState == undefined && (audio.source.playbackState = 1);
						break;
					case "arm":
					case "armRaise":
						s = g, v == "arm" && (v = "manivelle", e.publish("messageOn", ["Now crank this like you<br />would at home alone", "img-char_005.png", 500, "manivelle", 130]));
						break;
					case "keys":
						s = S, i.key = e.inArray(r[0].object, O);
						break;
					case "keyboard":
						s = E
				}
				if (!s) return;
				s.trigger(i)
			},
			j = function(t) {
				t.type == "touchstart" && t.preventDefault(), e(d.domElement).off("mousemove", U);
				var n = function(t) {
					e(d.domElement).on("mousemove", U), e(document).off("mouseup", n), e(document).off("mouseleave", n)
				};
				e(document).on("mouseup", n), e(document).on("mouseleave", n);
				if (v == "vortex") return;
				var r = H(t);
				if (r.length < 1) return;
				B(t, r)
			},
			F = undefined,
			I = undefined,
			q = function() {
				I && (e(".gramophone").css("cursor", "url(/cur-move.png) 16 16, auto"), F = undefined, I = undefined)
			},
			R = {
				turntable: !1,
				porte: !1,
				cone: !1
			},
			U = function(t) {
				if (v == "vortex") {
					q();
					return
				}
				var n = H(t);
				if (n.length < 1) {
					q();
					return
				}
				if (n[0].object.parent.name == F) return;
				q(), F = n[0].object.parent.name, I = !0;
				var r, i = "0 0";
				switch (F) {
					case "turntable":
						r = v == "vinyl" ? "cur-scratch.png" : "cur-vinyl.png", i = v == "vinyl" ? "20 110" : "46 46";
						if (R.turntable) break;
						e.publish("messageOn", ["Click the vinyl!<br />Let's go for a spin", "img-char_001.png", 200]), R.turntable = !0, R.porte = !1, R.cone = !1;
						break;
					case "porte":
						r = "cur-key.png", i = "46 46";
						if (R.porte) break;
						e.publish("messageOn", ["Open the door!<br /> Let's have a jam!", "img-char_006.png", 200]), R.turntable = !1, R.porte = !0, R.cone = !1;
						break;
					case "cone":
						r = "cur-cone.png", i = "46 46";
						if (R.cone) break;
						e.publish("messageOn", ["Click here to dive<br />into this dirty hole", "img-char_007.png", 200]), R.turntable = !1, R.porte = !1, R.cone = !0;
						break;
					case "manivelle":
						r = "cur-manivelle.png", i = "68 16";
						break;
					case "arm":
					case "armRaise":
						r = "cur-hand.png", i = "5 5";
						break;
					case "keys":
						r = "cur-point.png", i = "0 70";
						break;
					case "keyboard":
						r = "cur-hand.png", i = "5 5"
				}
				e(".gramophone").css("cursor", "url(/" + r + ") " + i + ", auto")
			},
			z = function(e, t) {
				x.animate({
					position: new THREE.Vector3(435, 385, -440),
					target: new THREE.Vector3(0, 80, 0),
					duration: 100,
					restartControl: !0
				}), v = "free"
			};
		e.subscribe("resetViewport", z);
		var W = e(".interface .menu-prompt"),
			X = e(".interface .menu-overlay"),
			V = !1,
			$ = THREE.ImageUtils.loadTexture("/bg-dead_pirates_pattern.jpg");
		$.wrapS = $.wrapT = THREE.RepeatWrapping, $.repeat.set(4, 4);
		var J = new THREE.Mesh(new THREE.PlaneGeometry(2e3, 2e3, 1, 1), new THREE.MeshBasicMaterial({
			map: $
		}));
		J.position.z = -100;
		var K = new THREE.Object3D;
		K.add(J), sceneMenu.add(K);
		var Q = new THREE.LineBasicMaterial({
				color: 16777215,
				linewidth: 2
			}),
			G = new THREE.SpriteMaterial({
				map: THREE.ImageUtils.loadTexture("/txt-point.png")
			}),
			Y = function(e, t, n) {
				var r = new THREE.Geometry;
				r.vertices.push(new THREE.Vector3(e, t, n)), r.vertices.push(new THREE.Vector3(0, 100, 0));
				var i = new THREE.Line(r, Q);
				return sceneMenuUI.add(i), spr = new THREE.Sprite(G), spr.scale.set(16, 16, 16), spr.position.set(e, t, n), sceneMenuUI.add(spr), i
			},
			Z = function(e, t) {
				var n = {
					x: e / WIDTH * 2 - 1,
					y: -(t / HEIGHT) * 2 + 1
				};
				h.updateMatrixWorld(), h.updateProjectionMatrix();
				var r = new THREE.Vector3(n.x, n.y, .5);
				P.unprojectVector(r, h);
				var i = r.sub(h.position).normalize(),
					s = Math.sqrt(h.position.x * h.position.x + h.position.y * h.position.y + h.position.z * h.position.z),
					o = h.position.clone().add(i.multiplyScalar(s));
				return o
			},
			et = Y(42.24, 135.2, 117.4),
			tt = Y(0, 35.87, -73.14),
			nt = Y(7.47, 72.66, -4.61),
			rt = 0,
			it = !1,
			st = function(e) {
				it = !it;
				var t = it,
					n = 100,
					r = 0,
					i = 0,
					s = function() {
						if (t !== it) return;
						rt += e ? -1 : 1;
						if (rt > n) {
							rt = n;
							return
						}
						if (rt < 0) {
							rt = 0;
							return
						}
						if (rt == 90) return;
						requestAnimationFrame(s), r = 0, i = 70, rt >= r && rt <= r + i && ($container[0].style.webkitTransform = "translate3d(0px, " + easing.easeInOutExpo(rt - r, 200, -200, i) + "px, 0px)"), r = 20, i = 70, rt >= r && rt <= r + i && ($content[0].style.webkitTransform = "translate3d(" + easing.easeInOutExpo(rt - r, -100, 100, i) + "%, 0px, 0px)"), r = 90, i = 50, rt >= r && rt <= r + i && ($content[0].style.webkitTransform = "translate3d(" + easing.easeInOutExpo(rt - r, 0, -100, i) + "%, 0px, 0px)")
					};
				s()
			},
			ot = function() {
				V = !0, x.animate({
					position: new THREE.Vector3(358, 400, -391),
					target: new THREE.Vector3(0, 80, 0),
					duration: 100,
					restartControl: !0
				});
				if (!audio) return;
				audio.lowPassFilterMenu.frequency.value = 500
			},
			ut = function() {
				V = !1;
				if (!audio) return;
				audio.lowPassFilterMenu.frequency.value = 22e3
			},
			at = function(t) {
				var n = V ? ut : ot;
				n(), e.publish("menuRender"), X.toggleClass("active")
			},
			ft = function() {
				if (!V) return;
				K.quaternion.copy(h.quaternion), J.position.z = -1300 + Math.sqrt(h.position.x * h.position.x + h.position.y * h.position.y + h.position.z * h.position.z), M.manivelle.rotation.x = T.rotation.x, _.manivelle.rotation.x = T.rotation.x, M.arm.rotation.y = k.rotation.y, _.arm.rotation.y = k.rotation.y, M.arm.children[1].rotation.z = k.children[1].rotation.z, _.arm.children[1].rotation.z = k.children[1].rotation.z, et.geometry.vertices[1].copy(Z(WIDTH * .2, HEIGHT * .3)), et.geometry.verticesNeedUpdate = !0, tt.geometry.vertices[1].copy(Z(WIDTH * .8, HEIGHT * .7)), tt.geometry.verticesNeedUpdate = !0, nt.geometry.vertices[1].copy(Z(WIDTH * .7, HEIGHT * .15)), nt.geometry.verticesNeedUpdate = !0
			},
			lt = function(t) {
				var n = audio.gain.gain.value;
				audio = c.play(), audio.source.playbackRate.value = .001, audio.beatSource.playbackRate.value = .001, audio.gain.gain.value = n, audio.source.onended = lt;
				var r = function() {
					TweenLite.to(e(".restart-popin .clouds-bottom"), .5, {
						y: 100
					}), TweenLite.to(e(".restart-popin .clouds-top"), .5, {
						y: -100
					}), TweenLite.to(e(".restart-popin"), .5, {
						opacity: 0,
						onComplete: function() {
							TweenLite.set(e(".restart-popin"), {
								display: "none"
							})
						}
					}), e(".restart-popin .restart-prompt").off("click", r), v = "arm", e.publish("messageOn", ["Drop the needle on the <br /> motherfuckin' vinyl", "img-char_005.png", 200, "arm", -130]), e.publish("reset"), e(d.domElement).on("touchstart", j), e(d.domElement).on("mousedown", j), e(d.domElement).on("mousemove", U)
				};
				TweenLite.set(e(".restart-popin"), {
					display: "block",
					opacity: 0
				}), TweenLite.to(e(".restart-popin"), 1, {
					opacity: 1
				}), TweenLite.to(e(".restart-popin .clouds-bottom"), 1, {
					y: 0
				}), TweenLite.to(e(".restart-popin .clouds-top"), 1, {
					y: 0
				}), e(".restart-popin .restart-prompt").on("click", r), q(), e(d.domElement).off("touchstart", j), e(d.domElement).off("mousedown", j), e(d.domElement).off("mousemove", U), e(document).trigger("mouseup"), v == "vortex" && e(".exp-vortex .close-prompt").trigger("click"), v == "vinyl" && e(".exp-vinyl .close-prompt").trigger("click"), v == "keyboard" && e(".exp-keyboard .close-prompt").trigger("click")
			},
			ct = function() {
				e(d.domElement).on("touchstart", j), e(d.domElement).on("mousedown", j), e(d.domElement).on("mousemove", U), W.on("click", at), audio.source.onended = lt, x.animate({
					position: new THREE.Vector3(485, 210, -470),
					target: new THREE.Vector3(0, 80, 0),
					duration: 200,
					restartControl: !0,
					ease: "easeInOutSine"
				}), c.ambience()
			};
		e.subscribe("setListeners", ct);
		var ht = function() {
			a.update(), o.update(), f.update(), u.update(), l.update(), ft()
		};
		return ht
	}), define("app/webAudio", ["app/scene", "three"], function(e) {
		var t = e.camera,
			n = new Uint8Array(16),
			r = !1,
			i = $(".logo, .menu-prompt, .sound, .share, .store"),
			s = !1;
		$.subscribe("intube", function() {
			s = !s
		});
		var o = function() {
			if (!audio) return;
			var e = t.position,
				n = s ? .001 : Math.atan2(e.z, e.x) * 180 / Math.PI;
			n = n == 0 ? .001 : n;
			var r = (Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z) - 270) / 730;
			r = r < 0 ? 0 : r > 1 ? 1 : r;
			var i = 1 + r * 1,
				o = Math.abs(n) / n * .5 * i,
				u = o * Math.sin(Math.PI * n / 90 - Math.PI / 2) + o,
				a = -Math.sin(Math.PI * n / 180 - Math.PI / 2) * i;
			audio.panner.setPosition(u, 0, a);
			var f = new THREE.Vector3(-u, 0, -a);
			f.normalize(), audio.panner.setOrientation(f.x.toFixed(1), 0, f.z.toFixed(1));
			var n = Math.abs(n);
			if (n < 80) audio.lowPassFilter.frequency.value = 22e3;
			else {
				var l = (100 - (n - 80)) / 100;
				audio.lowPassFilter.frequency.value = 1200 + l * 4100
			}
			audio.revbVolume.gain.value = r * .15
		};
		return {
			update: o
		}
	}), define("app/gameloop", ["jquery", "app/scene", "app/render", "app/interaction", "app/webAudio", "app/pubsub", "three"], function(e, t, n, r, i) {
		var s = t.controls,
			o = t.camera,
			u = -1,
			a = 30,
			f = function(e) {
				requestAnimationFrame(f);
				if (e - u < 1e3 / a) return;
				u = e, s.update(), r(), n(), i.update()
			};
		return f
	}), define("app/lineAnimationData", [], function() {
		return [{
			clip: "M739,1c-20.27,13.689-41.215,26.202-63.375,36.631c-1.166,0.548-2.457,2.261-2.525,3.498c-2.189,39.087-11.656,76.476-26.164,112.684c-1.408,3.515-1.016,5.983,3.055,8.41c1.391-2.371,3.18-4.521,4.023-6.995c12.064-35.327,23.977-70.705,36.002-106.045c1.266-3.724,2.703-7.456,4.611-10.878c2.057-3.69,4.963-4.014,7.457-0.645c1.873,2.533,3.43,5.817,3.732,8.903c1.057,10.734,1.484,21.529,2.189,32.298c0.562,8.591,1.18,17.178,1.775,25.818c5.379,0.337,10.244,0.643,15.111,0.949c0.18,0.628,0.361,1.256,0.543,1.884c-2.742,1.508-5.33,3.526-8.26,4.415c-5.742,1.743-7.176,5.255-7.367,11.044c-0.383,11.476-3.131,22.55-9.971,32.124c-1.816,2.541-4.049,4.93-6.521,6.828c-8.309,6.381-19.543,2.198-22.225-8.148c-0.646-2.489-1.01-5.051-1.674-8.454c-3.26,5.432-5.848,10.293-8.953,14.798c-5.641,8.186-8.238,8.844-17.844,6.277c-1.207-0.323-3.312,0.834-4.307,1.934c-3.549,3.92-6.418,8.512-10.24,12.112c-6.902,6.501-12.014,5.191-16.105-3.5c-0.42-0.891-0.895-1.757-1.811-3.55c-1.596,2.553-2.904,4.671-4.238,6.774c-3.166,4.992-5.918,10.324-9.637,14.865c-3.744,4.574-7.049,4.075-10.393-0.795c-1.281-1.867-1.85-4.21-2.957-6.219c-0.666-1.21-1.742-2.193-2.633-3.279c-1.168,0.99-2.652,1.776-3.443,3.008c-2.133,3.324-3.799,6.951-5.959,10.255c-5.299,8.106-10.924,8.634-15.164,0.242c-1.482-2.935-4.426-2.337-6.271,0.838c-2.648,4.552-5.16,9.214-8.203,13.491c-1.57,2.205-3.957,4.051-6.344,5.409c-5.227,2.974-10.246,1.428-11.787-4.335c-1.602-5.981-2.459-12.35-2.438-18.544c0.066-19.477,4.383-38.327,9.748-56.93c2.092-7.251,4.783-14.33,7.16-21.5c0.342-1.034,0.455-2.143,0.865-4.15c-4.746,2.615-8.555,5.11-12.672,6.892c-6.582,2.85-10.996,1.272-13.127-4.115c-2.734-6.916,3.094-16.417,11.018-16.042c-0.725,2.599-1.438,4.958-2.02,7.35c-0.213,0.87-0.111,1.817-0.152,2.729c1.031-0.062,2.316,0.246,3.047-0.254c2.721-1.862,5.467-3.776,7.83-6.058c6.828-6.6,13.381-13.487,20.26-20.03c1.643-1.562,5.414-3.6,6.008-3.048c1.984,1.838,3.621,4.628,4.135,7.296c0.422,2.188-0.652,4.84-1.562,7.085c-11.727,28.917-20.809,58.638-26.967,89.224c-1.045,5.191-0.977,10.607-1.424,15.921c0.592,0.205,1.182,0.41,1.773,0.615c1.115-1.45,2.535-2.757,3.295-4.374c4.271-9.086,9.104-18,12.322-27.458c2.627-7.716,3.186-16.126,4.787-24.203c3.746-18.883,6.826-37.986,15.115-55.593c3.014-6.398,6.529-12.718,10.84-18.281c2.248-2.903,6.82-5.831,10.158-5.633c4.861,0.289,7.354,5.064,7.869,10.101c0.414,4.044,0.695,8.102,1.156,13.585c2.984-3.535,5.477-6.486,7.967-9.438c-5.586,35.269-15.697,69.745-15.74,105.792c20.078-40.48,28.861-84.209,37.592-128.897c-7.354,0.865-14.496,1.705-21.637,2.544c-0.301-0.623-0.6-1.246-0.898-1.869c1.52-1.454,2.814-3.323,4.6-4.287c5.816-3.14,11.674-6.288,17.789-8.754c3.547-1.431,6.041-3.128,6.762-6.958c0.059-0.319,0.197-0.652,0.387-0.914c1.549-2.131,3.117-4.246,4.68-6.366c1.467,2.053,2.936,4.106,4.451,6.226C674.747,23.672,703.874,11.836,733,0C735,0.333,737,0.667,739,1z M654.495,47.109c-7.049,1.016-12.148,2.941-12.881,10.782c-0.434,4.667-2.395,9.188-3.635,13.783c-7.451,27.587-14.65,55.246-22.502,82.718c-1.994,6.978-1.26,13.368,0.482,19.888c1.258,4.713,4.012,5.452,6.834,1.551c4.137-5.717,7.691-11.917,10.889-18.218c1.242-2.447,1.076-5.725,1.141-8.633c0.268-11.725-1.506-23.865,0.951-35.09c4.34-19.819,11.248-39.073,17.012-58.584C653.551,52.711,653.905,49.996,654.495,47.109z M563.028,192.648c13.648-11.879,29.773-94.208,23.145-111.209C563.745,115.56,564.094,154.232,563.028,192.648z M641.245,130.723c0.76,0.305,1.52,0.61,2.281,0.916c1.176-2.023,2.658-3.931,3.463-6.091c1.717-4.605,3.129-9.327,4.582-14.027c4.652-15.053,9.371-30.088,13.84-45.196c1.629-5.506,0.783-11.013-2.072-14.705C652.583,77.53,645.211,103.656,641.245,130.723z M694.282,63.629c-0.619-0.055-1.238-0.11-1.857-0.166c-3.568,17.985-9.049,35.549-12.137,54.631c5.594-4.095,10.074-7.171,14.279-10.586c1.189-0.965,2.266-2.948,2.213-4.423c-0.441-12.449-1.146-24.889-1.816-37.329C694.924,65.038,694.518,64.338,694.282,63.629zM697.053,124.909c-0.381-0.52-0.764-1.04-1.145-1.559c-1.959,1.033-4.395,1.635-5.787,3.178c-4.789,5.304-7.541,11.626-7.357,18.899c0.072,2.839-0.445,7.035,3.336,7.156c1.875,0.06,4.01-3.547,5.748-5.717c0.762-0.949,0.912-2.436,1.197-3.71C694.409,137.08,695.723,130.993,697.053,124.909z M71,361.001c-7.402-3.092-8.404-10.045-8.811-16.49c-0.886-14.021,0.947-28.021,7.549-40.439c3.132-5.891,9.157-10.734,14.848-14.625c5.163-3.529,11.265-0.906,14.206,5.477c2.375,5.154,3.473,10.893,5.222,16.344c0.443,1.381,1.207,2.658,1.823,3.984c1.361-0.916,3.264-1.518,4.002-2.793c14.657-25.328,27.879-51.359,37.077-79.227c4.841-14.668,9.16-29.508,13.692-44.277c0.232-0.756,0.251-1.576,0.461-2.98c-5.424,0.02-8.826,3.408-11.846,6.486c-7.794,7.947-15.006,16.461-22.686,24.523c-3.995,4.195-8.175,8.363-12.889,11.661c-2.299,1.608-6.132,1.966-9.053,1.506c-3.498-0.55-5.808-0.543-7.598,2.962c-0.943,1.848-2.689,3.447-4.412,4.688c-1.575,1.133-4.03,2.678-5.336,2.152c-1.792-0.723-3.958-3.17-4.052-4.979c-0.361-6.898-0.028-13.841,0.192-20.762c0.115-3.615,0.535-7.22,0.818-10.828c-0.499-0.297-0.997-0.594-1.495-0.891c-1.301,1.491-3.117,2.773-3.819,4.508c-4.403,10.863-8.413,21.854-6.937,33.945c0.115,0.946-0.14,1.938-0.268,3.44c-4.739-2.783-6.666,0.295-9.208,3.367c-5.021,6.062-9.981,5.189-13.13-1.943c-0.975-2.208-1.624-4.559-2.872-8.134c-4.177,6.779-7.739,12.556-11.3,18.335c7.276-21.829,14.386-43.409,18.66-67.12c-9.428,3.543-17.631,6.664-25.865,9.707c-8.02,2.963-16.06,5.872-24.118,8.73C2.644,207.759,1.289,207.787,0,208c0-0.334,0-0.667,0-1c17.833-8.603,35.656-17.227,53.508-25.79c4.105-1.969,2.522-6,3.398-9.081c0.962-3.387,1.227-6.972,1.795-10.471c0.465,0.036,0.93,0.071,1.394,0.107c0.232,5.298,0.463,10.597,0.703,16.087c4.718-0.353,4.575-4.233,5.168-7.502c1.057-5.826,1.759-11.733,3.156-17.473c0.764-3.137,2.274-6.259,4.119-8.923c2.307-3.333,6.068-2.749,6.817,1.21c1.158,6.121,1.524,12.415,1.887,18.655c0.312,5.377,0.287,5.499,5.343,3.642c14.22-5.221,28.439-10.44,42.68-15.604c1.758-0.637,3.642-0.93,5.921-0.271c-4.77,2.482-9.448,5.162-14.327,7.407c-12.291,5.653-24.726,10.995-36.958,16.769c-1.873,0.884-3.938,3.248-4.238,5.188c-0.646,4.16-0.198,8.491-0.198,12.854c8.707-2.608,10.087-1.671,9.749,7.817c-0.301,8.436-1.362,16.842-1.949,25.271c-0.155,2.224,0.205,4.483,0.34,6.941c4.672-2.028,7.613-7.56,7.815-12.421c0.447-10.726,1.032-21.456,2.03-32.141c0.241-2.576,1.922-5.32,3.68-7.346c1.135-1.309,3.792-2.228,5.433-1.854c1.187,0.27,2.506,2.913,2.597,4.563c0.664,12.022-0.954,23.744-5.209,35.082c-0.581,1.547-0.263,3.432-0.362,5.161c2.144,0.101,4.674,0.985,6.357,0.153c4.664-2.303,7.978-5.818,9.772-11.191c7.285-21.819,21.324-37.871,42.447-47.336c3.101-1.39,4.88-3.271,6.336-6.296c6.548-13.602,13.358-27.107,24.712-37.529c2.141-1.965,4.825-3.426,7.438-4.77c3.636-1.87,7.131-1.371,9.896,1.793c2.727,3.122,2.106,6.556-0.22,10.157c-0.285-1.274-0.701-2.534-0.832-3.824c-0.535-5.283-3.808-7.1-7.904-3.604c-4.496,3.838-8.834,8.19-12.077,13.088c-4.427,6.689-7.966,14.003-11.458,21.255c-1.718,3.567-1.754,6.23,3.81,7.65c15.426,3.939,23.667,15.168,26.325,30.3c3.183,18.11,1.923,36.147-0.557,54.419c-3.49,25.713-12.891,48.641-27.383,69.789c-7.191,10.494-15.416,20.092-26.391,26.777c-15.531,9.463-30.743,8.027-45.52-2.09c-5.167-3.537-4.984-4.789-9.411,1.621c-5.525,8-13.197,13.223-22.635,15.758C75,361.001,73,361.001,71,361.001z M131.6,339.181c0.125-0.236,0.249-0.475,0.373-0.713c2.59-0.434,5.226-0.693,7.764-1.334c10.583-2.674,17.856-10.01,24.209-18.182c13.938-17.928,21.615-38.781,27.02-60.545c4.652-18.733,7.628-37.689,3.96-56.974c-1.922-10.108-6.015-18.943-17.189-22.062c-3.508-0.979-5.795-0.575-6.843,3.692c-1.607,6.537-3.966,12.887-5.876,19.355c-7.832,26.518-14.916,53.29-28.081,77.897c-7.923,14.811-15.596,29.754-23.427,44.613c-2.777,5.268-2.56,7.023,2.763,9.275C121.202,336.288,126.477,337.554,131.6,339.181zM68.036,336.132c0,2.494-0.081,4.99,0.041,7.477c0.047,0.951,0.558,1.879,0.857,2.816c1.75,5.488,4.533,6.891,9.721,4.41c8.374-4.006,14.226-10.664,18.505-18.738c0.614-1.158,0.659-2.873,0.382-4.209c-1.531-7.389-3.036-14.795-4.985-22.078c-0.903-3.377,0.877-8.586-4.155-9.613c-5.137-1.049-7.743,3.551-10.774,6.73c-0.44,0.461-0.668,1.125-1.005,1.688C70.815,314.319,68.117,324.876,68.036,336.132z M53.412,230.075c0.662,4.963,0.995,8.42,1.65,11.814c0.212,1.098,1.272,2.033,1.944,3.042c0.872-0.639,1.96-1.122,2.566-1.955c0.961-1.321,1.606-2.874,2.374-4.334c6.101-11.605,5.108-23.925,3.752-36.313c-0.45-4.115-0.308-8.297-0.805-12.404c-0.165-1.36-1.485-2.581-2.278-3.865c-0.879,1.133-2.198,2.146-2.549,3.424c-0.782,2.847-1.103,5.822-1.573,8.752C56.72,209.296,54.961,220.36,53.412,230.075zM77.113,147.293c-6.171,6.76-6.029,14.566-6.936,21.969c-0.139,1.132,1.501,3.576,2.058,3.5c1.904-0.259,5.153-1.172,5.292-2.19C78.536,163.167,80.621,155.634,77.113,147.293z M100.716,214.187c6.117-6.069,8.317-22.495,4.167-29.222C99.771,189.26,96.923,208.07,100.716,214.187z M70.127,201.713c0.813,0.058,1.627,0.115,2.44,0.173c0.962-6.062,2.029-12.108,2.792-18.194c0.142-1.129-0.941-2.41-1.458-3.622c-1.258,0.893-3.556,1.731-3.606,2.686C69.969,189.061,70.127,195.391,70.127,201.713z M304.368,149.699c1.789-4.938,3.535-9.894,5.396-14.806c0.58-1.528,1.281-3.092,2.289-4.35c0.826-1.031,2.188-1.631,3.312-2.422c0.533,1.455,1.674,2.988,1.496,4.351c-0.91,7.029-1.871,14.076-3.344,21.003c-4.998,23.501-10.613,46.878-15.178,70.461c-2.09,10.808-3.814,22.03-0.18,32.965c0.859,2.586,3.145,4.697,4.773,7.027c1.713-2.082,3.908-3.932,5.041-6.293c2.486-5.184,5.188-10.465,6.367-16.013c0.959-4.501,0.252-9.513-0.457-14.185c-2.15-14.172-1.281-28.257,2.357-41.919c4.648-17.46,10.125-34.725,15.912-51.849c3.094-9.161,9.596-16.243,17.613-21.694c7.738-5.261,13.199-3.808,16.006,5.116c1.953,6.207,2.221,12.944,3.219,19.448c0.164,1.073,0.215,2.163,0.922,3.366c12.992-28.732,16.379-61.275,34.439-87.808c0.83,0.212,1.66,0.425,2.492,0.638c-1.123,7.021-1.605,14.218-3.479,21.033c-8.066,29.333-16.578,58.543-24.834,87.824c-1.574,5.584-2.729,11.288-4.076,16.937c0.438,0.202,0.877,0.403,1.314,0.605c1.264-1.063,2.525-2.125,4.049-3.406c-0.291,6.617-0.646,12.876-0.818,19.141c-0.174,6.268-0.375,12.584,4.232,18.91c3.799-4.254,7.357-8.239,10.914-12.226c0.602,0.258,1.203,0.517,1.805,0.774c-0.352,2.745-0.498,5.539-1.119,8.223c-0.516,2.228-1.498,4.365-2.428,6.477c-3.352,7.617-3.377,7.607,0.609,15.125c-2.723-1.7-4.84-3.022-6.873-4.291c-4.67,5.436-9.109,10.604-14.223,16.557c10.457,1.512,17.154,5.939,17.967,17.373c-3.385-2.812-6.059-5.188-8.893-7.354c-4.549-3.475-9.857-3.838-14.498-1.133c-17.773,10.357-24.748,34.074-12.941,51.629c7.77,11.555,22.479,12.027,34.918,2.199c11.695-9.24,16.654-22.393,21.348-35.619c2.795-7.873,4.201-16.229,6.561-24.271c0.867-2.953,0.148-3.864-2.684-4.319c-2.336-0.375-4.576-1.349-6.857-2.058c0.096-0.411,0.189-0.823,0.285-1.235c0.391-0.191,0.773-0.529,1.174-0.554c10.752-0.642,10.383-0.685,11.785-11.54c1.986-15.379,3.678-30.891,7.18-45.953c3.299-14.188,8.809-27.86,13.252-41.79c0.355-1.115,0.465-3.06-0.162-3.565c-0.992-0.8-2.9-1.268-4.062-0.859c-1.619,0.569-3.203,1.843-4.293,3.219c-7.723,9.75-13.506,20.319-14.094,33.176c-0.143,3.114-1.334,6.181-2.041,9.269c-0.748,0.095-1.496,0.188-2.244,0.283c-1.203-3.514-3.762-7.188-3.371-10.516c1.652-14.042,5.311-27.526,14.916-38.61c5.402-6.234,11.883-10.062,20.406-9.159c2.873,0.304,4.344-1.046,6.01-3.13c5.064-6.333,10.125-12.717,15.75-18.539c4.445-4.603,10.85-4.757,14.211-1.301c4.078,4.192,5.07,13.69,1.752,17.46c-0.586,0.665-1.516,1.027-2.859,1.902c0.215-4.028,0.469-7.371,0.553-10.718c0.1-3.917-2.162-4.887-5.115-3.066c-7.658,4.724-11.592,12.516-15.496,20.19c-0.355,0.697,0.775,2.396,1.541,3.378c8.363,10.742,11.496,23.217,12.061,36.497c0.652,15.326-0.287,30.517-5.982,44.961c-5.852,14.835-16.066,25.795-30.727,32.263c-2.873,1.268-3.9,3.028-4.285,5.856c-2.746,20.111-9.346,38.828-21.691,55.051c-7.605,9.994-16.891,18.156-29.688,21.33c-19.789,4.904-37.744-8.674-39.809-25.713c-1.959-16.164,0.154-30.971,9.99-44.221c2.162-2.912,4.713-5.535,6.695-7.84c-1.588-5.153-3.32-10.766-5.486-17.789c-2.064,3.511-3.354,6.085-4.994,8.411c-3.396,4.82-6.439,10.073-10.631,14.1c-4.545,4.367-8.293,4.045-13.385,0.277c-3.213-2.379-4.676-1.824-6.119,1.836c-2.377,6.018-5.084,11.924-10.996,15.545c-7.113,4.355-11.959,3.131-15.924-4.137c-1.554-2.846-3.158-5.664-5.398-9.678c-2.268,3.742-3.833,6.527-5.591,9.186c-3.72,5.625-7.171,11.486-11.432,16.676c-3.57,4.348-8.606,5.457-13.815,2.418c-4.001-2.334-6.015-1.332-7.686,3.025c-3.229,8.42-9.799,13.471-18.668,14.27c-2.737,0.246-7.227-2.057-8.366-4.42c-2.514-5.219-4.605-11.184-4.767-16.904c-0.971-34.295,2.569-68.108,14.344-100.556c3.168-8.73,8.465-16.689,12.816-24.985c0.38-0.725,0.931-1.393,1.513-1.976c3.459-3.458,7.326-7.378,12.454-5.327c4.522,1.809,3.782,6.932,3.619,11.034c-0.664,16.655-5.619,32.401-10.416,48.172c-4.352,14.307-13.244,25.709-23.079,36.584c-1.715,1.897-3.22,4.752-3.308,7.219c-0.369,10.316-0.238,20.656-0.1,30.984c0.028,2.088,0.503,4.361,1.443,6.207c1.509,2.963,4.317,4.994,7.245,2.309c5.57-5.109,11.301-10.293,15.631-16.393c2.084-2.936,1.392-8.016,1.523-12.139c1.16-36.479,13.463-70.384,24.212-104.625c2.51-7.996,7.197-14.881,14.376-19.698c5.606-3.761,9.524-2.522,12.024,3.811c1.217,3.083,2.346,6.203,3.514,9.306C303.479,149.992,303.922,149.846,304.368,149.699z M329.139,244.872c0.609,0.053,1.217,0.105,1.826,0.16c1.387-1.721,3.045-3.291,4.102-5.194c1.834-3.309,3.561-6.725,4.869-10.267c10.506-28.461,19.301-57.426,22.572-87.689c0.693-6.433-1.152-13.418-3.072-19.772c-1.625-5.375-4.555-5.478-8.041-0.867c-2.174,2.876-3.957,6.14-5.424,9.447c-14.27,32.194-21.17,65.888-19.848,101.12C326.29,236.196,328.094,240.52,329.139,244.872z M300.403,164.908c-0.805-5.732-1.324-11.526-2.562-17.163c-0.46-2.092-2.606-3.813-3.984-5.703c-1.79,1.338-4.138,2.324-5.251,4.089c-2.182,3.463-4.092,7.22-5.389,11.098c-10.928,32.705-19.49,66.002-24.041,100.231c-0.511,3.842,0.197,7.914,0.782,11.812c0.554,3.688,3.053,3.285,4.908,1.207c2.065-2.311,3.987-4.971,5.165-7.812c6.743-16.268,13.718-32.462,19.695-49.013C295.387,197.981,300.127,181.942,300.403,164.908z M456.885,145.279c-5.73-0.297-6.42-0.088-7.783,7.366c-3.879,21.215-7.559,42.471-10.938,63.771c-0.801,5.048-0.119,10.33-0.119,15.825c1.443-0.289,2.25-0.209,2.684-0.573c7.705-6.459,14.131-13.801,17.342-23.643C464.92,187.02,461.891,166.287,456.885,145.279z M251.08,154.979c-11.684,9.585-24.653,51.799-20.134,64.831C241.675,216.179,257.856,164.808,251.08,154.979z M374.928,183.791c-0.584-0.099-1.168-0.196-1.752-0.294c-0.398,0.772-0.998,1.504-1.162,2.323c-2.363,11.788-4.93,23.546-6.857,35.405c-0.777,4.787-0.127,9.805-0.127,14.979c5.309-1.531,15.113-13.807,14.883-17.763c-0.027-0.466-0.361-0.913-0.551-1.368c-3.846-9.199-4.752-18.851-4.439-28.694C374.971,186.85,374.928,185.32,374.928,183.791z M520.243,134.792c-0.795,1.645-1.783,3.227-2.355,4.946c-3.682,11.075-7.197,22.206-10.912,33.27c-5.227,15.575-10.516,31.129-15.945,46.634c-0.738,2.105-2.436,3.873-3.688,5.798c-0.518-0.163-1.033-0.327-1.549-0.49c-0.281-1.5-0.955-3.048-0.779-4.493c1.076-8.814,1.674-17.762,3.689-26.369c4.121-17.606,9-35.036,13.664-52.513c0.936-3.505,0.283-6.263-2.854-9.094c-1.322,2.636-2.713,4.72-3.465,7.012c-4.459,13.581-8.914,27.167-13.094,40.835c-4.531,14.814-6.986,29.995-5.789,45.507c0.258,3.325,1.807,7.811,4.262,9.312c2.016,1.235,6.273-1.101,9.498-1.992c0.736-0.203,1.332-0.957,1.965-1.49c7.066-5.963,11.791-13.598,13.984-22.396c3.738-15.001,6.961-30.139,10.023-45.296c1.922-9.509,3.154-19.157,4.695-28.743C521.143,135.084,520.692,134.938,520.243,134.792z M509.901,90.051c0-1.165,0.311-2.446-0.072-3.466c-0.602-1.597-1.672-3.017-2.543-4.512c-1.488,0.876-3.605,1.398-4.338,2.699c-1.666,2.959-3.072,6.205-3.824,9.507c-1.424,6.245-2.412,12.598-3.361,18.938c-0.262,1.748,0.254,3.612,0.412,5.422c1.893-0.675,4.096-0.958,5.592-2.136c1.463-1.154,2.646-3.089,3.191-4.909c2.115-7.061,3.928-14.212,5.854-21.329C510.506,90.194,510.204,90.122,509.901,90.051z",
			path: "M29.961,257.25c12.25-16.75,30.25-68.5,27.25-100c-0.5,33.5-13,90-1,90.25s32-91.75,20.75-102.75c-14.25-6.5-8.25,93.5-5.75,101.25c-2.745-19.574,5-50.75,13-50.75s-5.06,41.5,2.25,41.5c11.75,0,31.5-46.25,20.064-53.5c-10.067-6.382-16.064,60.5,8.436,41.75",
			width: 11,
			dasharray: 635
		}, {
			clip: "",
			path: "M-2.289,208.25c33-12.75,134.75-57.25,139.75-58.25",
			width: 11,
			dasharray: 150
		}, {
			clip: "",
			path: "M114.961,225c15.751-21.001,36.792-54.523,59.751-54.333c40.358,0.333,31.596,77.602,16.333,116.332c-22.332,56.667-62.168,74.637-84.52,43.667c-8.811-12.208-12.5-74.182-38.939-13.667c-16.429,37.604,11.596,52.978,31.127,22.333c19.333-30.333,46-80,57.666-121s23.303-88.158,46.631-99c10.04-4.666,8.021,10.528,8.021,10.528",
			width: 17,
			dasharray: 755
		}, {
			clip: "",
			path: "M223.211,238.911c20.899-19.45,49.835-98.779,27.5-88.911c-21.5,9.5-40.896,122.898-29.582,141.216c10.5,17,30.582-14.216,30.082-26.716c-0.276-6.895,28.5-164.144,50-114.5c-14.5,8.5-62,128-40.5,130s51-130,55-157c-14,57.5-37.583,146.35-12.5,143.5c22-2.5,11.371-42.87,19.5-86c8.04-42.656,38-98.427,39.836-44.068c-18.5-24-50.336,127.017-29.336,112.068c12.315-8.767,24.5-50.5,33.5-93c7.296-34.454,28.001-69.427,40-108c-10,32-80,236.5-31,188c7.5-12,22.5-39.5,22.5-39.5",
			width: 13,
			dasharray: 1715
		}, {
			clip: "",
			path: "M480.434,119.425c7.946-6.971,0.983-24.809-10.223-15.925c-24.641,19.533-33.565,62.514-44.736,141.117c-14.764,103.883-99.592,91.527-79.151,28.972c12.446-38.089,37.627-24.682,43.563-11.797c8.324,7.208,7.202-25.986,17.238-22.161c14.086,5.369,58.79,3.337,61.586-56.641c3-64.351-49.635-83.596-55.912,3.009c-0.088,33.46,94.136-81.307,86.715-53.519C492.211,162,470.333,230.584,485.286,231c17.965,0.5,32.109-85.453,36.309-98.519",
			width: 18,
			dasharray: 1005
		}, {
			clip: "",
			path: "M524.045,94.666C506.378,121,522.211,125,555.711,88.5c-18.666,38.5-38.976,128.166-23.333,122.873c20.053-6.785,28.913-69.832,33.333-96.373s30.334-67.5,28-23c-18.823-12.683-51.5,101.5-32,105s29.5-100.984,45-122.742c-14.5,50.742-25.5,135.521-11,114.882s45.443-143.054,45.943-160.054c-3.5,38.5-48.443,148.414-20.943,151.414s57.262-158.216,43-141c-15.326,18.5-39.58,149.544-10.659,122.836C669.724,146.94,687.711,54.5,699.711,42.5c5.584-3.505,0.5,24,3.5,54s-5.5,78.5-22.5,61s4.674-49.498,46-51.428",
			width: 16,
			dasharray: 1730
		}, {
			clip: "",
			path: "M602.711,58C635.382,50.401,713.29,14,739-3.5",
			width: 18,
			dasharray: 150
		}, {
			clip: "",
			path: "M496.174,118.64c4.882-12.64,10.215-35.307,12.215-38.307",
			width: 16,
			dasharray: 40
		}]
	}), define("app/lineAnimation", ["app/lineAnimationData"], function(e) {
		var t = "http://www.w3.org/2000/svg",
			n = document.createElementNS(t, "svg");
		n.setAttribute("class", "dead-pirates-svg"), n.setAttribute("width", "800"), n.setAttribute("height", "400"), n.setAttribute("viewBox", "0 0 800 400"), n.style.position = "absolute", n.style.top = "53%", n.style.left = "50%", n.style.webkitTransform = "translate3d(-50%, -50%, 0px)", n.style.transform = "translate3d(-50%, -50%, 0px)";
		var r = document.createElementNS(t, "defs"),
			i = document.createElementNS(t, "clipPath");
		i.setAttribute("id", "mask-1");
		var s = document.createElementNS(t, "path");
		s.setAttribute("d", e[0].clip), i.appendChild(s), r.appendChild(i), n.appendChild(r);
		for (var o = 0; o < e.length; o++) {
			var u = document.createElementNS(t, "path");
			u.setAttribute("d", e[o].path), u.setAttribute("fill", "none"), u.setAttribute("stroke", "#fff"), u.setAttribute("stroke-linecap", "butt"), u.setAttribute("stroke-width", e[o].width), u.setAttribute("stroke-dasharray", e[o].dasharray), u.style.strokeDashoffset = e[o].dasharray, u.setAttribute("clip-path", "url(#mask-1)"), n.appendChild(u)
		}
		var a = n.cloneNode(!0);
		a.setAttribute("class", "dead-pirates-svg shadow"), isMobile || document.body.appendChild(a), document.body.appendChild(n)
	}), define("app/intro", ["app/gameloop", "app/messages", "jquery", "gsap", "app/lineAnimation"], function(e) {
		var t = $(".looneytunes div"),
			n = t.get().reverse(),
			r = function(e, t, n, r) {
				var i = [{
						s: 0,
						cp: .516,
						e: .74
					}, {
						s: .74,
						cp: .964,
						e: 1.006
					}, {
						s: 1.006,
						cp: 1.048,
						e: 1.02
					}, {
						s: 1.02,
						cp: .992,
						e: 1
					}],
					s = e / r,
					o = i.length,
					u = Math.floor(o * s),
					a, f;
				return a = (s - u * (1 / o)) * o, f = i[u], t + n * (f.s + a * (2 * (1 - a) * (f.cp - f.s) + a * (f.e - f.s)))
			},
			i = function() {
				this.target.style.webkitTransform = "translate3d(-50%, -50%, 0px)"
			},
			s = new TimelineMax({
				paused: !0,
				onComplete: function() {
					$.publish("messageOn", ["Drop the needle on the <br /> motherfuckin' vinyl", "img-char_005.png", !1, "arm", -130]), $(".intro").remove(), $(".dead-pirates-svg").remove(), s.remove()
				}
			});
		isMobile ? (s.add([TweenLite.to($(".headphones"), .5, {
			opacity: 0,
			onComplete: function() {
				$(".headphones").remove()
			}
		}), TweenLite.to($(".pause-load"), .5, {
			opacity: 0,
			onComplete: function() {
				$(".pause-load").remove()
			}
		}), TweenLite.set($(".un-logo"), {
			opacity: 1,
			delay: 1
		}), TweenLite.to($(".un-logo"), 3, {
			scale: .92,
			ease: Linear.easeNone,
			force3D: !0,
			delay: 1
		}), TweenLite.to($(".un-logo"), .5, {
			opacity: 0,
			ease: Power1.easeOut,
			delay: 2.5
		}), TweenLite.to($(".fucks-with"), .5, {
			opacity: 1,
			ease: Power1.easeIn,
			delay: 3
		}), TweenLite.to($(".fucks-with"), 2.5, {
			scale: .92,
			ease: Linear.easeNone,
			force3D: !0,
			delay: 3
		}), TweenLite.to($(".fucks-with"), .5, {
			opacity: 0,
			ease: Power1.easeOut,
			delay: 5
		})]), s.add([TweenLite.set($(".dead-pirates-svg"), {
			scale: 1,
			force3D: !0
		}), TweenLite.to($(".dead-pirates-svg path:eq(1)"), .4, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: .8
		}), TweenLite.to($(".dead-pirates-svg path:eq(2)"), .3, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: 1.1
		}), TweenLite.to($(".dead-pirates-svg path:eq(3)"), .4, {
			strokeDashoffset: 0,
			ease: Linear.easeNone,
			delay: 1.5
		}), TweenLite.to($(".dead-pirates-svg path:eq(4)"), .6, {
			strokeDashoffset: 0,
			ease: Linear.easeNone,
			delay: 2.1
		}), TweenLite.to($(".dead-pirates-svg path:eq(5)"), .6, {
			strokeDashoffset: 0,
			ease: Power1.easeInOut,
			delay: 2.7
		}), TweenLite.to($(".dead-pirates-svg path:eq(6)"), .7, {
			strokeDashoffset: 0,
			ease: Power1.easeInOut,
			delay: 3.2
		}), TweenLite.to($(".dead-pirates-svg path:eq(7)"), .4, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: 3.6
		}), TweenLite.to($(".dead-pirates-svg path:eq(8)"), .2, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: 4
		}), TweenLite.set($(".over-the-hills"), {
			opacity: 0,
			y: -700,
			delay: 3,
			force3D: !0
		}), TweenLite.set($(".intro-bottom"), {
			opacity: 0,
			y: 510,
			delay: 3,
			force3D: !0
		}), TweenLite.to($(".over-the-hills"), 1, {
			opacity: 1,
			y: -135,
			ease: r,
			delay: 3.28,
			force3D: !0
		}), TweenLite.to($(".intro-bottom"), 1, {
			opacity: 1,
			y: 95,
			ease: r,
			delay: 3.3,
			force3D: !0
		}), TweenLite.to($(".album-cover"), 1.5, {
			opacity: .2,
			ease: Power1.easeInOut,
			delay: 4
		}), TweenLite.to($(".dead-pirates-svg"), 1.2, {
			opacity: 1,
			delay: 4.2
		})]), s.add([TweenLite.to($(".grain"), 3, {
			opacity: 0,
			ease: Power1.easeInOut
		}), TweenLite.to($(".gramophone"), 3, {
			opacity: 1,
			ease: Power1.easeOut,
			delay: 1
		}), TweenLite.to($(".dead-pirates-svg"), 1, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 1
		}), TweenLite.to($(".intro-bottom"), 1, {
			opacity: 0,
			delay: 1
		}), TweenLite.to($(".over-the-hills"), 1, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 2
		}), TweenLite.to($(".interface"), 1, {
			opacity: 1,
			delay: 3
		})])) : (s.add([TweenLite.to($(".headphones"), .5, {
			opacity: 0,
			onComplete: function() {
				$(".headphones").remove()
			}
		}), TweenLite.to($(".pause-load"), .5, {
			opacity: 0,
			onComplete: function() {
				$(".pause-load").remove()
			}
		}), TweenLite.set($(".un-logo"), {
			opacity: 1,
			delay: 1
		}), TweenLite.to($(".un-logo"), 3, {
			scale: .92,
			ease: Linear.easeNone,
			force3D: !0,
			delay: 1
		}), TweenLite.to($(".un-logo"), .5, {
			opacity: 0,
			ease: Power1.easeOut,
			delay: 2.5
		}), TweenLite.set($(".looneytunes"), {
			opacity: 1,
			delay: 2.6
		}), TweenMax.staggerTo(n, 1.5, {
			scale: 1,
			ease: r,
			onComplete: i,
			force3D: !0,
			delay: 3
		}, .2), TweenLite.set($(".un-logo"), {
			scale: .4,
			y: isMobile ? -150 : -265,
			force3D: !0,
			delay: 4.6
		}), TweenLite.to($(".un-logo"), 1.5, {
			opacity: 1,
			ease: Power1.easeIn,
			delay: 5.3
		}), TweenLite.to($(".presents"), 1.5, {
			opacity: 1,
			ease: Power1.easeIn,
			delay: 5.5
		}), TweenLite.set($(".fucks-with"), {
			scale: 0,
			opacity: 1,
			delay: 1
		}), TweenLite.to($(".fucks-with"), 3, {
			scale: 1,
			ease: Elastic.easeOut,
			delay: 4.6
		}), TweenLite.to($(".album-cover"), 1.5, {
			opacity: .2,
			ease: Power1.easeInOut,
			delay: 4.7
		}), TweenLite.to($(".album-cover"), 1.2, {
			opacity: .2,
			ease: Power1.easeInOut,
			delay: 6.2
		})]), s.add([TweenLite.to($(".splash"), .7, {
			scale: 0,
			ease: Back.easeIn,
			delay: .5
		}), TweenLite.set($(".dead-pirates-svg"), {
			scale: 1,
			force3D: !0
		}), TweenLite.to($(".dead-pirates-svg"), 2.7, {
			scale: .9,
			ease: Power1.easeOut,
			delay: .8,
			force3D: !0
		}), TweenLite.to($(".dead-pirates-svg.shadow"), 2.7, {
			x: "-=15",
			y: "-=5",
			ease: Power1.easeOut,
			delay: .8
		}), TweenLite.to($(".dead-pirates-svg path:eq(1), .dead-pirates-svg path:eq(10)"), .2, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: .8
		}), TweenLite.to($(".dead-pirates-svg path:eq(2), .dead-pirates-svg path:eq(11)"), .15, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: .9
		}), TweenLite.to($(".dead-pirates-svg path:eq(3), .dead-pirates-svg path:eq(12)"), .2, {
			strokeDashoffset: 0,
			ease: Linear.easeNone,
			delay: 1
		}), TweenLite.to($(".dead-pirates-svg path:eq(4), .dead-pirates-svg path:eq(13)"), .3, {
			strokeDashoffset: 0,
			ease: Linear.easeNone,
			delay: 1.2
		}), TweenLite.to($(".dead-pirates-svg path:eq(5), .dead-pirates-svg path:eq(14)"), .3, {
			strokeDashoffset: 0,
			ease: Power1.easeInOut,
			delay: 1.5
		}), TweenLite.to($(".dead-pirates-svg path:eq(6), .dead-pirates-svg path:eq(15)"), .35, {
			strokeDashoffset: 0,
			ease: Power1.easeInOut,
			delay: 1.8
		}), TweenLite.to($(".dead-pirates-svg path:eq(7), .dead-pirates-svg path:eq(16)"), .2, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: 2
		}), TweenLite.to($(".dead-pirates-svg path:eq(8), .dead-pirates-svg path:eq(17)"), .1, {
			strokeDashoffset: 0,
			ease: Power1.easeOut,
			delay: 2.2
		}), TweenLite.set($(".over-the-hills"), {
			opacity: 1,
			y: -window.innerHeight / 2 - 200,
			delay: 1,
			force3D: !0
		}), TweenLite.set($(".intro-bottom"), {
			opacity: 1,
			y: window.innerHeight + 10,
			delay: 1,
			force3D: !0
		}), TweenLite.to($(".over-the-hills"), 1, {
			y: isMobile ? -135 : -255,
			ease: r,
			delay: 1.28,
			force3D: !0
		}), TweenLite.to($(".intro-bottom"), 1, {
			y: isMobile ? 95 : 165,
			ease: r,
			delay: 1.3,
			force3D: !0
		})]), s.add([TweenLite.to($(".album-cover"), 2, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 0
		}), TweenLite.to(t, 2, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 0
		}), TweenLite.to($(".intro-bottom"), 2, {
			opacity: 0,
			ease: Power1.easeInOut
		}), TweenLite.to($(".dead-pirates-svg.shadow"), 2, {
			opacity: 0,
			ease: Power1.easeInOut
		}), TweenLite.to($(".grain"), 3, {
			opacity: 0,
			ease: Power1.easeInOut
		}), TweenLite.to($(".dead-pirates-svg"), 2.5, {
			scale: isMobile ? .3 : .6,
			y: -30,
			ease: Power3.easeInOut,
			delay: 1,
			force3D: !0
		}), TweenLite.to($(".gramophone"), 3, {
			opacity: 1,
			ease: Power1.easeOut,
			delay: 1
		}), TweenLite.to($(".dead-pirates-svg"), 1, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 5
		}), TweenLite.to($(".over-the-hills"), 1, {
			opacity: 0,
			ease: Power1.easeInOut,
			delay: 5
		}), TweenLite.to($(".interface"), 1, {
			opacity: 1,
			delay: 6
		})])), s.addCallback(function() {
			$.publish("setListeners")
		}, 12.5), s.addCallback(e, 10.7);
		var o = function() {
			s.resume()
		};
		return {
			titleSequence: o
		}
	}), define("app/interface", ["app/scene", "jquery", "app/pubsub", "easing", "gsap"], function(e) {
		var t = e.controls,
			n = function() {
				var e = $(".interface .sound .volume-prompt"),
					t = 24,
					n = "";
				for (var r = 0; r < t; r++) n += "<li />";
				var i = $(n),
					s = i.get().reverse(),
					o = function() {
						i.removeClass("active");
						var e = Math.round(audio.gain.gain.value * t);
						for (var n = 0; n < e; n++) s[n].className = "active"
					};
				o(), $.subscribe("volumeChange", o), e.append(i);
				var u = function(t) {
						var n = t.clientY - e.offset().top,
							r = e.height();
						n = n < 0 ? 0 : n > r ? r : n;
						var i = 1 - n / r;
						audio.gain.gain.value = i, o()
					},
					a = function() {
						$(document).off("mousemove", u), $(document).off("mouseup", a), $(document).off("mouseleave", a)
					},
					f = function(e) {
						u(e), e.stopPropagation(), $(document).on("mousemove", u), $(document).on("mouseup", a), $(document).on("mouseleave", a)
					};
				e.on("mousedown", f)
			},
			r = !1,
			i = function() {
				var e = $(".interface .mute-prompt"),
					t = $(".interface .sound .volume-prompt"),
					n = 1,
					i = !1,
					s = function(e, t, n) {
						i = !i;
						var r = i,
							s = -1,
							o = function() {
								s++;
								if (r != i || s >= n) return;
								requestAnimationFrame(o), audio.gain.gain.value = easing.easeInOutExpo(s, e, t, n), audio.soundGain.gain.value = audio.gain.gain.value, $.publish("volumeChange")
							};
						o()
					},
					o = function(t) {
						e.toggleClass("active"), r = !r, r && (n = audio.gain.gain.value);
						var i = audio.gain.gain.value,
							o = r ? -n : n - audio.gain.gain.value,
							u = 20;
						if (t) {
							audio.gain.gain.value = i + o, audio.soundGain.gain.value = audio.gain.gain.value, $.publish("volumeChange");
							return
						}
						s(i, o, u)
					};
				e.on("click", o);
				var u = function() {
					r && (e.toggleClass("active"), r = !r)
				};
				t.on("mousedown", u);
				var a = !1,
					f = function(e) {
						switch (document.visibilityState) {
							case "hidden":
								r || (a = !0, o(!0));
								break;
							case "visible":
								a && o(), a = !1
						}
					};
				$(document).on("visibilitychange", f)
			},
			s = function() {
				var e = audio.source.buffer.duration,
					t = 0
			},
			o = function() {
				n(), i()
			},
			u = function() {
				var e = $(".interface .share"),
					t = $(".interface .share-prompt"),
					n = $(".interface .share .networks a"),
					r = [];
				n.each(function(e, t) {
					r.push(t)
				}), r.reverse();
				var i = function() {
						TweenLite.set(n, {
							display: "block",
							opacity: 0,
							x: 10
						}), TweenMax.staggerTo(r, .3, {
							opacity: 1,
							x: 0,
							ease: Power1.easeOut
						}, .1)
					},
					s = function() {
						TweenMax.staggerTo(r, .2, {
							opacity: 0,
							ease: Power1.easeOut,
							onComplete: function() {
								this.target.style.display = "none"
							}
						}, .1)
					};
				e.on("mouseenter", i), e.on("mouseleave", s)
			},
			a = $(".interface .store"),
			f = null,
			l = function() {
				f = document.createElement("iframe"), f.id = "bandcamp", f.src = "http://bandcamp.com/EmbeddedPlayer/album=300037325/size=large/bgcol=ffffff/linkcol=333333/transparent=true/", document.body.appendChild(f)
			};
		isMobile || l();
		var c = !1,
			h = function() {
				$(".interface, .gramophone").off("click", h), TweenLite.to(f, .5, {
					x: 350,
					ease: Power2.easeInOut,
					onComplete: function() {
						f.remove(), l(), a.on("click", p)
					}
				}), c && $(".interface .mute-prompt").trigger("click")
			},
			p = function() {
				c = !1, r || ($(".interface .mute-prompt").trigger("click"), c = !0), TweenLite.to(f, .5, {
					x: 0,
					ease: Power2.easeInOut
				}), a.off("click", p), setTimeout(function() {
					$(".interface, .gramophone").on("click", h)
				}, 0)
			};
		a.on("click", p);
		var d = function() {
				TweenLite.to($(".about-overlay"), .3, {
					scale: 1.1,
					opacity: 0,
					ease: Power1.easeIn,
					onComplete: function() {
						TweenLite.set($(".about-overlay"), {
							display: "none"
						}), $(".about-overlay .close-prompt").off("click", d), $(".about-prompt").on("click", v), t.enabled = !0
					}
				})
			},
			v = function() {
				TweenLite.set($(".about-overlay"), {
					scale: 1.1,
					opacity: 0,
					display: "block"
				}), TweenLite.to($(".about-overlay"), .5, {
					scale: 1,
					opacity: 1,
					ease: Power1.easeOut
				}), $(".about-prompt").off("click", v), $(".about-overlay .close-prompt").on("click", d), t.enabled = !1
			},
			m = function() {
				TweenLite.to($(".interface .logo"), .2, {
					opacity: 0
				}), TweenLite.to($(".about-hover"), .4, {
					x: 0,
					scale: 1,
					ease: Back.easeOut
				})
			},
			g = function() {
				TweenLite.to($(".interface .logo"), .4, {
					opacity: 1
				}), TweenLite.to($(".about-hover"), .2, {
					x: -170,
					scale: .5,
					ease: Power1.easeIn
				})
			};
		return $(".about-prompt").on("click", v), $(".about-prompt").on("mouseenter", m), $(".about-prompt").on("mouseleave", g), {
			audioInterface: o,
			shareInterface: u
		}
	});
var deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0,
	deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent),
	deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent),
	deviceIsIOSWithBadTarget = deviceIsIOS && /OS ([6-9]|\d{2})_\d/.test(navigator.userAgent),
	deviceIsBlackBerry10 = navigator.userAgent.indexOf("BB10") > 0;
FastClick.prototype.needsClick = function(e) {
	switch (e.nodeName.toLowerCase()) {
		case "button":
		case "select":
		case "textarea":
			if (e.disabled) return !0;
			break;
		case "input":
			if (deviceIsIOS && e.type === "file" || e.disabled) return !0;
			break;
		case "label":
		case "video":
			return !0
	}
	return /\bneedsclick\b/.test(e.className)
}, FastClick.prototype.needsFocus = function(e) {
	switch (e.nodeName.toLowerCase()) {
		case "textarea":
			return !0;
		case "select":
			return !deviceIsAndroid;
		case "input":
			switch (e.type) {
				case "button":
				case "checkbox":
				case "file":
				case "image":
				case "radio":
				case "submit":
					return !1
			}
			return !e.disabled && !e.readOnly;
		default:
			return /\bneedsfocus\b/.test(e.className)
	}
}, FastClick.prototype.sendClick = function(e, t) {
	var n, r;
	document.activeElement && document.activeElement !== e && document.activeElement.blur(), r = t.changedTouches[0], n = document.createEvent("MouseEvents"), n.initMouseEvent(this.determineEventType(e), !0, !0, window, 1, r.screenX, r.screenY, r.clientX, r.clientY, !1, !1, !1, !1, 0, null), n.forwardedTouchEvent = !0, e.dispatchEvent(n)
}, FastClick.prototype.determineEventType = function(e) {
	return deviceIsAndroid && e.tagName.toLowerCase() === "select" ? "mousedown" : "click"
}, FastClick.prototype.focus = function(e) {
	var t;
	deviceIsIOS && e.setSelectionRange && e.type.indexOf("date") !== 0 && e.type !== "time" ? (t = e.value.length, e.setSelectionRange(t, t)) : e.focus()
}, FastClick.prototype.updateScrollParent = function(e) {
	var t, n;
	t = e.fastClickScrollParent;
	if (!t || !t.contains(e)) {
		n = e;
		do {
			if (n.scrollHeight > n.offsetHeight) {
				t = n, e.fastClickScrollParent = n;
				break
			}
			n = n.parentElement
		} while (n)
	}
	t && (t.fastClickLastScrollTop = t.scrollTop)
}, FastClick.prototype.getTargetElementFromEventTarget = function(e) {
	return e.nodeType === Node.TEXT_NODE ? e.parentNode : e
}, FastClick.prototype.onTouchStart = function(e) {
	var t, n, r;
	if (e.targetTouches.length > 1) return !0;
	t = this.getTargetElementFromEventTarget(e.target), n = e.targetTouches[0];
	if (deviceIsIOS) {
		r = window.getSelection();
		if (r.rangeCount && !r.isCollapsed) return !0;
		if (!deviceIsIOS4) {
			if (n.identifier === this.lastTouchIdentifier) return e.preventDefault(), !1;
			this.lastTouchIdentifier = n.identifier, this.updateScrollParent(t)
		}
	}
	return this.trackingClick = !0, this.trackingClickStart = e.timeStamp, this.targetElement = t, this.touchStartX = n.pageX, this.touchStartY = n.pageY, e.timeStamp - this.lastClickTime < this.tapDelay && e.preventDefault(), !0
}, FastClick.prototype.touchHasMoved = function(e) {
	var t = e.changedTouches[0],
		n = this.touchBoundary;
	return Math.abs(t.pageX - this.touchStartX) > n || Math.abs(t.pageY - this.touchStartY) > n ? !0 : !1
}, FastClick.prototype.onTouchMove = function(e) {
	if (!this.trackingClick) return !0;
	if (this.targetElement !== this.getTargetElementFromEventTarget(e.target) || this.touchHasMoved(e)) this.trackingClick = !1, this.targetElement = null;
	return !0
}, FastClick.prototype.findControl = function(e) {
	return e.control !== undefined ? e.control : e.htmlFor ? document.getElementById(e.htmlFor) : e.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")
}, FastClick.prototype.onTouchEnd = function(e) {
	var t, n, r, i, s, o = this.targetElement;
	if (!this.trackingClick) return !0;
	if (e.timeStamp - this.lastClickTime < this.tapDelay) return this.cancelNextClick = !0, !0;
	this.cancelNextClick = !1, this.lastClickTime = e.timeStamp, n = this.trackingClickStart, this.trackingClick = !1, this.trackingClickStart = 0, deviceIsIOSWithBadTarget && (s = e.changedTouches[0], o = document.elementFromPoint(s.pageX - window.pageXOffset, s.pageY - window.pageYOffset) || o, o.fastClickScrollParent = this.targetElement.fastClickScrollParent), r = o.tagName.toLowerCase();
	if (r === "label") {
		t = this.findControl(o);
		if (t) {
			this.focus(o);
			if (deviceIsAndroid) return !1;
			o = t
		}
	} else if (this.needsFocus(o)) {
		if (e.timeStamp - n > 100 || deviceIsIOS && window.top !== window && r === "input") return this.targetElement = null, !1;
		this.focus(o), this.sendClick(o, e);
		if (!deviceIsIOS || r !== "select") this.targetElement = null, e.preventDefault();
		return !1
	}
	if (deviceIsIOS && !deviceIsIOS4) {
		i = o.fastClickScrollParent;
		if (i && i.fastClickLastScrollTop !== i.scrollTop) return !0
	}
	return this.needsClick(o) || (e.preventDefault(), this.sendClick(o, e)), !1
}, FastClick.prototype.onTouchCancel = function() {
	this.trackingClick = !1, this.targetElement = null
}, FastClick.prototype.onMouse = function(e) {
	return this.targetElement ? e.forwardedTouchEvent ? !0 : e.cancelable ? !this.needsClick(this.targetElement) || this.cancelNextClick ? (e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.propagationStopped = !0, e.stopPropagation(), e.preventDefault(), !1) : !0 : !0 : !0
}, FastClick.prototype.onClick = function(e) {
	var t;
	return this.trackingClick ? (this.targetElement = null, this.trackingClick = !1, !0) : e.target.type === "submit" && e.detail === 0 ? !0 : (t = this.onMouse(e), t || (this.targetElement = null), t)
}, FastClick.prototype.destroy = function() {
	var e = this.layer;
	deviceIsAndroid && (e.removeEventListener("mouseover", this.onMouse, !0), e.removeEventListener("mousedown", this.onMouse, !0), e.removeEventListener("mouseup", this.onMouse, !0)), e.removeEventListener("click", this.onClick, !0), e.removeEventListener("touchstart", this.onTouchStart, !1), e.removeEventListener("touchmove", this.onTouchMove, !1), e.removeEventListener("touchend", this.onTouchEnd, !1), e.removeEventListener("touchcancel", this.onTouchCancel, !1)
}, FastClick.notNeeded = function(e) {
	var t, n, r;
	if (typeof window.ontouchstart == "undefined") return !0;
	n = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
	if (n) {
		if (!deviceIsAndroid) return !0;
		t = document.querySelector("meta[name=viewport]");
		if (t && t.content.indexOf("user-scalable=no") !== -1) return !0
	}
	if (deviceIsBlackBerry10) {
		r = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
		if (r[1] >= 10 && r[2] >= 3) {
			t = document.querySelector("meta[name=viewport]");
			if (t) {
				if (t.content.indexOf("user-scalable=no") !== -1) return !0;
				if (document.documentElement.scrollWidth <= window.outerWidth) return !0
			}
		}
	}
	return e.style.msTouchAction === "none" ? !0 : !1
}, FastClick.attach = function(e, t) {
	return new FastClick(e, t)
}, typeof define == "function" && typeof define.amd == "object" && define.amd ? define("fastclick", [], function() {
	return FastClick
}) : typeof module != "undefined" && module.exports ? (module.exports = FastClick.attach, module.exports.FastClick = FastClick) : window.FastClick = FastClick, requirejs.config({
	baseUrl: "assets/js/lib",
	paths: {
		app: "../app",
		jquery: "jquery-2.1.0.min",
		three: "threejs/three.min",
		gsap: "TweenMax.min",
		stats: "threejs/stats.min"
	}
}), isMobile = !1;
for (var i = 0; i < document.body.parentNode.classList.length; i++) document.body.parentNode.classList[i] == "mobile" && (isMobile = !0);
requirejs(["app/sfx", "app/intro", "app/interface", "app/pubsub", "app/messages", "jquery", "fastclick", "gsap"], function(e, t, n) {
	function r() {
		var e = window.document,
			t = e.documentElement,
			n = t.requestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullScreen || t.msRequestFullscreen,
			r = e.exitFullscreen || e.mozCancelFullScreen || e.webkitExitFullscreen || e.msExitFullscreen;
		!e.fullscreenElement && !e.mozFullScreenElement && !e.webkitFullscreenElement && !e.msFullscreenElement ? n.call(t) : r.call(e)
	}
	audio = undefined;
	var i = function() {
		audio = e.play(), audio.source.playbackRate.value = .001, audio.beatSource.playbackRate.value = .001, n.audioInterface(), t.titleSequence(), isMobile || setTimeout(e.looney, 850)
	};
	$.subscribe("trackready", i), n.shareInterface();
	if (isMobile) {
		var s = function() {
			r(), $(document).off("touchstart", s)
		};
		$(document).on("touchstart", s)
	}
}), define("../app", function() {});